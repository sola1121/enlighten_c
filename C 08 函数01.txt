变量作用域
    在函数中的变量都是局部变量(local variable), 都是属于所在函数私有, 生命周期只存在于整个函数.
    比如: 在main函数中声明的变量, 不能直接通过其他函数调用, 得通过将值传递参数的形式来间接使用其值, 函数调用不会影响到他原本值
    要使一个变量可以不通过传参直接被调用, 可以将该变量在函数外声明, 这就是全局变量(global variable), 其生命周期从声明时开始到程序结束


--------------------------------------------------------------

函数 function
    完成特定任务的独立程序代码单元.
    C的设计思想是, 把函数用作构建块.
    C将函数看作一种派生类型, 因为其是建立在其他类型之上的, 这意味着函数也可以使用指针引用.

    函数调用(function call)表明在此处执行函数
    函数定义(function definition)明确的指定了函数要做什么

    优势
        使用函数可以重复使用代码段
        可以让程序更加模块化, 提高代码可读性

    对于函数, 若不关心其实现, 而只管使用, 可以将函数视为根据传入信息(输入)及其生成的值或响应的动作(输出)来定义的黑盒
    以这种方式看待函数可以有效的将注意力集中在程序的整体设计, 而不是函数的细节上

    函数和变量一样, 有其类型.
    一般而言, 函数原型指明了函数的返回类型和函数接受的参数类型. 这行信息称为该函数的签名(signature)

    执行完函数中的代码后, 计算机返回主调函数(calling function)继续执行下一行.

    在函数签名后需要加分号, 而在函数定义时, 右花括号结束后不需要分号

    函数可以分开放在单独的文件中, 但是需要#include宏配合头文件将不在同一个文件中的含函数引入


    典型的ANSII C函数定义的形式
        返回类型 名称(形参声明列表) {
            函数体
        }
    包含函数类型, 函数名, 和圆括号接着是左花括号, 变量声明, 函数表达式, 最后以右花括号结束
    
    形参声明列表是使用逗号分割的一系列变量声明. 除形参变量外, 函数其他变量均在函数体的花括号内声明.
    C语言规定, 在函数体内不能再出现其他函数定义.
    即除了主函数被操作系统直接调用外, 其他函数都是一个相对独立的程序块, 每个函数之间是并列的关系, 但不能相互包含.

    值传递
        实参用于把值从主调函数传递给被调函数. 该过程是通过传递值来实现的.
        可以说形参是变量, 而实参是在调用时提供的参数实际值.
        所以被调函数一般不会改变主调函数中的变量, 如果要改变, 应使用指针作为参数.
    
    函数的返回类型
        函数的返回类型指的是函数返回值的类型.
        如果返回值的类型与声明的返回类型不匹配, 返回值将被转换成函数声明的返回类型.

    函数签名
        函数的返回类型和形参列表构成了函数签名. 因此, 函数签名指定了传入函数的值的类型, 个数和函数返回值的类型.

    函数形参和其他局部变量都属于其所声明函数私有, 因此, 声明在不同函数中的同名变量完全是不同的变量.
    而且, 函数无法直接访问其他函数中的变量. 这种限制访问保护了数据的完整性.
    但是, 当确实需要在函数中访问另一个函数的数据时, 可以把指针作为函数的参数.

    对于不同函数的同名变量, 不会有名称冲突, 只是同名而使不同的变量.


函数参数
    形式参数(formal argument 或 formal parameter), 简称形参
        和定义在函数中的变量一样, 形式参数也是局部变量, 属于函数私有. 即在其他函数中使用同名变量不会引起名称冲突.
        每次调用就相当于声明并初始化这些形式参数.

        ANSII C要求在每个形式参数前都声明其类型. 不能像golang中使用同一类型的变量列表
        如
            long sum(int num1, int num2){
                return (long) num1 + num2;
            }
        但在ANSI C之前, 还可以用如下的形式, 虽已弃用, 现在编译也可以通过
            long sum(num1, num2)
            int num1;
            int num2;
            {
                return (long) num1 + num2;
            }
        或
            long sum(num1, num2)
            int num1, num2;
            {
                return (long) num1 + num2;
            }
        圆括号中只用参数名列表, 而参数的类型在后面的声明.
        通常的函数的局部变量在花括号之后声明, 而上面的变量在函数左花括号之前声明, 如果变量是同一类型, 这种形式可以用逗号分隔变量名列表

    实际参数(actual argument), 简称实参
        形式参数是被调函数(called function)中的变量, 实际参数是主调函数(calling function)赋值给被调函数具体值.
        实际参数可以是常量, 变量, 或甚至是更复杂的表达式.
        无论实际参数是何种形式都要被求值, 然后该值被拷贝给被调函数相应的形式参数, 属于值传递

        实际参数是具体的值, 该值要被赋值给作为形式参数的变量. 
        因为被调函数使用的值是从主调函数中拷贝而来的, 所以无论被调函数对拷贝数据进行什么操作, 都不会影响主调函数中的原始数据.

        实际参数是出现在函数调用圆括号中的表达式.
        形式参数是函数定义的函数头中声明的变量.

    函数传参
        一个函数如果想要调用另一个函数中声明的变量是不行的, 所以有了传递参数值的方式.
        如某个函数想要直接调用main中的变量, 这是不可行的, 可以将main中的变量通过传参的方式传递给该函数
        如果两个参数都是数字, 但是类型不匹配, 编译器会把实际参数的类型转换成形式参数的类型, 这可能会造成一些精度损失

        主调函数把它的参数存储在被称为栈(stack)的临时存储区, 被调函数从栈中读取这些函数.
        
        如果想创建一个可以在程序执行时不受函数局部变量影响的变量, 可以将该变量在函数外声明, 这就是全局变量(global variable).
        全局变量的生命周期在定义时开始, 到程序执行结束

        还可以使用指针变量, 让被调函数可以操作主调函数中传入的指针所指向的变量.


使用return从函数中返回值
    参数传递将信息从主调函数传递给被调函数, 而return将被调函数中的值返回给主调函数

    return后面的表达式的值就是函数的返回值
    返回值不仅可以赋给变量, 也可以被用作表达式的一部分
    返回值不一定是变量的值, 也可以是任意表达式的值

    函数中可以使用多个return语句

    使用return语句会终止函数并把控制返回给主调函数的下一条语句
    可以将return单独作为一条语句
    如:
        return;
    专门用以结束函数的执行


函数类型
    声明函数时必须声明函数的类型. 带返回值的函数类型应该与其返回值类型相同, 而没有返回值的函数应声明为void类型.
    如果没有声明函数的类型, 旧版本的C编译器会假定函数的类型是int, 而C99标准不在支持int类型函数的这种假定
    函数类型值的使返回值的类型, 不是函数参数的类型


函数原型 function prototype
    用以告诉编译其函数的类型, 函数名, 所需的参数个数及对应类型
    函数原型用逗号分隔的列表指明参数的数量和类型. 变量名可以省略.
    函数原型都声明在使用函数之前.

    如
        void pound(double array[], unsigned int len);
    该声明和变量的声明格式一致.
    如果函数不返回任何参数, 函数类型应该写上关键字void.
    如果函数不接受任何参数, 函数头的圆括号中应该写上关键字void.

    ANSI C函数原型
        在ANSI C之前的函数原型声明方案有缺陷, 因为只需要声明函数的类型, 不用声明任何参数
        如果调用时参数的个数不对或类型不匹配, 编译器根本察觉不出来
        如
            void pound();

        针对参数不匹配的问题, ANSI C标准要求在函数声明时还要声明变量的类型, 即使用函数原型来声明函数的返回类型, 参数的数量和每个参数的类型
        函数原型中使用的参数名是假名, 在调用时, 以实际定义的参数名为准, 实际上也不需要在意实际定义的又是什么名字. 并且函数原型中的参数名可省, 可见其不重要

    无参数和未指定参数
        一个不支持ANSI C的编译器会假定用户没有用函数原型来声明函数, 他将不会检查参数.
        为了表明函数确实没有参数, 应该在圆括号中使用void关键字
            void message(void);
        
        支持ANSI C的编译器解释为message()不接受任何参数. 然后在调用函数时, 编译器会检查以确保没有使用参数

    ANSI C允许使用部分原型
        如, 格式化输出的原型
            int printf(const char *__restrict__ __format, ...);
        该函数原型表明, 第一个参数是一个不可修改的字符串, ...指出可能还有其他未指定的参数

        C标准库 stdarg.h头文件提供了一个定义这类形参数量不固定的标准方法

    函数原型的优点
        函数原型是C语言的一个强有力的工具, 他让编译器捕获在使用函数时可能出现的许多错误或疏漏
        使用函数原型的根本目的是为了让编译器在第一次执行到该函数之前就知道如何使用他. 因此将函数定义放在第一次执行前也是可以的, 就可以不用写函数原型


main()函数
    完整形式
        int main(int argc, char * argv[]);
    main()函数对于其他函数有一些特殊. 
    当main()与程序中的其他函数放在一起的时候, 最开始执行的是main()函数中的第一条语句, 并且以main()函数的执行完毕作为程序结束
    但这也是局限之处. main()函数可以被自己或其他函数递归调用.


指针在函数间通信
   // 用于将两个值内容项交换
    void swap(int * num1, int * num2){
        int temp = 0;
        temp = *num1;
        *num1 = *num2;
        *num2 = temp;
    }

    对应的函数原型
    void swap(int *, int *);

    其指针是存储变量地址的变量, 通过指针, 可以访问到原始的变量, 也就可以更改原始的变量了.
    这样, 主调函数与被调函数间, 就可以同时操作同一个变量.


变量: 名称, 地址, 值
    编写程序时, 可以认为变量有两个属性: 名称和值(还有其他性质, 如类型).
    计算机编译和加载程序后, 认为变量也有两个属性: 地址和值. 地址就是变量在计算机内部的名称.
    C可以通过&运算符访问地址, 通过*运算符获得地址上的值.
    
    简而言之, 普通变量把值作为基本量, 把地址作为通过&运算符获得的派生量, 而指针变量把地址作为基本量, 把值作为通过*运算符获得的派生量.
