I/O函数负责把信息传送到程序中
最初, 输入和输出函数不是C定义的一部分, C把开发这些函数的任务留给编译器的实现者来完成


缓冲区 buffer
    当用户输入字符到程序直接回显用户输入的字符, 属于无缓冲(或直接)输入, 即正在等待的程序可立即使用输入的字符.
    当用户输入字符到程序得等到按下Enter键之前不会对用户的输入进行反应的, 输入缓冲输入.
    在缓冲输入中, 用户输入的字符被收集并存储在被叫做缓冲区(buffer)的临时存储区.
    通常系统使用行缓冲输入, 即当用户按下Enter键后才将内容传送给程序, 但是按下Enter键也传输了一个换行符在字节流中.

    无缓冲优势
        反应快速
        不需要存储

    有缓冲优势
        把若干个字符作为一个块进行传输比逐个发送这些字符节约时间.
        用户输入错误可以自纠.

    缓冲分为两类
        完全缓冲I/O 和 行缓冲I/O
        完全缓冲是指当缓冲区被填满时才刷新缓冲区, 此时输入的内容将会被发送至目的地, 通常应用在文件输入中
        行缓冲是指在出现换行符时刷新缓冲区. 键盘输入就是行缓冲.

    缓冲区的大小一般取决于系统, 常见的是512字节和4096字节

    为了兼容一些不允许无缓冲输入的计算机, C标准规定, C中的输入都是缓冲的.
    
    C标准库stdio.h中
        void setbuf ( FILE * stream, char * buffer );
        int setvbuf ( FILE * stream, char * buffer, int mode, size_t size );
    这两个函数可用来控制缓冲, 但是受限于一些系统的内部设置, 这些函数可能不起作用

    

结束键盘输入
    C中为了标明一个输入完成, 且不与输入中的字符相冲突, 使用一个在文本中用不到的字符来标记输入完成. 
    EOF, 通常定义为-1, 字符都是正数.


文件, 流, 键盘输入
    文件(file)是存储器中存储信息的区域. 通常, 文件都保存在某种永久的存储器中, 如磁盘, U盘, 固态硬盘

    C具有很多打开, 读取, 写入和关闭文件的函数.
    从较底层面上, C可以使用主机操作系统的基本文件工具直接处理文件, 这些直接调用操作系统函数被称为底层I/O(low-level I/O)
    从较高层面上, C可以通过标准I/O包(standard I/O package)来处理文件

    根据系统的不同, 存储文件的方式和文件保存内容的约定会有不同. 如Dos/Windows系统使用\r\n标记行末尾, Linux/Unix系统使用\n标记行末尾.
    而使用标准I/O包, 就可以不用考虑以上差异
    即C可以通过标准I/O包中的一系列函数, 以统一的方式处理不同系统中的不同文件形式

    从概念上看, C程序处理的是流而不是直接处理文件. 流(stream)是一个实际输入或输出映射的理想化数据流.
    这意味着不同属性和不同种类的输入, 由属性更统一的流来表示. 于是打开文件的过程就是把流与文件相关联, 而且读写都是通过流来完层.

    C把输入和输出设备视为存储设备上的普通文件, 尤其是把键盘和显示设备视为每个C程序自动打开的文件. 
    stdin流表示键盘输入, stdout流表示屏幕输出.

    可以使用处理文件的方式来处理键盘输入.
    例如, 程序读文件时要检测文件的末尾才知道应在何处停止. 因此, C的输入函数内置了文件结尾检测器.
    既可以把键盘输入视为文件, 那么也应该能使用文件结尾检测器结束键盘输入.

文件结尾
    计算机系统要以某种方式判断文件的开始和结束.
    检测文件尾的一种方法是在文件末尾放一个特殊的字符标记文件结尾. 
        如CP/M, IBM-DOS, MS-DOS的文件曾经用过这种方法. 使用Ctrl+Z字符生成文件尾字符.
    记录文件大小, 文件有多大, 就读取多大的内容. 这些系统的文件就不会有文件结尾字符, 但是如果有, 也是可以识别的. 
        如新版DOS, Linux/Unix, MS-DOS及其相关系统使用这种方法处理二进制文件, 因为这种方法可以在文件中存储所有的字符.

    无论操作系统实际使用何种方法检测文件尾, 在C语言中, 用getchar()读取文件检测到文件尾时将返回一个特殊值, 即EOF (end of file).
    scanf()检测到文件尾时也返回EOF.

    通常, EOF在stdio.h 中定义 # define EOF (-1), 即值为-1, 不同系统可能定义的值不一样.
    定义为-1是因为-1不在字符集中

    例子, 文件结尾在输入中的应用
        int ch;
        while ((ch=getchar()) != EOF)
    在程序中将getchar()获得的数值与EOF进行比较, 不是才进行循环, 是就结束循环.
    注意
        这里的ch类型为int, 而不是char, char的范围有限, 使用int可以很好的支持获得EOF的负值, 而且getchar()实际的返回值是int, 所以可以这样用
        因为getchar()返回的是int, 当将返回赋值给char类型变量的时候, 有些编译器可能会警告会丢失数据
    绝大部分系统都可以通过键盘模拟文件结尾条件, 要想结束循环, 得模拟输入EOF字符. 
    在Linux/Unix系统, Ctrl+D会传输文件结尾信号, 一些微型计算机都把一行开始处的Ctrl+Z识别为文件结尾信号, 一些系统把任意位置的Ctrl+Z解释成文件结尾信号
    总之, 可以通过Ctrl+D或Ctrl+Z模拟文件结尾


重定向和文件
    重定向是系统功能, 是基于命令行运行的.
    绝大部分C系统都可以使用重定向, 如Unix/Linux 和 Dos/Windows系统
    默认情况下, C程序使用标准I/O包查找标准输入和输出作为输入源和输出源, 即stdin流和stdout流, 其实也可以让程序到别处查找输入和输出, 如从某个文件, 而不是键盘和屏幕.

    为了实现将文件作为输入和输出, 有两种办法
    使用C的方法, 显式使用特定函数打开文件, 读取文件, 写入文件, 关闭文件.
    使用系统的方法, 设计能与键盘和屏幕互动的程序, 通过不同的渠道重定向输入至文件和从文件输出.

Linux/Unix, Dos/Windows系统的重定向
    重定向输入让程序使用文件而不是键盘来输入, 重定向输出让程序输出至文件而不是屏幕.
    
    文本文件(text file), 是内含文本的文件, 存储的数据是人类可以识别的字符

    把输入重定向至文件 <
    把输出重定向至文件 >
    把输出重定向至文件内容末尾 >>

    例子
        # 将文件中的内容重定向作为输入到execute.a执行文件
        execute.a < file.txt

        # 将execute.a执行文件输出的内容重定向作为输出到文件
        execute.a > file.txt
    
        # 将 execute.a执行文件输出的内容重定向作为输出添加到文件末尾
        execute.a >> file.txt

    重定向输入与输出可以同时使用, 但是都只能出现一次, 且文件名不能一样
    如
        execute.a < input.txt > output.txt
        execute.a > output.txt < input.txt
    两者等价, 可见重定向没有执行先后, 是根据语义执行的

    重定向输入< , 重定向输出> , 在现代系统中左右是可以有空格的

    注意
        在一条命令中, 输入文件名和输出文件名不能相同
        重定向输出会替换掉原文件中的内容

    定向运算连接一个可执行文件和一个数据来源文件, 二者不可或缺
    使用重定向运算符不能读取多个文件的输入, 也不能把输出定向至多个文件
    文件名和运算符直接按的空格个不是必须的


处理Enter键输入发送的换行符
    在使用缓冲输入的时候, 要求用户按下Enter键才能发送输入, 这一动作也传送了一个换行符, 在处理字符输入的时候, 需要妥善的处理这个换行符
    常用的方式就是使用getchar()将stdin流中的剩下的字符全部丢弃, 因为getchar()读取每一个字符, 包括空格, 制表符, 换行符
    while (getchar() != '\n')
        continue;
    循环到直到获得换行符, 说明一行的输入结束了, 而在这个换行符及其之前的所有在stdin流中的字符都丢弃了
    代码表现上就是只是从stdin流中获取字符, 而不对这些字符做任何的处理

    使用scanf()进行个格式化输入的时候, 在格式化字符后添加一个\n, 这样会把用户按下Enter输入的换行符也从stdin流中读取
    但是这样做会造成困扰, 因为其实scanf会忽略收到的空白字符, 而从流中读取到的空白字符自然也会被忽略, 而且包括scanf用来判断输入完成的那个换行符
    会让用户继续输入, 直到不是空白字符, scanf才会停止对换行的读取, 转而读取下一个字符, 这时候的Enter才能结束输入


输入验证
    通常使用关系表达式来判断输入的数值是否符合某个范围, 或某种条件
    使用格式化输入的时候, 可以通过检查scanf()的返回值, scanf()返回成功读取项的个数
        如  
            long num;
            int ch;
            while (scanf("%ld", &num) != 1){
                while ((ch = getchar()) != '\n')
                    putchar(ch);
                puts("以上字符不是所期待的值, 只能输入单个长整型.");
            }
