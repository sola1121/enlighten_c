变参宏
    可以接受可变数量的参数

    通过 ... 和 __VA_ARGS__ 在定义宏函数时候完成

    宏参数表中最后的参数写成省略号(三个点...), 预定义宏__VA_ARGS__用在替换部分中, 表明省略号代表什么.
    如
        # define PR(...) printf(__VA_ARGS__)
        // 调用
        PR("参数%d\n", num);
    __VA_ARGS__展开为二个参数, "参数%d\n" 和 num, 展开后的代码是printf("参数%d\n", num);


1. 可变参数 stdarg.h
    stdarg.h头文件为函数提供了一个类似变参宏的功能, 但是用法比较复杂, 需要按步骤进行
        1) 提供一个使用省略号的函数原型
        2) 在函数定义中创建一个va_list类型的变量
        3) 用宏把该变量初始化为一个参数列表
        4) 用宏访问参数列表
        5) 用宏完成清理工作
    
    1) 使用省略号
        这种函数原型应该有一个形参列表, 其中至少有一个形参和一个省略号
            void fun1(int n, ...);   // 有效
            int fun2(const char * s, int k, ...);   // 有效
            char fun3(char c1, ..., char c2);   // 无效, 省略号不在最后
            double fun4(...);   // 无效, 没有形参
        省略号的前一个形参起着特殊的作用, 标准中用parmN这个术语来描述该形参
        如, fun1中的parmN为n, fun2中的parmN为k.
        传递给该形参(作为parmN的形参)的实际参数是省略号部分代表的参数数量
            fun1(2, 43, 23);   // parmN位置参数为2, 表示省略号部分有2个额外参数
            fun2(4, 12 114, 55, 78);   // parmN位置参数为4, 表示省略号部分有4个额外参数
    
    2) va_list类型的变量 ...
        声明在头文件stdarg.h中的va_list类型代表一种用于存储形参对应的形参列表中省略号部分的数据对象
            double sum(int lim, ...){
                va_list ap;   // 声明一个存储参数的对象

            }
        上面lim是parmN形参, 表明变参列表中参数的数量
    
    2) va_start宏初始化参数列表
        该函数将使用定义在头文件stdarg.h中的va_start()宏, 把参数列表拷贝到va_list类型的变量中.
        va_start宏有两个参数, 第一个参数接受va_list类型的变量, 第二个参数接受parmN形参, 即表明省略部分的将会处理的数据个数
            va_start(ap, lim);   // 把ap初始化为参数列表

    3) va_arg宏访问参数列表内容
        访问参数列表内容, 这需要使用头文件stdarg.h中的va_arg()宏
        va_arg宏接受两个参数, 第一个参数接受va_list类型的变量, 第二个参数需要输入一个类型名, 即指出返回省略参数数据的类型
        第一次调用va_arg()时, 他返回参数列表的第一项, 第二次调用时, 他返回第二项, 以此类推
        表示类型的参数指定了返回值的类型. 
        如果参数列表中的第一个参数是double类型, 第二个参数是int类型
            double tic;
            int toc;
            ...
            tic = va_arg(ap, double);   // 检索第一个参数
            toc = va_arg(ap, int);   // 检索第二个参数
        注意, 传入的参数类型必须与宏参数的类型相匹配.
        如果第一个参数是10.0, 上面的tic那行代码可以正常工作.
        但是如果参数是10, 这行代码可能会出错.
        因为是预处理宏指令, 这里不会像C赋值那样把double类型自动转换成int类型.

    4) va_end宏完成清理工作
        最后, 要使用va_end()宏完成清理工作. 例如释放动态分配用于存储参数的内存
        该宏接受一个va_list类型的变量
            va_end(ap);   // 清理工作
        调用va_end(ap)后, 只有用va_start重新初始化ap后, 才能使用变量ap.
        因为va_arg()不提供退回之前参数的方法, 所以有必要保存va_list类型变量的副本.
        C99标准开始, 提供了va_copy()宏处理这种情况.
        该宏接受两个va_list类型变量作为参数, 把第二个参数拷贝给第一个参数.
            va_list ap;
            va_list apcopy;
            double tic;
            int toc;
            ...
            va_start(ap, lim);   // 把ap初始化为一个参数列表
            va_copy(apcopy, ap);   // 把apcopy作为ap的副本
            tic = va_arg(ap, double);   // 检索第一个参数
            toc = va_arg(ap, int);   检索第二个参数
