# include "stdio.h"

/*
    数字类型都是以补码的形式存储在计算机中的
*/


int main() {
    // 位运算在计算负整数时的表现
    /*
        对于存储int类型为两个字节的系统
        正整数1的补码,          00000000,00000001
        负整数-1为1的补码,      11111111,11111111
        八进制0377的计算机表示为 00000000,11111111

            11111111,11111111
         |  00000000,11111111
        -----------------------
            11111111,11111111

        依然为-1, 其对应二进制为1,111,111,111,111,111, 八进制为1,7,7,7,7,7
    */
    puts("负数的按位或的表现:");
    int num = -1;
    num = num | 0377;
    printf("%d, %#o\n\n", num, num);

    // 位取反的表现
    /*
        对于存储int类型为两个字节的系统
        正整数1的补码        0000000,00000001
        取反后为            1111111,11111110

        表示的是一个负数 -2

        以此类推, ~0==-1, ~2==-3, ~3==-4, ...
        反之亦然
    */
    puts("正整数的取反的表现:");
    num = 1;
    printf("%d\n\n", ~num);

    // 位移运算
    /*
        对于存储char为1个字节的系统
        有符号的范围为-128~127, 无符号的范围为0~255
        负整数-8的计算机表示为   10000100
        正整数248的计算机表示为  11111000

        对于有符号负数-8采用算术右移, 即保留符号位1, -8>>2为 10000001, 对应十进制-2

        对于无符号正数, 依然采用填0, 248>>2为 00111110, 对应十进制 62
    */
    puts("无符号字符型的位移运算: ");
    char s1 = -8;
    unsigned char s2 = 248;
    printf("%d, %d\n\n", s1>>2, s2>>2);

    /*
        对于存储char为1个字节的系统
        有符号的范围为-128~127, 无符号的范围为0~255
        十六进制0x95为  10010101
        十六进制0xf为   00001111
        十六进制0xf0为  11110000

        0x95 & 0xf, 保留后四位, 为 00000101, <<4 为  01010000   
        0x95 & 0xf0, 保留前四位, 为 10000000, >>4 为 10001000, 高位具有符号, 采用算术右移   # FIXME: 0x95是正数, 只是高位为1而已?
        最后将所得结果按位或
        01010000 | 10001000, 为 11011000, # FIXME, 实际输出为59
    */
    puts("有符号字符型的位移运算: ");
    char a = 0x95, b, c;
    b = (a & 0xf) << 4;
    c = (a & 0xf0) >> 4;
    a = b | c;
    printf("%#x\n\n", a);

    // 将整型变量类型low中低字节即整型变量high中高字节放入变量num中
    int low = 834, high = 245;
    num = high & 0xff00 | low & 0x00ff;
    
    return 0;
}