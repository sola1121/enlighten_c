指针和数组
    数组表示法其实是在变相的使用指针.
    数组名的值是个指针常量(或者说, 数组名是不可修改的左值)
    数组名指向数组的第一个元素的地址或者说指向整个数组的首地址. 即array == &array[0];   // 1
    也可以简单的看作数组名是数组首元素的地址.

    指针与数组名的区别
        指针是一个变量, 所以可以当做左值赋值. 
        而数组名不是变量, 为不可修改的左值, 不能被放在赋值运算符的左边, 可以简单的理解为就是一个常量.
        如
            int array = {1, 2, 3};
            int *pt = array;

            pt ++; // 可行, 指针是变量, 可以修改
            array ++ ;   // 不可行, 数组名是不可修改的左值

    指针与数组虽然可以相互使用, 但是还是有区别. 


--------------------------------------------------------------

指针和多维数组

声明一个二维数组
    int matrix[3][4];   // 内含int数组的数组
    
    matrix数组名就是数组首元素的地址, 即 matrix == &matrix[0]. 
    因为matrix变量名是就是代指第一维matrix[3]数组, 数组名就是数组首元素, 所以matrix与matrix[0]地址相同

    给指针或地址加1, 其值会增加对应类型大小的数值. 在这方面, matrix和matrix[0]不同.
    因为matrix指向的对象占用了两个int大小, 而matrix[0]指向的对象只占用了一个int大小(matrix[0]的元素是一个一维数组指针)

    解引用一个指针或在使用数组下标, 得到引用的对象代表的值. 
    因为matrix[0]是该数组首元素(matrix[0][0])的地址, 所以*(matrix[0])表示存储在matrix[0][0]上的值(即一个int值)
    与此类似, *matrix代表该数组首元素(matrix[0])的值, 但是matrix[0]本身是一个int类型值的地址. 该值的地址是&matrix[0][0], 所以*matrix就是&matrix[0][0]
    简而言之, matrix是地址的地址, 必须解引用两次才能获得原始值, matrix[0][0], **matrix, *&matrix[0][0]等价

    两次才能获得原始值, 地址的地址或指针的指针就是双重间接(double indirection).

    使用两个解引用运算符*, 使用两对方括号[], 或者一个解引用*一个方括号[]都可以获得指针的指针所指向的值
    *(*(matrix+1)+3), matrix[1][3], (*(matrix+1))[3]

    matrix             // 二维数组首元素的地址(每个元素都是内含4个int类型元素的一维数组)
    matrix+2           // 二维数组第3个元素(即一维数组)的地址
    *(matrix+2)        // 二维数组第3个元素(即一维数组)的首元素(一个int类型的)地址
    *(matrix+2)+1      // 二维数组第3个元素(即一维数组)的第2个元素(一个int类型的值)地址
    *(*(matrix+2)+1)   // 二维数组第3个一维数组的第2个int类型元素的值, 即数组第3行, 第2列的值, matrix[2][1]


指向多维数组的指针
    指向多维数组的指针, 在声明时需要告诉两个主要信息给编译器, 一个是所声明的为指定类型的指针, 另一个是所指向的内容有指定类型的多大
    这就对应两个运算符号的使用
        *指针运算符, 告诉声明的变量为指定类型的指针
        []下标运算符, 空的方括号可以代替星号表示所声明变量为指针变量, 其中有值的可以让编译器为其分配该值对应类型的大小的内存, 就像是数组一样, 分配一定长度的空间

    对于一个二维数组, 变量名为其首元素的地址, 而该元素又是内含指定类型与个数的一维数组
    因此, 想要用一个指针指向一个二维数组, 该指针必须指向一个内含两个指定类型的数组. 
    如下, 使用int类型举例
        int (* mx_pt)[4];   // mx_pt指针内含一个具有4个int元素的数组
    以上代码将mx_pt声明为指向一个数组的指针, 该数组内含4个int类型值.
    []下标运算符的优先级属于1级, 为最高, 而*指针运算符的优先级属于2级, 次于下标运算符
    所以得在声明的时候使用圆括号让指针运算符先执行, 表明该新声明的变量为对应类型的指针, 接下来的下标运算符表明其指向一个多大的数组
    可以理解其为数组指针, 即指向一个指定大小的数组的指针.

    如果不写圆括号
        int * array[4];   // array是一个内含4个指针元素的数组, 其所含元素为int*, 即int指针
    []下标运算符的优先级高于*指针运算符, 所以变量在声明的时候先与下标运算符相结合, 使新生成的变量为数组, 接下来的指针运算符表明该数组的内容的元素为指定类型的指针变量
    这种内含元素为指针的数组就叫做指针数组, 本质上还是一个一维数组

    数组指针与指针数组
        声明一个指向二维数组的指针, 即需要声明一个数组指针
            int (* mx_pt)[4];
        先执行圆括号中*指针运算符将mx_pt声明为指针, 然后执行[]下标运算符, 指明该指针指向多大的数组.
        那么这个指向二维数组的指针, 就叫做二维数组指针.
        
        声明一个指针数组
            int * array[4];
        先执行[]下标运算符将array声明为数组, 然后执行*指针运算符, 表明该数组保存的元素类型为指针.
        那么这个保存指针元素的数组, 就叫做指针数组.


指针的兼容性
    指针之间的赋值比数值类型之间的赋值要严格.
    例如, 不用类型转换就可以把int类型的值赋给double类型的变量, 但是两个类型的指针不能这样做.

    例1
        int num = 8;
        double dnum;
        int * i_pt = &num;
        double * d_pt = &dnum;
        dnum = num;
        d_pt= i_pt;   // 编译时错误, 对double* 赋值 int*所存的地址

    例2
        int * i_pt;
        int (* imx_pt)[4];
        int matrix1[3][4];
        int matrix2[4][3];
        int ** ppt;

        i_pt = &matrix1[0][0];   // 可以赋值, 都是指向int的指针
        i_pt = matrix1[1];   // 可以赋值, 都是指向int的指针
        i_pt = matrix1;   // 无效, i_pt是int类型指针, matrix1是int(*)[4]类型的指针
        imx_pt = matrix1;   // 可以赋值, 都是指向int(*)[4]的指针
        imx_pt = matrix2;   // 无效, imx_pt是int(*)[4]类型的指针, matrix2是int(*)[3]类型的指针
        *ppt = matrix2[0];   // 可以赋值, 都是指向int的指针
        ppt = matrix2;   // 无效, ppt是int**类型的指针, matrix2是int(*)[3]类型的指针

    在最后为指针的指针赋值的时候, ppt存储的是一个int*指针变量的地址, 而这个指针变量又存储一个int变量的地址, 即ppt指向的指针指向int.
    而matrix2是指向数组的指针, 该数组内含4个int类型值.
    所以ppt和matrix2的类型不同, 不能将matrix2赋给ppt.
    但是, *ppt是指向int的指针, 而matrix2[0]是一个一维数组, 从指针的角度看可以使用一个int指针记录其地址, 即对应的是int*(指向int的指针)
    因此可以将matrix[0]的地址赋值给*ppt

    const数据为指针赋值
        const数据的地址或非const数据的地址 可以初始化指向const的指针 或 为指向const变量的指针变量赋值
        非const数据的地址赋给普通指针
        可以避免通过指针而改变const变量中的数据

    多重引用令人费解
    例
        int num = 8;
        const int c_num = 32;
        int * pt = &num;
        const int * c_pt = &c_num;
        const int ** c_ppt;

        pt = c_pt;   // 将const指针赋给非const指针, 不安全
        c_pt = pt;   // 把非const指针赋给const指针
        c_ppt = &pt;   // 嵌套指针类型赋值, 不安全

    const指针赋给非const指针不安全, 因为这样可以使用新的指针改变const指针指向的数据.
    编译器在编译代码时, 可能会给处警告, 执行这样的代码是未定义的.

    在两级解引用时, 赋值的不安全性
        const int ** c_ppt;
        int * pt;
        const int num = 8;
        c_ppt = &pt;   // 允许, 但是这导致const限定失效, 因为可以通过非const指针pt更改内容, 这违背了c_ppt的意图
        *c_ppt = &num;   // 有效, 两者读声明为const, 但是这将导致pt指向num
        pt = 10;   // 有效, 但是这将改变num的值, 但是num定义为了常变量, 其意图是不让修改的

    C标准规定了通过非const指针更改const数据是未定义的. 在不同的编译器下, num的值肯能变了, 也可能没变, 但一般编译器会给出指针类型不兼容的警告.


C const 和 C++ const 关键字
    C和C++中const的用法很相似, 但是并不完全相同.
    区别1: C++允许在声明数组长度时使用const整数, 而C却一般不支持.
    区别2: C++的指针赋值检查更严格
        const int num;
        const int * c_pt = &num;
        int * pt;
        pt = c_pt;   // 在C++中不允许这样做, 但是在C中可能只给出警告

        C++不允许把const指针赋给非const指针. 而C则允许这样做, 但是通过pt更改其指向的const变量, 这样的行为是未定义的


--------------------------------------------------------------

复合字面量 compound literal
    字面量(literal)是用于表达源代码中一个固定值的表示法(notation).
    字面量是除符号常量外的常量. 
    例如, 5是int类型字面量, 3.14是double类型的字面量, "hello, world." 是字符串字面量.
    C99新增了复合字面量, 用来代表数组和结构内容的复合字面量.

    对于数组 , 复合字面量类似数组初始化列表, 前面是用括号括起来的类型名
        int array[2] = {3, 5};   // 普通的数组声明
        (int [2]) {3, 5};   // 复合字面量
    可见, 复合字面量类似去掉普通声明中数组名, 留下 int [2]即是复合字面量的类型名

    初始化有数组名的数组时可以省略数组长度, 复合字面量也可以省略长度, 编译器会自动计算数组当前的元素个数.
        (int []) {1, 3, 5, 7};
    
    因为复合字面量是匿名的, 所以不能先创建然后再使用他, 必须在创建的同时使用他.
    使用指针记录就是一种方法.
    如
        int * pt;
        pt = (int [2]) {2, 4};
        pt = (int []) {1, 3};
    注意
        该复合字面量的字面常量与对应的普通数组完全相同. 
        与有数组名的数组类似, 复合字面量的类型名也代表首元素的地址, 所以可以把它赋给指向int的指针. 然后便可使用这个指针.

    还可以把复合字面量作为实际参数传递给具有匹配形式参数的函数
        int sum_array(const int array[], int len);
        sum_array((int [3]){1, 2, 3}, 3);

    使用复合字面量的好处是把信息传入函数前不必先创建数组

    也可以把这种用法用于二维数组或多维数组
        int (*ppt)[3];   // 声明一个指向二维数组的指针, 其内容的一维数组有3个int类型的值
        ppt = (int [2][3]) {{11, 12, 13}, {21, 22}};

    复合字面量是提供只临时需要的值的一种手段.
    复合字面量具有块作用域, 这意味着一旦离开定义复合字面量的块, 程序将无法保证该字面量是否存在.
    也就是说, 复合字面量的定义在最内层的花括号内.
