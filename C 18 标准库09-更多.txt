断言库 assert.h
    assert.h头文件中将assert()定义为一个宏.
    在包含assert.h头文件之前定义宏标识符NDEBUG, 可以禁用assert()宏


复数 complex.h


字符处理 ctype.h
    ctype.h中声明的函数, 都接受int类型的参数, 这些参数可以表示为unsigned char类型或EOF.


错误报告 errno.h
    errno.h头文件支持较老式的错误报告机制.
    该机智提供一个标识符(或有时称为宏)ERRNO可访问外部静态内存位置.
    一些库函数把一个值放进这个位置用于报告错误, 然后包含该头文件的程序就可以通过查看ERRNO的值检查是否报告了一个特定的错误.
    ERRNO机智被认为不够艺术, 而且设置ERRNO值也不需要数学函数了.


浮点环境 fenv.h
    fenv.h头文件提供访问和控制浮点环境
    浮点环境floating-point environment由一组状态标志statusflag和控制模式control mode组成.
    在浮点计算中发生异常情况时(如, 被零除), 可以"抛出一个异常".
    这意味着该异常情况设置了一个浮点环境标志.
    控制模式值可以进行一些控制, 例如控制舍入的方向.
    fenv.h头文件定义了一组宏表示多种异常情况和控制模式, 并提供了与环境交互的函数原型.
    头文件还提供了一个编译指令来启用或禁用访问浮点环境的功能.
        # pragma STDC FENV_ACCESS on   // 开启访问浮点环境
        # pragma STDC FENV_ACCESS off   // 关闭访问浮点环境


浮点特性 float.h
    float.h头文件中定义了一些表示各种限制和形参的宏.
    许多宏都涉及下面的浮点表示模型.
        x = sb^e * sum from { { k=1 } } to { k=p } { {f_{k}^{(b ^ -k)}} }
    

整型类型的格式转换 inttypes.h
    intypes.h头文件定义了一些宏可用作转换说明来扩展整数类型.
    该头文件中还包含了stdint.h, 并声明了一些使用最大长度整数类型的函数. 这种整数类型在stdint.h中声明为intmax.


可选拼写 iso646.h
    iso646.h头文件中提供了11个宏, 扩展了指定的运算符.


本地化 locale.h
    本地化是一组设置, 用于控制一些特定的设置项, 如表示小数点的符号.
    本地值存储在struct lconv类型的结构中, 定义在locale.h头文件中.
    可以用一个字符串来指定本地化, 该字符串制定了一组结构成员的特殊值.


非本地条跳转 setjmp.h
    setjmp.h头文件可以让你不遵循通常的函数调用, 函数返回顺序.
    setjmp.h()函数把当前执行环境的信息(如, 指向到那个前指令的指针)存储在jmp_buf类型(定义在setjmp.h头文件中的数组类型)的变量中
    然后longjmp()函数把执行转至这个环境中.
    这些函数主要是用来处理错误条件, 并不是通常程序流控制的一部分.


信号处理 signal.h
    信号signal是在程序执行期间可以报告的一种情况, 可以用正整数表示.
    raise()函数发送(或者说抛出)一个信号, signal()函数设置特定信号的响应.
    标准定义了一个整数类型 sig_atomic_t, 专门用于在处理信号时指定原子对象. 也就是说, 更新原子类型是不可分割的过程.


对齐 stdalign.h
    stdalign.h头文件定义了4个宏, 用于确定和指定数据对象的对齐属性.


可变参数 stdarg.h
    stdarg.h头文件提供一种方法定义参数数量可变的函数.
    这种函数的原型有一个形参列表, 列表中至少有一个形参后面跟有省略号
    如
        void fun(int n, ...);
        int fun2(int n, float x, int k, ...);
    该头文件中声明了va_list类型表示存储形参列表中省略号部分的形参数据对象.


原子支持 stdatomic.h
    stdatomic.h和threads.h头文件支持并发编程. 
    stdatomic.h头文件提供了创建原子操作的宏.
    编程社区使用原子这个术语是为了强调不可分割的特性.
    一个操作(如, 把一个结构赋给另一个结构)从编程层面上看是原子操作, 但是从机器语言层面上看是由多个步骤组成.
    如果程序被分成多个线程, 那么其中的线程可能读或修改另一个线程正在使用的数据.
    例如, 可以想象给一个结构的多个成员赋值, 不同线程给不同成员赋值.
    有了stdatomic.h头文件, 就能创建这些可以看作是不可分割的操作, 这样就能保证线程之间互不干扰.


线程 threads.h
    threads.h和stdatomic.h头文件支持并发编程.
    该头文件支持程序执行多线程, 原则上可以把多个线程分配给多个处理器处理.


布尔支持 stdbool.h
    stdbool.h头文件中定义了4个宏
        bool   : 展开为_Bool
        false  : 展开为整型常量0
        true   : 展开为整型常量1
        __bool_true_false_are_defined : 展开为整型常量1
    

通用定义 stddef.h
    该文件定义了一些类型和宏
    定义的类型
        ptrdiff_t   : 有符号整数类型, 表示两个指针之差
        size_t      : 无符号整数类型, 表示sizeof运算符的结构
        wchar_t     : 整数类型, 表示支持的本地化所指定的最大扩展字符集
    定义的宏
        NULL   : 实现定义的常量, 表示空指针
        offsetof(type, member-designator) : 展开为size_t类型的值, 表示type类型结构的指定成员在该结构中的偏移量, 以字节为单位. 如果成员是一个位字段, 该宏的行为是未定义的


整型类型 stdint.h
    stdint.h头文件中用一组typedef工具创建整数类型名, 指定整数的属性.
    stdint.h头文件包含在inttypes.h中, inttypes.h头文件中提供了输入/输出函数调用的宏.


日期和时间 time.h


统一码工具 uchar.h
    C99的wchar.h头文件提供两种途径支持大型字符集.
    C11专门针对统一码(Unicode)新增了适用于UTF-16和UTF-32编码的类型


扩展的多字节字符和宽字符工具 wchar.h
    每种实现都有一个基本字符集, 要求C的char类型足够宽, 以便能处理这个字符集.
    实现还要支持扩展的字符集, 这些字符集中的字符可能需要多字节来表示.
    可以把多字节字符与单字节符一起存储在普通的char类型数组, 用特定的字节值指定多字节符本身及其大小.
    如何解释多字节符取决于移位状态shift state.
    在最初的移位状态中, 单字节字符保留其通常的解释.
    特殊的多字节符可以改变移位状体.
    除非显式改变特定的移位状态, 否则移位状态一直保持有效.

    wchar_t类型提供另一种表示扩展字符的方法, 该类型足够宽, 可以表示扩展字符集中任何成员的编码.
    用这种宽字符类型来表示字符时, 可以把单字符存储在wchar_t类型的变量中, 把宽字符的字符串存储在wchar_t类型的数组中.
    字符的宽字符表示和多字节符表示不必相同, 因为后者可能使用前者并不使用的移位状态.


宽字符分类和映射工具 wctype.h
    wctype.h库提供了一些与ctype.h中的字符函数类似的宽字符函数, 以及其他函数.


POSIX操作系统API访问unistd.h 
    unistd是Unix Standard的缩写.
    unistd.h 是C和C++程序设计语言中提供对POSIX操作系统API的访问功能的头文件的名称.
    该头文件由POSIX.1标准(单一UNIX规范的基础)提出, 故所有遵循该标准的操作系统和编译器均应提供该头文件.

    常用系统功能如文件读写read, write, close, seek, 多进程fork, pipe