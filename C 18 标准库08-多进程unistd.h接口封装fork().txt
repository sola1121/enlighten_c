多核计算机与进程
   计算机核的个数与可同时运行的进程数相同.
   相反, 若进程数超过核数, 进程将分时使用CPU资源. 但因为CPU运行速度极快, 我们会感到所有进程同时运行.
   当然多核越多, 这种感觉也明显.

进程是一个程序的一个实例, Linux下一个进程在内存里有三部分的数据, 就是"代码段", "堆栈段"和"数据段".
   "代码段", 存放了程序代码.
   "堆栈段", 存放的就是程序的返回地址, 程序的参数以, 程序的局部变量.
   "数据段", 存放程序的全局变量, 常数, 动态数据分配的数据空间(如malloc函数分配的空间).
系统如果同时运行多个相同的程序, 他们的"代码段"是相同的, "堆栈段"和"数据段"是不同的(相同的程序, 处理的数据不同).
   
进程是资源分配的最小单位, 线程是程序执行的最小单位.
每次创建一个进程需要从操作系统分配这些资源给他, 消耗一定的时间.
在linux下C语言创建一个进程使用fork()函数, 该函数被定义在POSIX标准封装接口unistd.h头文件中


1. 查看Linux系统中的进程
    ps   : 查看当前终端的进程
    ps -ef   : 查看系统全部的进程
    ps -ef | more   : 查看系统全部的进程, 结果分页显示
    ps -ef | grep book   : 查看系统全部的进程, 然后从结果集中过滤出包含"book"单词的记录
    total   : 动态的列出系统中运行的进程

    进程的各种标识
        UID   : 启动进程的操作系统用户
        PID   : 进程id号
        PPID  : 进程的父进程id号
        C     : CPU使用的资源百分比
        STIME : 进程启动时间
        TTY   : 进程所属系统终端
        TIME  : 使用掉的CPU时间
        CMD   : 该进程执行的指令


2. 进程状态
   1) 僵尸进程
      正常情况下, 子进程结束后, 系统会发送SIGCHLD信号给父进程, 父进程对其默认处理是忽略. 如果想响应这个消息, 父进程通常在信号事件处理程序中, 使用wait系统调用来响应子进程的终止.
      如果父进程先退出, 子进程被init接管, 子进程退出后init会回收其占用的相关资源.
      僵尸进程zombie process是当子进程比父进程先结束, 而父进程又没有回收repeat子进程, 释放子进程占用的资源, 此时子进程将成为一个僵尸进程.
      即子进程在调用exit命令结束自己的生命的时候, 其实它并没有真正的被销毁, 而是留下一个称为僵尸进程的数据结构.
      在类UNIX系统中, 通常进程直接被其父进程wait并由系统回收. 但是当一个进程结束了, 他的父进程没有等待(调用wait / waitpid)他, 那么他将变成一个僵尸进程.
      僵尸进程被回收后, 其进程号与在进程表中的表项都可以被系统重用. 进程长时间保持僵尸状态一般是错误的并导致资源泄漏.
      这些资源, 是为了让父进程知道子进程结束时的状态信息所分配的, 包括进程号, 退出状态, 运行时间等.

      终止僵尸进程
         kill命令对僵尸进程本身无效.
         收割僵尸进程的方法是通过kill命令手工向其父进程发送SIGCHLD信号. 
         如果其父进程仍然拒绝收割僵尸进程, 则终止父进程, 使得init进程收养僵尸进程. init进程周期执行wait系统调用收割其收养的所有僵尸进程.

      避免僵尸进程
         (1) 父进程通过wait或waitpid等函数等待子进程结束, 这会导致父进程挂起.
         (2) 如果父进程很忙, 那么可以用signal函数为SIGCHLD安装handler, 因为子进程结束后, 父进程会收到该信号, 可以在handler中调用wait回收.
         (3) 如果父进程不关心子进程什么时候结束, 那么可以用signal(SIGCHLD, SIG_IGN)通知内核, 自己对子进程的结束不感兴趣, 那么子进程结束后, 内核会回收, 并不再给父进程发送信号.
         (4) 还有一些技巧, 就是fork两次, 父进程fork一个子进程, 然后继续工作, 子进程fork一个孙进程后退出, 那么孙进程被init接管, 孙进程结束后, init会回收. 不过子进程的回收还要自己做.

      区分
         僵尸进程, 一个进程使用fork创建子进程, 如果子进程退出, 而父进程并没有调用wait或waitpid获取子进程的状态信息, 那么子进程的进程描述符仍然保存在系统中, 这种进程称为僵尸进程.
         孤儿进程, 一个父进程退出, 而它的一个或多个子进程还在运行, 那么那些子进程将成为孤儿进程. 孤儿进程将被init进程(进程号为1)所收养, 并由init进程对它们完成状态收集工作.


   2) 孤儿进程
      在操作系统领域中, 孤儿进程(Orphan Process)指的是在其父进程执行完成或被终止后仍继续运行的一类进程.
      孤儿进程将被init进程(进程号为1)所收养, 并由init进程对它们完成状态收集工作.

      在类UNIX操作系统中, 子进程是通过父进程创建的, 子进程再创建新的进程.
      子进程的结束和父进程的运行是一个异步过程, 即父进程永远无法预测子进程到底什么时候结束.
      当一个父进程由于正常完成工作而退出或由于其他情况被终止, 它的一个或多个子进程却还在运行, 那么那些子进程将成为孤儿进程.
      为避免孤儿进程退出时无法释放所占用的资源而僵死, 进程号为1的init进程将会接受这些孤儿进程, 这一过程也被称为收养.

   3) 守护进程
      在一个多任务的电脑操作系统中, 守护进程daemon是一种在后台执行的电脑程序, 此类程序会被以进程的形式初始化, 用以执行特定的系统任务.
      守护进程程序的名称通常以字母"d"结尾, 如, syslogd就是指管理系统日志的守护进程.
      通常, 守护进程没有任何存在的父进程(即PPID=1, 由init进程管理)且在UNIX系统进程层级中直接位于init之下. 
      也可以理解为守护进程是一个在后台运行并且不受任何终端控制的进程.

      创建守护进程
         在类UNIX系统中, 命令行行终端, 在执行指令后以&结尾即可将该条指令作为守护进程, 让其在后台运行, 此时执行指令就脱离终端而直接受init管理.
         对一个子进程执行fork, 然后使其父进程立即终止, 使得这个子进程能在init下运行. 这种方法通常被称为"脱壳".

      守护进程的作用
         系统通常在启动时一同启动守护进程.
         守护进程为对网络请求, 硬件活动等进行响应, 或其他通过某些任务对其他应用程序的请求进行回应提供支持.
         守护进程也能够对硬件进行配置(如在某些Linux系统上的devfsd), 运行计划任务(例如cron), 以及运行其他任务.

      其他系统中的守护进程
         在DOS环境中, 此类应用程序被称为驻留程序(TSR). 在Windows系统中, 由称为Windows服务的应用程序来履行守护进程的职责.
         在原本的Mac OS系统中, 此类应用程序被称为"extensions"。而作为类UNIX的Mac OS X有守护进程. 在Mac OS X中也有"服务", 但他们与Windows中类似的程序在概念上完全不相同.


3. 类Unix系统接口封装 unistd.h
    unistd.h头文件是C和C++语言中提供对POSIX操作系统API的访问功能的头文件. 
    该头文件由POSIX.1标准(可移植系统接口)提出, 故所有遵循该标准的操作系统和编译器均应提供该头文件(如Unix的所有官方版本, 包括 Mac OS X, Linux等).

   对于类Unix系统, unistd.h头文件中所定义的接口通常都是大量针对系统调用的封装wrapper functions
   如, fork(), pipe() 以及 各种I/O原语(read, write, close 等等).
   类似于Cygwin和MinGW的Unix兼容层也提供相应版本的 unistd.h.

    1) 创建进程
        创建进程有两种方式, 一是由操作系统创建, 二是由父进程创建. 
        操作系统创建的进程, 它们之间是平等的, 一般不存在资源继承关系. 
        由父进程创建的进程(子进程), 它们和父进程存在隶属关系. 子进程又可以创建进程, 形成一个进程家族.

        系统调用fork()函数是创建一个新进程的唯一方法. 进程调用fork()函数就创建了一个子进程.

        pid_t fork(void);
        克隆当前进程作为父进程用以创建一个新的子进程
        成功便在子进程中返回0, 父进程中返回所克隆出子进程的id, 错误返回-1

        创建了一个子进程之后, 父进程和子进程争夺CPU, 抢到CPU的执行, 另外一个挂起等待.
        若要父进程等待子进程执行完毕后再继续执行, 可以在fork操作之后调用wait或waitpid.
        
        fork()函数创建了一个新的进程, 新进程(子进程)与原有的进程(父进程)一模一样. 
        子进程和父进程使用相同的代码段, 子进程拷贝了父进程的堆栈段和数据段.
        子进程一旦开始运行, 它复制了父进程的一切数据, 然后各自运行, 相互之间没有影响.

        fork()函数对返回值做了特别的处理, 调用fork()函数之后, 在子程序中fork的返回值是0, 在父进程中fork的返回是子进程的id号.
        程序员可以通过fork()函数的返回值来区分父进程和子进程, 然后再执行不同的代码.
        如, 使用条件语句, 判断fork()函数的返回值为0则代表执行在子进程中, 非0进程id号则代表执行在父进程中.

        pid_t vfork(void);
        克隆当前进程作为父进程用以创建一个新的子进程, 但是并不复制所有的地址空间.
        父进程将会被暂停直到该新的子进程退出或被执行的execve取代
        返回值
            成功便在新创的进程中返回0, 在父进程中返回新进程的id号, 错误返回0
        vfork()函数会产生一个新的子进程, 其子进程会复制父进程的数据与堆栈空间, 并继承父进程的用户代码, 组代码, 环境变量, 已打开的文件代码, 工作目录和资源限制等.

        类UNIX系统使用copy-on-write(COW)技术
        只有当其中一进程试图修改欲复制的空间时才会做真正的复制动作, 由于这些继承的信息是复制而来, 并非指相同的内存空间, 因此子进程对这些变量的修改和父进程并不会同步.
        此外, 子进程不会继承父进程的文件锁定和未处理的信号.

        注意
            系统不保证子进程会比父进程先执行或晚执行, 因此编写程序时要留意死锁或竞争条件的发生.

        错误代码:
            (1) EAGAIN, 内存不足.
            (2) ENOMEM, 内存不足, 无法配置核心所需的数据结构空间.

   2) 查看进程
        进程的编号是系统动态分配的, 相同的程序在不同的时间执行, 进程的编号是不同的.
        进程的编号会循环使用, 但是, 在同一时间, 进程的编号是唯一的. 也就是说, 不管任何时间, 系统不可能存在两个编号相同的进程.

        pid_t getpid() 获取本程序运行时进程的编号
        返回值是进程的编号, pid_t就是typedef int pid_t

        pid_t getppid(void);
        取得目前进程的父进程识别码.
        返回值: 目前进程的父进程识别码.

        pid_t getpgid(pid_t pid);
        取得参数pid指定进程所属的组识别码.
        如果参数pid 为0, 则会取得目前进程的组识别码.
        返回值是执行成功则返回组识别码, 如果有错误则返回-1, 错误原因存于errno 中.
        错误代码: ESRCH 找不到符合参数pid 指定的进程.

        pid_t getpgrp(void);
        取得目前进程所属的组识别码. 此函数相当于调用getpgid(0)
        返回值: 返回目前进程所属的组识别码.

        int getpriority(int which, int who);
        取得进程, 进程组和用户的进程执行优先权.
        参数which有三种数值, 参数who则依which值有不同定义.
        返回值: 返回进程执行优先权, 如有错误发生返回值则为-1 且错误原因存于errno 中.

        int setpgid(pid_t pid, pid_t pgid);
        将参数pid指定进程所属的组识别码设为参数pgid指定的组识别码. 
        如果参数pid为0, 则会用来设置目前进程的组识别码, 如果参数pgid为0, 则会以目前进程的进程识别码来取代.
        返回值: 执行成功则返回组识别码, 如果有错误则返回-1, 错误原因存于errno 中.

        int setpgrp(void);
        将目前进程所属的组识别码设为目前进程的进程识别码. 此函数相当于调用setpgid(0, 0).
        返回值: 执行成功则返回组识别码, 如果有错误则返回-1, 错误原因存于errno 中.

        int setpriority(int which, int who, int prio);
        用来设置进程, 进程组和用户的进程执行优先权.
        参数which 有三种数值, 参数who 则依which 值有不同定义.
        参数prio 介于-20至20之间. 代表进程执行优先权, 数值越低代表有较高的优先次序, 执行会较频繁. 此优先权默认是0, 而只有超级用户(root)允许降低此值.
        返回值: 执行成功则返回0, 如果有错误发生返回值则为-1, 错误原因存于errno 中.

        int nice(int inc);
        用来改变进程的进程执行优先顺序. 参数inc 数值越大则优先顺序排在越后面, 即表示进程执行会越慢. 只有超级用户才能使用负的inc 值, 代表优先顺序排在前面, 进程执行会较快.
        返回值: 如果执行成功则返回0, 否则返回-1, 失败原因存于errno 中.


3. 等待进程 sys/wait.h
    pid_t wait (int * status);
    第一个参数status, 将子进程结束状态值存储到status所指向的地址
    wait()函数会暂时停止目前进程的执行, 直到有信号来到或子进程结束.
    如果在调用wait()函数时子进程已经结束, 则wait()函数会立即返回子进程结束状态值.
    子进程的结束状态值会由参数status返回, 而子进程的进程识别码也会一快返回. 
    如果不在意结束状态值, 则参数status可以设成NULL. 
    返回值
        如果执行成功则返回子进程识别码(PID), 如果有错误发生则返回-1. 失败原因存于errno中.

    pid_t waitpid(pid_t pid, int * status, int options);
    第一个参数pid, 欲等待的子进程识别码
    第二个参数status, 将子进程结束状态值存储到status所指向的地址
    第三个参数options, 
    waitpid()会暂时停止目前进程的执行, 直到有信号来到或子进程结束. 
    如果在调用wait()函数时子进程已经结束, 则wait()函数会立即返回子进程结束状态值. 
    子进程的结束状态值会由参数status返回, 而子进程的进程识别码也会一快返回. 
    如果不在意结束状态值, 则参数status可以设成NULL. 
    返回值
        如果执行成功则返回子进程识别码(PID), 如果有错误发生则返回-1. 失败原因存于errno中.

    参数pid为欲等待的子进程识别码, 其他数值意义如下: 
        1) pid<-1 等待进程组识别码为pid绝对值的任何子进程.
        2) pid=-1 等待任何子进程, 相当于wait().
        3) pid=0 等待进程组识别码与目前进程相同的任何子进程.
        4) pid>0 等待任何子进程识别码为pid的子进程.

    参数status, 保存子进程的状态信息, 有了这个信息父进程就可以了解子进程为什么会退出, 是正常退出还是出了什么错误.

    参数option 可以为0 或下面的OR 组合:
        1) WNOHANG, 如果没有任何已经结束的子进程则马上返回, 不予以等待.
        2) WUNTRACED, 如果子进程进入暂停执行情况则马上返回, 但结束状态不予以理会. 子进程的结束状态返回后存于status, 底下有几个宏可判别结束情况
            (1) WIFEXITED(status), 如果子进程正常结束则为非0值.
            (2) WEXITSTATUS(status), 取得子进程exit()返回的结束代码, 一般会先用WIFEXITED来判断是否正常结束才能使用此宏.
            (3) WIFSIGNALED(status), 如果子进程是因为信号而结束则此宏值为真
            (4) WTERMSIG(status), 取得子进程因信号而中止的信号代码, 一般会先用WIFSIGNALED来判断后才使用此宏.
            (5) WIFSTOPPED(status), 如果子进程处于暂停执行情况则此宏值为真. 一般只有使用WUNTRACED时才会有此情况.
            (6) WSTOPSIG(status), 取得引发子进程暂停的信号代码, 一般会先用WIFSTOPPED 来判断后才使用此宏.

    注意
        一次wait或waitpid调用只能清理一个子进程, 清理多个子进程需要用到循环


4. unistd.h头文件中其他内容
    access	判断指定的文件或目录是否存在、是否可读、是否可写
    alarm	在指定秒数后生成一个SIGALRM信号
    brk	改变分配给调用进程的空间量
    chdir	将指定路径成为当前工作目录
    chmod	
    chown	
    chroot	
    close	收回指定的文件描述符
    ctermid	
    cuserid	
    dup	复制一个现存的文件描述符
    dup2	
    execl	用一个新的进程映像替换当前的进程映像
    execle	
    execlp	从PATH 环境变量中查找文件并执行
    execv	执行文件函数
    execve	执行文件函数
    execvp	执行文件函数
    fchdir	将指定路径成为当前工作目录
    fchmod	
    fchown	
    fork	创建当前进程的副本
    fpathconf	
    fsync	
    ftruncate	
    getcwd	获取当前工作目录的绝对路径
    getdomainname	
    getegid	获取调用进程的有效组ID
    geteuid	获取调用进程的有效用户ID
    getgid	获取调用进程的实际组ID
    getgroups	
    getlogin	获取用户使用其登录的名称
    getlogin_r	
    getopt	
    getpass	
    getpagesize	
    getsubopt	
    gethostid	检索当前主机的32位标识符
    getuid	
    getusershell	
    getwd	
    isatty	
    lchown	
    link	
    nice	
    lseek	
    pathconf	
    pause	
    pipe	
    pread	
    pwrite	
    read	
    readlink	
    rmdir	删除一个目录，该目录只有为空时才被删除。
    sbrk	
    sleep	使进程沉睡指定秒
    swab	
    symlink	
    sysconf	
    tcgetpgrp	
    tcsetpgrp	
    truncate	将文件截断为指定的长度
    ttyname	
    ttyname_r	
    unlink	
    usleep	使进程沉睡指定毫秒
    vhangup	
    write	
    __gethostname	
    _close	
    _execve	
    _exit	
    _fork	
    _getpid	
    _link	
    _lseek	
    _read	
    _sbrk	
    _unlink	
    _write	