字符串
    C字符串是一系列char类型的字符, 以空字符('\0')结尾. 存储在char类型数组中.
    如果没有空字符'\0'作为结尾, 完全可以看作是一个char类型的数组, 即一个数组, 元素为单个的char

    字符串常量(string constant)也叫做字符串字面量(string literal)
    由双引号括起来的一串字符, 编译器为其末尾自动加上'\0'空字符, 双引号中的字符和编译器自动加入末尾'\0'空字符, 都做为字符串存储在内存中.
    可以用于初始化字符数组. 为了容纳末尾的空字符, 数组大小应该至少容纳的数组长度多1.
    也可以用字符串字面量初始化指向char的指针.
        char * pt;
        char words[13] = "hello, world.";
        pt = words;
    所容纳字符的末尾后一位为空字符'\0'
        words[13] == '\0';   // 1

    ANSI C标准起, 如果字符串字面量之间没有间隔, 或者用空白字符分隔, C将会视其为串联起来的字符串字面量.
        printf("%s\n", "one" "two""three");

    字符串常量属于静态储存类别(static storage class), 说明如果在函数中使用字符串字面量, 该字符串只会被存储一次, 在整个程序的生命期内存在, 即使函数被调用多次.
    用双引号括起来的内容被视为指向该字符串存储位置的指针. 这类似于把数组名作为指向该数组位置的指针.
        printf("对比同值字符串的存储地址: %p, %p, 是否相等: %d\n", "ABC", "ABC", &"ABC"==&"ABC");
        输出
            对比同值字符串的存储地址: 0x56034a9b300c, 0x56034a9b300c, 是否相等: 1

        printf("在内存中存储是以首字符地址为保存: %c\n", *"ABC");
        输出
            在内存中存储是以首字符地址为保存: A

    函数使用指向字符串首字符的指针来表示待处理的字符串. 通常对应的实际参数是数组名, 指针变量或用双引号括起来的字符串.
    传递给函数的都是首字符的地址. 一般而言没有必要传递字符串的长度, 因为可以在函数数中通过末尾的空字符确定字符串的结束.


字符串数组声明和初始化
    定义字符串数组时, 必须让编译器知道需要多少空间.
    字符串需要的真正存储空间长度会比字符串中的实际字符个数多一个, 用来存储'\0'. 但是在描述计算字符串长度时, 不包含作为字符串结束标记的'\0'.

    1. 一种方法是用足够空间的数组存储字符串.
        const char msg[20] = {'h', 'e', 'l', 'l', 'e', ',', ' ', 'w', 'o', 'r', 'l', 'd', '.', '\0'};
        const char msg[20] = {"hello, world."};
    const表明不会更改这个字符串.
    注意最后的空字符'\0', 没有这个空字符, 该数组就不是一个字符串, 这里不写也是字符串, 因为空余位置编译器会全部部填充'\0'.
    剩余的没有初始化的位置将会以空字符'\0'填充.

    2. 另一种方法是省略数组初始化声明中的长度, 让编译器自动计算数组的长度.
        const char msg[] = {'h', 'e', 'l', 'l', 'e', ',', ' ', 'w', 'o', 'r', 'l', 'd', '.', '\0'};
    或
        const char msg[] = "hello, world.";
        const char msg[] = {"hello, world."};
    将会产生一个包含13个字符和一个'\0'的字符数组
    让编译器确定初始化字符数组的长度很合理. 因为处理字符串的函数通常都不知道数组的长度, 这些函数通过查找字符串末尾的空字符确定字符串在何处结束.
    注意
        让编译器计算数组的长度只能用在初始化数组时. 如果创建一个稍后在填充的数组, 就必须在声明时指定长度.
        声明数组时, 数组长度必须是可求值的整数.
        花括号只能用于数组的初始化.
        中文占用两个字节, 所以不能用于赋值单个char字符, 但是可以用字符串字面量来赋值中文.

    用字符串常量初始化字符数组时, 由于要提供一个字节来存储字符串的结束标志'\0', 因此数组的大小至少要比字符串的长度大1.
    在统计字符串长度时不包含结束标志'\0'这一位.
    
    注意, 
        字符数组只有在定义时才能将整个字符串一次性地赋值给他, 一旦定义完了, 就只能一个字符一个字符的赋值.

    还可以使用指针表示法创建字符串
        cosnt char * msg = "hello, world.";

    字符数组名和其他数组名一样, 是该数组首元素的地址.
        char msg[] = "hello, world.";
        msg == &msg[0];
        *msg == 'h';
        *(msg+1) == msg[1] == 'e';
    
    * 完成初始化的字符串下标与字符的对应关系
        char msg[6] = "hello.";
        0 | 1 | 2 | 3 | 4 | 5 | 6 | 
        h | e | l | l | o | . | \0|


数组表示法和指针表示法声明并初始化的字符串对比

    char array[] = "hello, world.";
    char * pt = "hello, world.";

    数组形式array[]在计算机的内存中分配为一个内含14个元素的数组(每个元素对应一个数组, 末尾还有一个'\0'), 每个元素被初始化为字符串字面量对应的字符.
    通常字符串都做为可执行文件的一部分存储在数据段中. 当把程序载入内存时, 也载入了程序中的字符串.
    字符串存储在静态存储区(static memory)中. 但是程序在开始运行时才会为数组分配内存. 此时才将字符串拷贝到数组中.
    注意, 此时字符串有两个副本. 一个实在静态内存中的字符串字面量, 另一个是存储在array数组中的字符串.
    
    此后, 编译器便把数组名array识别为数组首元素地址(&array[0])的别名.
    在数组形式中, array是地址常量. 不能更改array, 如果改变了array, 则意味着改变了数组的存储位置, 即地址.
    可以进行类似array+1这样的操作, 标识数组的下一个元素.
    但是不允许进行++array这样的操作. 自增运算只能用于变量名前(或者说, 只能用于可修改的左值), 不能用于常量.

    指针形式*pt在计算机内也让编译器预留14个元素的空间. 
    另外, 一旦开始执行程序, 他会为指针变量留出一个存储位置, 并把字符串的地址存储在指针变量中.
    该变量最初指向该字符串的首地址, 但是他的值可以改变. 因此可以使用自增远算符, 如 ++++pt; 指两个的后面.

    字符串字面量被视为const数据. 由于pt指向这个const数据, 所以应该把pt声明为指向const数据的指针.
    这意味着不能用pt改变他所指向的数据, 但是仍然可以改变pt的值, 即改变pt指向的位置.
    如果把一个字符串字面量拷贝给一个数组, 就可以随意改变数据, 除非把数组声明为const.

    总之, 初始化数组把静态存储区的字符串拷贝到数组中, 而初始化指针只把字符串的地址拷贝给指针.

    例
        # define MSG "hello, world."

        char array[] = MSG;
        char * pt = MSG;
    则有
        &array != &MSG;


数组表示法和指针表示法对于字符串的区别
    char array[] = "hello, world.";
    char * pt = "hello, world";

    主要区别: 数组名array是常量, 而指针名pt是变量.
    其次:
        两者都可以使用数组表示法
            putchar(array[3]);
            putchar(pt[3]);
        两者都能进行指针加法操作
            array + 3;
            pt + 3;
        只有指针表示法可以改变其值
            pt ++;
            pt += 2;
            因为, 赋值运算符的左侧必须是变量(或者说可修改的左值)
        可以改变数组中元素的值
            array[0] = 'H';
            *(array+0) = 'H';
            因为数组的元素是变量(除非数组被声明为const数组), 但是注意, 数组名不是变量

    如果 
        pt = array;
    则也可以使用指针修改字符串中的值
        pt[0] = 'H';
    
    但是, 如果直接使用pt修改指向的字符串字面量, 编译器允许这样做, 但是对当前的C标准来说, 这样的行为是未定义的.
        char * pt = "pure blue sky."
        *(pt+0) = 'P';   // 行为未定义, gcc中编译错误 Segmentation fault (core dumped)
    语句可能导致内存访问错误. 
    原因是编译器可以使用内存中的一个副本来表示所有完全相同的字符串字面量. 即相同的字符串只在静态内存中保留了一个.
    也就是说, 编译器可以用相同的地址替换每个相同字符串的实例.
    如果编译器使用这种单次副本表示法, 会影响所有使用该字符串的代码.
    介于以上表现, 应该把指针初始化为字符串字面量的时候使用const关键字.

    如果把非const数组初始化为字符串字面量就不会有以上的问题. 因为数组获得的是保存在静态内存中的字符串字面量副本.


字符串的数组
    在指针和数组中
        int (* pt)[4] 指针运算符*先与变量名结合, 创造出指针, 然后在与下标运算符[]结合, 指明该指针所指向的数组中包含4个int元素
        这就是数组的指针, 即该指针可以用来指向一个指定长度与类型的数组

        int *pt[4] 下标运算符[]先与变量名结合, 创造出可以存储4个元素的数组, 然后在于int*结合, 指明该数组存储的类型为int*, 即指针类型
        这就是指针数组, 即存储指针的数组, 本质上还是一个一维数组

    # define SIZE 50

    指向字符串的指针数组
        char * pt_msg[SIZE] = {
            "The earth belongs to us, the workers,",
            "No room here for the shirk.",
            "How many on our flesh have fattened!"
        };

    char类型数组的数组
        char arr_msg[3][SIZE] = {
            "The earth belongs to us, the workers,",
            "No room here for the shirk.",
            "How many on our flesh have fattened!"
        }
    
    相同点
        pt_msg与arr_msg非常相似, 两者都代表3个字符串. 
        使用一个下标时都分别表示一个字符串.
            pt_msg[2];
            arr_msg[2];
        使用两个下标时都分别表示一个字符.
            pt_msg[1][2];
            arr_msg[1][2];
        而且两者的初始化方式也相同.

    不同点
        pt_msg是一个内含指针的数组, 每个指针8字节, 共50个指针, 在系统中占用400个字节
        arr_msg是一个内含3个数组的数组, 每个数组内含50个char类型的值, 共占150个字节

        虽然pt_msg[0]和arr_msg[0]都分别表示一个字符串, 但是pt_msg和arr_msg的类型并不同

        pt_msg中的指针指向初始化时所用的字符串字面量的位置, 这些字符串字面量被储存在静态内存中
        arr_msg中的数组则存储者字符串字面量的副本, 所以每个字符串都被存储了两次.

        此外, 为字符串数组分配内存的使用率较低. arr_msg中的每个元素的大小必须相同, 而且必须能存储最长字符串的大小.

        pt_msg指向3个不规则的数组, 而且这些数组可能在内存中不连续, 这些数组的最后一位的末尾是'\0', 从而成为了字符串
        而arr_msg是一个二维数组, 长度是固定的, 在内存中顺序排列, 没有被初始化的地方都被赋予'\0'

    如果要用数组表示一系列待显示的字符串,应该使用指针数组, 因为他比二维字符数组的效率高.
    但是指针数组也有自身的缺点. pt_msg中的指针指向的字符串字面量不能更改. 
    所以要改变字符串或为字符串输入预留空间, 最好使用字符串二维数组.


指针和字符串的赋值
    字符串的绝大多数操作都是通过指针完成的. 但是当要将一个字符串的内容赋值给另一个字符串
    使用pt_str1 = pt_str1; 这是不对的, 这只是指针间的赋值, 意思是将pt_str2的记录的地址赋值给pt_str1
    想要复制内容的一个副本给另一个指针, 需要使用strcpy()和strncpy()函数.


--------------------------------------------------------------

命令行参数
    在图形界面普及之前都使用命令行界面.
    命令行(command line)是在命令行环境中, 用户为运行程序输入命令的行.
    命令行参数(command-line argument), 是同一行的附加项

    系统如何区分输入的各个字符串与并计数
        系统用空格表示一个字符串的结束和下一个字符串的开始.
        许多环境都允许用双引号把多个单词括起来形成一个参数.


main的参数

    C编译器允许main没有参数或者有两个参数, 一些实现甚至允许更多, 属于对标准的扩展.

    main()有两个参数时
        第一个参数是命令行中的字符串的数量. 被叫做参数计数(argument count), 通常简写为argc
        第二个参数为指向内存中保存的每个命令行参数的字符. 被叫做参数值(argument value), 通常简写为argv

    main()的参数
        int main(int argc, char * argv[]);
        int main(int argc, char **argv);

    在main里面, char *argv[] 和 char **argv是等价的, 其实argv是一个指向指针的指针, 而不仅仅是一个指针数组, 该指针指向的指针指向char.
    但是通常使用char * argv[]的形式, 应为更清楚的表明argv表示一个指针数组, 即一系列的字符串.

    每个指向char的指针都指向一个命令行参数字符串, argv[0]指向命令名称, argv[1]指向第一个命令行参数, 以此类推.