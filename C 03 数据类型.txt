数据类型
    基本类型
        整型类型
            字符型 - char
            短整型 - short int
            基本型整型 - int
            长整型 - long int
            双长整型 - long long int
            布尔型 - _Bool
        浮点类型
            单精度浮点型 - float
            双精度浮点型 - double
            长双精度浮点型 - long double
            复数浮点型 - float _Complex, double _Complex, long double _Complex
            虚数浮点型 - float _Imaginary, double _Imaginary, long double _Imaginary
    枚举类型 - enum
    空类型 - void
    派生类型
        指针类型 - * pointer
        数组类型 - array[]
        结构体类型 - struct data{};
        共用体类型 - union data{};
        函数类型 - void (*func)()


--------------------------------------------------------------


数字类型关键字
    char , int , short , long , float , double , _Bool , _Complex, _Imaginary


整型类型是否有符号位
    只有整型(包括字符型)数据可以使用, 实型数据不能加

    signed
        在整型数据前面添加. 默认的, 可以省略
            int num;
            signed int num;
        存储位中, 留出一个高位代表数据的正负.

    unsigned
        在数字类型前面添加.
            unsigned int num;
        存储位中, 不留出一个高位代表数据的正负.


数值类型
    整数类型
        C 标准规定: sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long long)
        short或short int至少占16位, int类型不小于16位, long或long int至少占32位, long long或long long int 至少占64位

        short - 短整型
            占2个字节, singed 范围 -2¹⁵ ~ 2¹⁵-1, unsigned 范围 0 ~ 2¹⁶-1
        int - 整型
            占4个字节, signed 范围 -2³¹ ~ 2³¹-1, unsigned 范围 0 ~ 2³²-1
        long - 长整型
            占4个字节, signed 范围 -2³¹ ~ 2³¹-1, unsigned 范围 0 ~ 2³²-1
            占8个字节, signed 范围 -2⁶³ ~ 2⁶³-1, unsigned 范围 0 ~ 2⁶⁴-1
        long long - 超长整型
            占8个字节, signed 范围 -2⁶³ ~ 2⁶³-1, unsigned 范围 0 ~ 2⁶⁴-1

        超过最大值或最小值
            将数值范围想象成一个环, 最大值紧接最小值
            如果超出最大值, 就从最小值开始前进超出的数目  
            如果超出最小值, 就从最大值开始后退超出的数目
            也就是说, 当一个正数溢出后, 会变为对应类型最小的值

    字符类型
        char - 单字符
            占1个字节, signed 范围 -2⁷ ~ 2⁷-1, unsigned 范围 0 ~ 2⁸-1
        
        使用单括号 '' 扩入一个字符, 如: 'a'

        在C中, 1字节定义为char类型所占用的空间大小.

        注意:
            实际存储的是一个整数, 可以参与计算, 该整数对应特定的字符编码表上的字符, 如'a'为97, 'A'为65, '0'为48
            因为char不支持多字节字符集, 对于如中文占用2个字节的文字, 就不能定义为单个字符, 要使用字符串才能存储.

        虽然char看上去只能支持标准的0~127的标准ASCII码, 但根据不同系统, 会保证更大的字符集使用, 如Unicode字符集等.

        标准库 uchar.h 提供了对16位与32位Unicode字符的支持.
        标准库 wchar.h 提供了对宽字符的支持, 表示比8位字符还宽的数据类型. 不同于Unicode.

        字符串 character string
            C语言没有专门用于存储字符串的变量类型. 
            使用char数组来作为字符串的保存媒介, 也可直接用char *指针来指向一块字符串字面量或指向一块已保存的字符串地址.
            数组由连续的存储单元组成, 字符串中的字符被存储在相邻的存储单元中, 每个单元存储一个字符.
            
            如: "hello, world.\0"
            
            注意:
                数组末尾位置的字符\0是空字符(null character), C语言用其来标记字符串的结束
                \0不是数字0, 他是非打印字符, 其ASCII码值是0.
            
            C语言中的字符串一定以空字符结束, 这意味着数组的容量必须至少比待存储字符串中的字符数多1
            如有14个存储单元的数组, 只能存储13个字符, 剩下一个留给空字符.

            按照数组的方式声明并初始化
                char array_str[] = {'h', 'e', 'l', 'l', 'o', '.', '\0'};   // 使用这种方式得手动添加\0, 注意对于多字节的文字, 这是存储不了的
                char array_str[] = "hello.";   // 会自动向末尾添加一个\0
            按照指针的方式指向一个字符串字面常量
                char * array_str = "hello.";
            
            在 string.h 中有专门操作字符串的各种函数
            如:
                size_t strlen ( const char * str ); 返回C字符串的长度, 不包含\0


    浮点类型
        C标准规定: float可精确表示至少6位有效数字, double比float有效数字和指数根多, 至少10位, long double比double有效数字和指数更多

        float - 浮点型
            占4个字节, 有效数字6, 范围 0以及1.2×10⁻³⁸ ~ 3.4×10³⁸
        double - 双精度浮点型
            占8个字节, 有效数字15, 范围 0以及2.3×10⁻³⁰⁸ ~ 1.7×10³⁰⁸
        long double - 长双精度浮点型
            占8个字节, 有效数字15, 范围 0以及2.3×10⁻³⁰⁸ ~ 1.7×10³⁰⁸
            占16个字节, 有效数字19, 范围 0以及3.4×10⁻⁴⁹³² ~ 1.1×10⁴⁹³²

        特殊的浮点值: NaN (not a number)
            如 asin(10) 反函数参数大于1 , 会返回NaN

        注意:
            所有浮点类型的精度都为6, 在满足有效数字时, 精度会完美的呈现, 但是如果超过有效数字, 则精度会有丢失, 优先表示前几位在有效值内的数字

            在将浮点类型转换为整型的时候, 会直接丢弃(截断)小数部分, 而不进行四舍五入, 这会损失精度.

            有些编译处理float时会按照double处理, 可以在数字的后面加字母F或f告诉编译器按照float类型处理.
            数字的后面加字母l或L则指定该数字为long double型
            如:
                float pi = 3.141593f;
                long double pi = 3.141593l;

        浮点字面常量, 可用于对应浮点类型的赋值
            如:
                3.14   3.   0.14   .14
            使用e或E做科学记数表示
                0.314e1   .314e1   314e-2

        浮点值的上溢和下溢 overflow underflow
            当计算导致数字过大, 超过当前类型能表达的范围时, 就会发生上溢.
            C语言规定, 在这种情况下会给溢出变量赋一个表示无穷大的特定值, 而且printf()显示该数值为inf或infinity.
            这叫做上溢

            当对一个很小的数做除法时, 浮点型以指数和尾数部分来存储.
            当一个数指数部分使最小值, 即由全部可用位表示的最小尾数值. 该数字是当前所使用类型能用全部精度表示的最小数字.
            现在对其除以2. 通常这个操作会减小指数部分, 但是假设的情况中, 指数已经是最小值了. 
            计算机将会把尾数部分的位向右移, 空出第一个二进制位, 并丢弃最后一个二进制位.
            如:
                4位有效数字 0.1234e-10 除以10 为 0.0123e10 , 虽然得到结果, 但是失去末尾上的有效数字.
            这叫做下溢, 其结果会低于正常的浮点值

        浮点数舍入错误
            给定一个数, 加上1, 在减去原来给定的数, 结果不一定是1
            如:
                float a, b;
                b = 2.0e20 + 1.0;
                a = b - 2.0e20;
                printf("%f\n", a);   // 结果4008175468544.000000
            原因: 计算机缺少足够的小数位来完成正确的运算. 2.0e20后面有20个0, 如果加上1, 那么发生变化的21位.
                 由于float类型的数字通常只能存储按指数比例缩小或放大的6或7位有效数字. 这种计算一定是错的.
                 改成2.0e4计算就没问题, 只需要改变第5位上的数字

        比较浮点数
            在使用关系运算符操作浮点数对象的时候, 因为浮点数的舍入误差会导致在逻辑上应该相等的两数却不等.
            在实际操作中, 一般采用计算误差来判断两个浮点值是否相等, 当误差趋于一个非常小的数时, 就可认为当前比较的浮点数相等.
            fabs(num1 - num2) < 0.001


    复数和虚数类型
        float _Complex, double _Complex, long double _Complex

        如:
            float _Complex 类型的变量应该包含两个float类型的值, 分别表示复数的实部和虚部
        
        对应的虚数类型
        float _Imaginary, double _Imaginary, long double _Imaginary

        标准库 complex.h , 变可以使用complex代替_Complex, imaginary代替 _Imaginary
        为了对已有代码的兼容性, 以免有命名冲突


    数的工程表示
        整数
            有符号数据存储单元中最高位代表数值的符号(0为正, 1为负), 无符号则存储单元中的所有位都用做存放数值本身.
            对于负数, 其是以补码的形式储存的, 这样在与整型运算的时候更加方便.
            负数, 先取对应正数的二进制, 然后各二进制为取反, 最后补上(加上)1, 便是该负数在系统中的存储方式
            如2字节的short, 其0~32767表示他们本身, 而数字32768~65535则表示负数, 其中65535表示-1, 65543表示-2, 以此类推
        浮点数
            浮点数以二进制形式下的指数方式代表, 类似于科学计数法, 一位表示符号, 一部分表示小数部分, 一部分表示指数部分
            如float类型
                1位数符 ∪ 23位小数 ∪ 8位指数, 即最后合成浮点数 ±1✕小数✕2⁸


布尔型
    _Bool - 布尔型
        所占空间只要能存储0和1即可

    标准库 stdbool.h 中 bool类型, true 为1, false 为0.

    布尔类型的数据只存储真和假, 对应的值为1和0, 
    当赋予非零值时, 会转换为1, 即真, 当赋予零值时, 会转换为0, 即假
    如:
        _Bool b;
        b = 3.2;   // 存储真, 值为1
    C将所有的非零值都视为真.

    注意
        在使用关系运算符计算两个表达式的时候, 所得值也是真或假, 即对应数值1或0


C语言可以使用八进制和十六进制数值为整数类型赋值
    八进制
        使用 0 前缀表示八进制, 数字使用范围 0 ~ 7
        如:
            int oct_num = 077;   // 63

    十六进制
        使用 0x 或 0X 前缀表示十六进制值, 数字使用范围 0 ~ f
        如: 
            int hex_num = 0xff;   // 255
    

可移植的类型
    C语言提供了许多有用的整数类型, 但是某些类型名在不同系统中功能不一样.
    使用标准库 stdint.h, 和 inttypes.h, 可以确保C语言的类型在各系统中的功能相同.
    因为有些功能计算机底层系统不支持, 所以将这些作为可选项.

    stdint.h
        C标准库, 定义了具有特定位宽的整型, 以及对应的宏, 还列出了在其他标准头文件中定义的整型的极限.

        精确宽度整数类型 exact-width interger type
        如:
            int32_t, 定义为系统中可容纳32位有符号整型的别名, 可能计算机底层系统的不支持

        最小宽度类型 minimum width type
        如:
            int_least8_t, 定义为系统中可容纳8位有符号整数值中宽度最小的类型别名, 如果系统最小整数类型是16位的, 可能就不会定义int8_t类型, 但是用的话会换成int16_t, 这样就避免了错误

        最快最小宽度类型 fastst minimum width type
        如:
            int_fast8_t, 定义为系统中对8位有符号值而言最快的整数类型别名

        intmax_t, 定义为系统中最大的有符号整数类型
        uintmax_t, 定义为系统中最大的无符号整数类型


    inttypes.h
        C标准库, 提供了各种位宽的整数类型输入输出时的转换标志宏.

        如: PRId32 字符串宏, 提供了打印32位有符号值的合适转换说明.
            printf("number = " PRId32 "\n", num);
        
        注意:
            C语言中可以把多个连续的字符串组合成一个字符串.
            如: 
                char array_str[35] = "hello," "world." "\n";


类型转换
    类型转换规则
        当类型转换出现在表达式时, 无论是unsigned还是signed的char和short都会被自动转换成int, 如果有必要, 会被转换成unsigned int
        在某些较老的编译器中, float会被自动转换成double.
        由于以上都是从容量较小的类型转换为容量较大的类型, 所以这些转换被称为升级(promotion)

        涉及两种类型的运算, 两个值会被分别转换成两种类型的更高级别的那一方

        类型的级别从高到低依次是long double, double, float, unsigned long long, long long, unsigned long, long, unsigned int, int.
        例外的情况是, 当long和int容量相同, unsigned int比long的级别高. 没有short和char, 因为这两者会被升级到int 或unsigned int.

        在赋值表达式语句中, 计算的最终结果会被转换成被赋值变量的类型. 这个过程可能会导致类型的升级(promotion)或降级(demotion)

        当作为函数参数传递时, char和short被转换成int, float被转换成double.

    类型与数据内容不匹配
        如:
            较低类型可能放不下整个数字
        当出现待赋值的值与目标类型不匹配时:
            ● 目标类型是无符号整型, 且待赋的值是整数时, 额外的位将被忽略
            ● 如果目标类型是一个整型, 且待赋的值是整数时, 结果因实现而异
            ● 如果目标类型是一个整数, 且待赋的值是浮点数, 该行为使未定的


其他一些补充
    在C语言标准库 limits.h 和 float.h 分别提供了与整数类型和浮点类型大小限制相关的详细信息.
    每个头文件都定义了一系列供使用的明示常量(字符常量).
    
        limits.h中
            # define INT_MAX +32767
            # define INT_MIN -32768


    在C语言标准库 ctype.h包含了用于判断字符和转换大小写等的函数.

        int toupper(int __c) 返回字符c对应的大写字符
        int tolower(int __c) 返回字符c对应的小写字符
        int isalnum(int) 参数字符是否是字母或数字
        int isprint(int) 参数字符是否可打印字符
        int isspace(int) 参数字符是否空白字符(空格,换行符,换页符,垂直制表符,水平制表符,其他本地化定义的字符)


    size_t, 用以表示字节个数. 标准规定了该值是一个无符号整数.

    ptrdiff_t, 是两个指针差值的底层有符号整数类型.
