0. 预处理指令(preprocessing direcitve)

    C标准不仅描述C语言, 还描述如何执行C预处理, C标准库有哪些函数, 以及详述这些函数的工作原理.

    C预处理器在程序执行之前查看程序. 根据程序中的预处理器指令, 预处理器把符号缩写替换成其表示的内容.
    预处理器可以包含程序所需的其他文件, 可以选择让编译器查看哪些代码.
    预处理器并不知道C. 基本上他的工作是把一些文本替换成另外一些文本.

    在预处理之前, 编译器必须对该程序进行一些翻译处理.
        首先, 编译器把源代码中出现的字符映射到源字符集. 该过程处理多字节字符和三字节字符
        第二, 编译器定位每个反斜杠\后面跟着换行符的实例, 并删除他们. 让预处理时表达式的长度是一个逻辑行. 这里的换行符指书写源代码时使用Enter输入的换行
            puts("hello, wo\
            rld.");
            将会被处理为
            puts("hello, world.");
            换为一个逻辑行logical line
        第三, 编译器把文本环分成预处理记号序列, 空白序列, 注释序列. 需要注意, 编译器将用一个空格字符替换每一条注释.
            int/* 注释内容 */num;
            将会被处理为
            int num;

    在预处理阶段, 预处理器把程序中的注释全部删除, 并用一个空格代替, 并开始对预处理指令进行处理
        如将#include 指令指定的头文件的内容复制并替换在该指令位置处
        对#define 指令, 将该指令定义的宏替换为指定的文本, 替换完成后删除指令所在行

    经过处理后的待编译代码不包含任何预处理指令, 再由编译器生成可执行的目标代码.

    1) 预处理指令的常用功能
        1. 宏定义
        2. 文件包含
        3. 条件编译

    2) 格式样式
        为了与C语言相区别, 以# 作为一行的开始, 预处理器通过查找# 来定位预处理指令的位置
        允许#前面有空格, 制表符. 允许#和指令的其余部分之间有空格.

    3) 位置
        指令可以出现在源文件的任何地方, 其定义从指令出现的地方到该文件末尾有效.
        

1. 宏定义
        # define指令可以定义宏
            # define 宏 替换体
        通常定义的宏有如下用处
            代表值
            类对象宏(object-like macro)
            函数宏
        宏名字必须遵守C变量命名规则: 只能使用字符, 数字, 下划线, 而且首字符不能是数字, 长度不能超过64.
        一旦预处理器在程序中找到宏的实例后, 就会用替换体代替该宏. 
        从宏变为所替换的文本, 该过程称为宏展开macro expansion.

        注意
            宏定义只是用宏名代替一个字符串, 也就是只做简单的替换, 构成C代码的一部分, 但是不会进行正确性检查.
            宏定义不是C语句, 不必在行末加分号. 如果有了分号, 则会连带分号一起进行置换.
            在进行宏定义的时候, 可以引用以定义的宏名, 即可以层层置换.
            宏定义与定义变量的含义不同, 不分配存储空间. 不带参数的宏定义只作简单的字符替换.
            程序中用双撇号括起来的字符串内的字符, 即使与宏名相同, 也不进行置换.

    1) 符号常量
        符号常量, 也叫做明示常量(manifest constant)

        # define 标识符 字符串

        解除定义的符号常量.
        # undef 标识符

        如
            # define PI 3.141592
            ...
            # undef PI
        在程序文件中, 将会由3.141592 来替换所有未在字符串中出现的PI. 这个PI标识符一般就就做宏名, 在预处理时将宏名替换为字符串的过程称为宏展开.

        宏名习惯上由大写字母表示, 以便避免与程序中变量名混淆.

        注意:
            #define 指令出现在程序中的函数外面, 宏名的有效范围为该指令行起到本源文件结束.
            通常, #define 指令写在文件开头, 函数之前, 作为文件一部分, 在整个文件范围内有效. 可以用#undef 终止宏名的定义.

    2) 带参数的宏定义
        # define 宏名(参数表) 字符串
        字符串中包含在括号中所指定的参数
        如
            # define SUM(a, b) a+b
            ...
            sum = SUM(3, 2);
        在预处理时将会被替换为 sum = 3+2;

        在程序中如果有带实参的宏, 则按#define 指令行中指定的字符串从 左→右 进行置换. 
        如果字串中包含宏中的形参, 则将程序语句中相应的实参(可以是常量,变量,表达式)代替形参. 
        如果宏定义中的字符串中的字符不是参数字符, 则保留.
        这样就形成了置换的字符串.

        如
            # define PI 3.141592
            # define AREA(r) PI*r*r
            ...
            area = AREA(radius);
        对带参数的宏的展开, 只是将语句中的宏名后面括号内的实参字符串代替#define 指令中的形参.
        在对area的赋值语句进行替换的时候, 找到#define指令中的AREA(r), 将AREA(radius)中的实参字符radius代替宏定义中的PI*r*r中的形参r. 得到PI*radius*radius.

        如果给出 area = AREA(x + y);
        则会出现 area = PI*x + y*x + y;
        这可能并不是想要的替换结果, 可以在定义的时候加上括号 # define AREA(r) PI*(r)*(r)

        注意:
            在定义宏时, 在宏名与带参数的括号之间不应该加空格, 否则会将空格以后的字符都做为替代字符串的一部分
            如
                # define AREA (r) PI*(r)*(r)
                这样会将AREA看作符号常量, AREA后面的(r) PI*(r)*(r)将被用作替换字符串

        (1) 带参数的宏定义与函数的区别
            函数调用时, 先求出实参表达式的值, 然后代入形参. 而使用带参数的宏只是进行字符替换
            函数调用是在程序运行时处理的, 为形参分配临时的内存单元. 而宏置换则是在预处理阶段进行的, 在置换时并不分配内存单元, 不进行值的传递处理, 也没有返回值概念
            对函数中的实参和形参都要定义类型, 二者的类型要求一致, 如不一致, 应进行类型转换. 而宏不存在类型问题, 宏名无类型, 他的参数也无类型, 只是一个符号代表, 置换时, 代入指定的字符串即可. 
            定义宏时, 字符串可以是任何类型的数据
            调用函数只可得到一个返回值, 而用宏可以设法得到几个结果
            使用宏次数越多时, 宏展开后源程序变长, 因为每展开一次都是代码量增长, 而函数调用不会使源程序变长
            宏替换不占运行时间, 而函数调用则占运行时间(分配单元, 保留现场, 值传递, 返回)

        (2) 适用例子
            一般将宏用来代表简短的表达式比较合适

            例子
                # define PI 3.141592
                # define CIRCLE(r) printf("圆的周长:%lf, 圆的面积:%lf\n", 2*PI*(r), PI*(r)*(r))
                ...
                CIRCLE(redius);

            可以拼接来写

            例子
                # define PR printf
                # define INTEGER "输出: %d"
                # define ENDLN "\n"

                # define PRINT_1 INTEGER ENDLN
                # define PRINT_2 INTEGER INTEGER ENDLN
                ...
                int a=1, b=2;
                PR(PRINT_1, a);
                PR(PRINT_2, a, b);
                ...
                可以使用puts(PRINT_1); 来查看拼和置换后的字符串

                若使用#undef ENDLN 释放, 那么PRINT_1和PRINT_2 就都没法用了

            可以发现, 如果是纯字符型的, 原内容需使用双撇号括起来, 这样会自动拼接

2. 文件包含
    # include <文件名>
    # include "文件名"

    作用
        包含以上指令的源文件, 会将指定文件名的另外一个源文件包含进来, 即将另外的文件内容包含到文本文件之中, 替换指令位置.
        在进行编译的时, 不是分别对源文件和被包含的源文件进行编译, 然后再将他们的目标程序连接的.
        而是在预处理时将被包含的源文件内容包含到主源文件中(取代#include 指令), 得到一个新的源程序
        即被包含的源文件中的内容成为新的源文件的一部分.

    这种常用在文件头部的被包含的文件称为标题文件或头文件, 常以 .h (header)作为后缀.
    当然不用.h 用 .c也可以, 只是这样能更明确的表现该文件的作用.

    1) <> 与 "" 的区别
        使用<> 包含文件名的时候, 预处理器将会到存放C库函数头文件的目录中寻找要包含的文件, 这称为标准方式.
        使用"" 包含文件名的时候, 预处理器将会先在用户当前目录中寻找要包含的同名文件, 若找不到, 再按标准方式寻找.
        另外, 若该头文件没有放在用户当前目录或库文件目录中, 可以使用"" 指明头文件的路径, 如: #include "/usr/share/c/file.h"

    2) 使用要点
        (1) 一个#include 指令只能指定一个被包含的文件, 如果要包含n个文件, 要用n格#include 指令.
        (2) 如果文件1需要包含文件2, 而文件2又需要用到文件3的内容, 则可以文件1中用两个#include 指令分别包含文件3和文件2.
            文件3应该出现在文件2之前. 因为#include 是将文件中的字符内容复制到源文件指令位置.
            所以可以看做, 先有了文件3的内容, 然后后面文件2的内容又被复制进来, 自然能使用先前复制进来的3中的内容.
        (3) 针对上面问题, 其实在一个被包含文件中又可以包含另一个文件, 即文件可以嵌套. 
            上面只需文件2提前在自己中#include 文件3, 然后源文件也就只需包含文件2就可以了. 同样的这三个文件的内容也是被复制合在一起.
        (4) 头文件除了可以包括函数原型和宏定义外, 也可以包括结构体类型定义和全局变量定义等.

3. 条件编译
    # ifdef 标识符
        程序段
    # endif

    作用
        若自定的标识符已经被#define 指令定义过, 就保留程序段, 否则在编译前将程序段删除
   
    # ifdef 标识符
        程序段1
    # else
        程序段2
    # endif

    作用
        若自定的标识符已经被#define 指令定义过, 则在程序编译阶段对程序段1进行编译, 否则编译程序段2.
        实际上预处理器发现所指定的标识符已经被#define 定义过, 就保留源程序中的程序段1, 而将程序段2删除, 否则就保留程序段2, 删除程序段1.
        在最后编译的源程序中只包含程序段1或2.

    这里的程序段可以是语句组, 也可以是指令行.

    # ifndef 标识符
        程序段1
    # else
        程序段2
    # endif

    作用
        若指定的标识符未被定义过, 则保留程序段1, 删除程序段2, 否(定义了对应标识符)则保留程序段2, 删除程序段1
        这样在编译源文件的时候, 就只有一个程序段
        ifndef 就是 if not define
    
    # if 表达式
        程序段1
    # else
        程序段2
    # endif

    作用
        当指定的表达式值为真(非零)时就保留程序段1, 删除程序段2, 否则(表达式为任意非零数)保留程序段2, 删除程序段1
        这样在编译源文件的时候, 就只有一个程序段

    1) 使用优势
        使用条件预编译, 可以减少被编译的语句, 从而减少目标程序的长度, 减少运行时间. 当条件编译较多时, 目标程序长度可以大大减少.

    以上的预处理功能都是C语言特有的, 有利于程序的可移植性

    2) 使用示例

        # ifdef COMPUTER_64
            # define INTEGER_SIZE 8
        # else
            # define INTEGER_SIZE 4
        # endif

        若在以上条件编译指令前出现 #define COMPUTER_64, 那么#ifdef 下面的留下, #else 下面的删了

        # ifdef DEBUGE
            printf("错误码: %d, 描述: %s", err, decr);
        # endif

        可以这样用来切换是否打印一些额外额信息

        # define IS_PRINT 1
        int main(){
            ...
            # if IS_PRINT
                puts("打印");
            # endif
            ...
        }

        判断是否执行, 注意, #if 后面跟的是可以反映真假的表达式

        注意, # define DO 就算宏定义的时候, 不定义任何内容, 也算是定义了的