1. 封装一个新的数据类型
    首先, 必须提供存储数据的方法, 例如设计一个结构.
    其次, 必须提供操控数据的方法, 例如如何创建, 如何删除内容.
    1) 从抽象到具体
        1.提供类型属性和相关操作的抽象描述. 这些描述既不能依赖特定的实现, 也不能依赖特定的编程语言. 这种正式的抽象描述被称为抽象数据类型(Abstract Data Type, ADT).
        2.开发一个实现ADT的编程接口. 也就是说, 指明如何存储数据和执行所需操作的函数. 例如在C中, 可以提供结构定义和操控该结构的函数原型.
        3.编写代码实现接口.

2. 链表
    电影链表的封装
    用于记录一年间看过的电影, 需要有电影名, 评分, 因为不知道一年能看多少, 所以应该使用一个链表, 而不是只能固定内存大小的多维数组数据结构, 有一个生成一个, 还节约内存.
    1.建立抽象
        属性特征
            单向链表, 可以储存电影名, 评分.
        需要的操作
            初始化链表为空
            判断链表为空
            判断链表已满
            判断链表中项数
            在链表末尾添加项
            遍历链表以处理链表中的项
            清空链表
    2.定义接口
        这个单向链表的接口分两部分. 
        1) 描述如何表示数据 
            例如, 要设计在链表中添加项的函数和报告链表中项数的函数. 接口设计应尽量与ADT的描述保持一致.
            因此, 应该用某种通用的Item类型而不是一些特殊类型, 如int或struct film. 可以使用C的typedef来定义所需.
            # define TSIZE 63
            struct film {
                char title[TSIZE];
                int rating;
            };
            typedef struct film Item;
            然后就可以在定义其余部分使用Item类型. 如果以后需要其他数据形式的链表, 可以重新定义Item, 不必更改其余的接口定义.

            独立出了Item, 先在应确定如何存储这种类型的项. 实际上这属于实现步骤, 先在这决定好可以让下面的操作理解简单点.
            typedef struct node {
                Item item;
                struct node * next;
            } Node;
            定义节点类型, 每隔节点包含形成链表内容的信息和指向下一个节点的指针.

            typedef Node * List;
            为了管理链表, 还需要一个指向链表开始处的指针, 使用typedef把List作为该类型的指针名.
            更好一点的方式
            typedef struct list {
                Node * head;
                int size;
            } List;
            head用以记录链表头, size用以记录当前指向的链表项数

            声明一个链表
            下面的声明创建了一个链表, 而不是一个指向节点的指针或一个结构.
            List movie_list;
            movie_list代表的确切数据应该是接口层次不可见的实现细节.
            例如程序启动后应把头指针初始化为NULL. 但是不应该 movie_list = NULL
            而是根据List类型的结构
            movie_list.head = NULL;
            movie_list.size = 0
            使用List的人都不用担心这些细节, 只要能使用下面代码就行
            InitializeList(movie_list);
            这是数据隐藏的一个示例

        2) 描述实现ADT操作的函数
            初始化链表 InitializeList(), 使用者可以不需要知道实现细节, 而只需要知道其作用, 需要的参数, 返回的内容就可以. 这也是数据隐藏的一个示例.
            在这里明白的注释将会有很大帮助.
            /* 操作: 初始化一个链表 */
            /* 前提条件: plist指向一个链表 */
            /* 后置条件: 该链表初始化为空 */
            void InitializeList(List * plist);
            前提条件(precondition), 描述调用该函数前应具备的条件. 后置条件(postcondition), 描述执行完该函数后的情况.
            该函数的参数是一个指向链表的指针, 而不是一个链表. 应该如下方式调用. (指向Node *指针的指针)
            InitializeList(&movie_list);
            C语言将所有类型和函的信息集合成一个软件包的方法是: 把类型定义和函数原型(包括前提条件和后置条件)放在一个头文件中. 该头文件应该提供用户使用该类型所需的所有信息.
            
            如 list.h 中, 该程序定义了一个特定的结构作为Item类型, 然后根据Item定义了Node, 在根据Node定义了List. 
            然后把表示链表操作的函数设计成接受Item类型和List类型的参数. 如果函数要修改一个参数, 那么该参数的类型应该是指向相应类型的指针, 而不是该类型
    3. 实现接口
        C 一般是把函数定义同意放在另一个文件中, 在例中为与头文件同名的list.c. 整个程序由list.h中的数据结构和接口原型提供实现的架构.
    4. 使用接口
        main函数所在, 实现具体的功能.
        在例中, list.h定义数据结构和提供用户接口的原型, list.c提供函数代码实现接口, film.c把链表接口应用于特定编程问题.
        最后只需要将list.c和film.c一起编译和链接.

3. ADT方法做了什么
    使用ADT将方法总结成了实际的事务, 并将其一一实现了出来. 对数据的操作变成了做一件具体的事, 方便理解, 同时也隐藏了具体的编程细节, 而变成了直接开箱即用.
    从实际任务来写代码.
    list.h和list.c文件一起组成了可复用的资源. 如果需要另一个简单的链表, 也可以使用这些文件.
    
    假如是需要存储亲友的一些信息 - 姓名, 关系, 地址, 电话号码
    先在list.h中重新定义Item
    typedef struct itemtag {
        char name[32];
        char relationship[32];
        char address[128];
        char phone[24];
    } Item;
    然后, 因为所有处理简单链表的函数都与Item类型有关. 根据不同的情况, 有时还需要重新定义CopyToNode()函数. 如当项是一个数组时, 就不能通过赋值来拷贝了.

    因为用户接口是根据抽象链表定义的, 不是根据某些特定的数据表示和算法来定义.
    这样, 不重写最后的程序就能随意修改实现.
    例如当前使用的AddItem()函数效率不高, 因为它总是从链表的第一项开始向后移至末尾.
    可以通过保存链表结尾处的地址来解决这个问题.
    typedef struct list {
        Node * head;
        Node * tail;
    } List;
    当然, 还要根据新的定义重写处理链表的函数, 但是不用修改film.c中的内容.
    对大型编程项目来说, 这种把实现和最终接口隔离的作法相当有用. 称为数据隐藏, 对终端用户隐藏了数据表示的细节.
    