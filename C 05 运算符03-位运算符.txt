C按位运算符
    用于整型数据, 包括char

    优先级2, 左←右, 单目运算符
        ~  : 按位反

    优先级5, 左→右, 双目运算符
        << : 左移运算符
        >> : 右移运算符

    优先级8, 左→右, 双目运算符
        &  : 按位与

    优先级9, 左→右, 双目运算符
        ^  : 按位异或

    优先级10, 左→右, 双目运算符
        |  : 按位或

    优先级14, 左←右, 双目运算符
        <<= : 左移后赋值
        >>= : 右移后赋值
        &=  : 按位与后赋值
        ^=  : 按位异或后赋值
        |=  : 按位或后赋值

--------------------------------------------------------------

注意
    参加位运算的对象只能是整型或字符型(char)的数据, 负数都是以补码的形式参加运算的
    之所以叫作按位bitwise运算, 是因为这些操作都是针对每一个位进行的, 不影响它左右两边的位.
    要注意区分常规的逻辑运算符(!, &&, ||), 常规的逻辑运算操作的是整个值.
    在C中, 编译器只识别八进制, 十进制, 十六进制的数, 例如在程序中用031, 25, 0x19, 而不能直接输入二进制形式的数, 00011001

分类
    按位逻辑运算符
        按位反 ~
        按位与 &
        按位异或 ^
        按位或 |

    移位运算符
        左移 <<
        右移 >>

运算规则概括
    ~ 0变1, 1变0
    << 左移指定位数, 相当与×2ⁿ
    >> 右移指定位数, 相当于÷2ⁿ
    & 都是1, 返1, 有个0, 返0
    ^ 两个不同返1, 两个相同返0
    | 都是0, 返0, 有个1, 返1

补充
    二进制, 逢2进1
        0, 1, 10, 11, 100, 101, 110, 111, 1000

    正十进制转二进制, 除2取余, 倒排余数, 高位0占
        19 ÷ 2 = 9 ... 1
        9  ÷ 2 = 4 ... 1
        4  ÷ 2 = 2 ... 0
        2  ÷ 2 = 1 ... 0
        1  ÷ 2 = 0 ... 1
        倒着取余数 -> 10011
        若按一个整数一字节, 补到8位 -> 00010011
        即为19 的二进制
    正二进制转十进制, 按位乘2的对应次方
        00010011 共8位, 按位数排下来是 7,6,5,4,3,2,1,0
        0*pow(2,7) + 0*pow(2,6) + 0*pow(2,5) + 1*pow(2,4) + 0*pow(2,3) + +0*pow(2,2) + 1*pow(2,1) + 1*pow(2,0) == 19

    负十进制转二进制, 对应的正十进制转为二进制后, 对该二进制取反~, 然后加1 (取补码)
        00010011 - 取反~ -> 11101100 -在加1-> 11101101   (实际代表-18)
    负二进制转十进制
        如果最高位为0, 这是一个正数, 补码和原码相同
        如果最高位为1, 这是一个负数, 需要取反~, 在按正二进制转十进制方法计算
            11101101 - 取反~ -> 00010010 -> 1*pow(2,4) + 0*pow(2,3) + 0*pow(2,2) + 1*pow(2,1) + 0*pow(2,0) == -18
            
    小数转二进制, 对小数点后面的数乘2, 取结果个位(为0或1), 在接着用这个结果的小数部分乘2, 取结果个位(0或1)...直到小数部分为0或者位数已够
        0.125 转二进制
        0.125*2 = 0.25 取个位 0
        0.25 *2 = 0.5  取个位 0
        0.5  *2 = 1.0  取个位 1
        小数部分为0, 结束
        则获得0.125的二进制为 0.001
        用二个字节表示一个浮点数, 那么19.125 二进制:0.0001, 科学记数法 1*pow(2,-4), 后移动四位, 在内存中表现 0001001100010000
    二进制转小数, 按位乘2的对应次方
        二进制 0.1101, 从个位按位数排下来是 0,-1,-2,-3,-4
        0*pow(2,0) + 1*pow(2,-1) + 1*pow(2,-2) + 0*pow(2,-3) + 1*pow(2,-4) == 0.8125


--------------------------------------------------------------

掩码 mask
    掩码是指一些设置为开(1)或关(0)的位组合. 在计算机学科及数字逻辑中指的是一串二进制数字, 通过与目标数字的按位操作, 达到屏蔽指定位而实现需求
    因为C语言中用八进制, 十进制, 十六进制表示数值, 而不能直接用二进制表示, 所以这些位组合都先计算好, 在转换为可用的进制进行位运算


1. 按位取反
    反 ~ 运算
    对二进制数按位取反, 即将0变1, 将1变0

    ~ 为单目运算符, 左←右, 比算术运算符, 关系运算符, 逻辑运算符和其他运算符优先级都高

    1) 例
        ~25
        0000000000011001
      ~  
      -------------------
        1111111111100110   十进制 65510
    
    2) 应用
        (1) 关闭位 (清空位)
            有时需要在不影响其他位的情况下关闭指定的位.
            可以先对用来运算的数取反, 然后在于被计算整数进行按位与
            
            如想让00001111, 十进制15, 第1位和第2位关闭, 使用11110110, 十进制246, 先取反, 再按位与
            
            ~10110110 变为 00001001

              00001111   十进制 15
            & 00001001
            -----------
              00001001
            C语言表达式为 num & ~ mask
            mask中为1的位在结果中都被设置为(清空)为0. num中与mask为0的位相应的位在结构中都未改变.

            如想让一个数的最后一位为0, 如1101, 想让最后一个1变为0, 配合& 与运算, 1101&1110
            可以这样 num & ~1 即可

2. 左移
    << 左移运算符, 左→右, 双目运算符
    用来将一个数的各二进制位全部左移若干位, 右补0, 溢位舍

    左移一位相当于乘以2, 移动若干位, 相当于乘以2的对应次方. 这个情况只适用于该数左移时被溢出舍弃的高位中不包含1的情况.

    1) 例
        15<<2
        00001111
    <<2  
    -------------
        00111100   十进制 60

        相当于 15 * pow(2, 2), 即 15 * 4

        -15<<2
        11110001
    <<2
    -------------
        11000100   表示为十进制 -60

        和正数左移一样, 在负数的二进制位右边补0, 一个数在左移的过程中会有正负切换的情况, 所以负数左移不会特殊处理符号位.
        如果一直左移, 最终会变成0.

    2) 应用
        左移运算比乘法运算要快, 可以使用左移来代替乘以2即其次方的情况

3. 右移
    >> 右移运算符, 左→右, 双目运算符
    用来将一个数的各二进制位全部右移若干位, 对无符号, 左补0, 溢位舍

    右移一位相当于处以2, 移动若干位, 相当与除以2的对应次方.

    右移时, 需注意符号位问题. 对无符号数, 右移时左边高位补0. 
    对与有符号的数, 如果原来符号位是0, 则补0, 如果符号位为1, 根据系统或编译器的不同, 会补1保证符号和补0依照运算两种.
    补1称为 算术右移, 补0称为 逻辑右移.
    VC++ 中 msvc, GNU GCC编译器都是算术右移.

    1) 例
        -6125>>2
        1001011111101101
    >>2 
    ---------------------
        1000010111111011   表示为十进制 -1531 
    
    这是算术右移, 补了符号1

4. 按位与
    与 & 运算
    对应二进制位都是1, 返1, 否则为0
    即: 0&0=0, 0&1=0, 1&0=0, 1&1=1

    按位与和赋值结合的运算符 &=

    1) 例
        7&5=5
          00000111
        & 00000101
        -----------
          00000101

        -7&-5
          11111001
        & 11111011
        -----------
          11111001

    2) 应用
        (1) 应用于掩码
            按位与运算符常用于掩码.
            掩码 2, 二进制形式 00000010, 从右边1位为开(1), 其他都为0
            一个整数与掩码2进行按位与运算的时候
                10010110   十进制 150
              & 00000010
                -----------
                00000010
            C语言表达式为 num & mask
            任何整数与掩码2进行按位与运算都只会保留1号位的值. 
            这个过程叫做使用掩码, 因为掩码中的0隐藏了与其进行按位与运算的整数中相对应的位

            为了方便理解, 把掩码中的0看作不透明, 1看作透明. 表达式 num & mask相当于用掩码覆盖在num的位组合上, 只有mask为1的位才可见.

            常用的掩码数 
                二进制11111111, 对应八进制0377 ,十进制255, 十六进制0xff
                与其运算只保留低位8位, 或者说低位的1个字节

        (2) 检查位的值
            检查某位的值不能直接使用==进行比较, 因为这样是对数值大小的比较, 而不是对某一个位上开关相同的比较
            应该使用按位与计算比较值与被比较值之间某位是否相同
            查看00001111, 十进制15, 是否第3位为开(1), 通过与00001000, 十进制8, 进行按位与运算, 结果为非零即可验证
                00001111   十进制 15
              & 00001000
              -----------
                00001000
            C语言表达式为 (num & mask) == mask
            因为按位与运算符&比关系远算符==优先级低, 所以得用圆括号括起来

            为了避免信息漏过边界, 掩码至少要与其覆盖的值宽度相同

        (3) 取一个数中某些指定位
            想要将01010100中第0, 1, 3, 4, 5位保留下来, 只需找一个在这些位为1的掩码与其进行按位与运算
                01010100   十进制 84
              & 00111011   十进制 59
              -----------
                00010000   十进制 16


5. 按位异或
    异或 ^ 运算
    参加运算的两个二进制位不同(异), 则返1, 否则为0
    即: 0^0=0, 0^1=1, 1^0=1, 1^1=0

    按位异或和赋值结合的运算符 ^=

    1) 例
        00111001   十进制 57
      ^ 00101010   十进制 42
      -----------
        00010011   十进制 19

        异或 的意思是判断两个相应的位值是否为 异, 是(两个不同)就返1, 否(两个相同)就返0
    
    2) 应用
        (1) 切换位
            切换位指的是打开已关闭的位, 或关闭已打开的位, 也就是翻转0和1
            如01111010, 想使其后四位翻转, 即1变为0, 0变为1
                01111010   十进制 122
              ^ 00001111   十进制 15
              -----------
                01110101   十进制 117
            因为15的后四位都为1, 按位异或将对应位不同的返回1, 相同返回0, 这会使122的后四位变为与原位值相反的, 1变0, 0变1.

        (2) 和0相^, 保留原值
                00001010   十进制 10
              ^ 00000000   十进制 0
              -----------
                000010010  十进制 10
            0所有位都是0, 与其他数对应位比 0^1=1, 0^0=0, 这样返回和原数位上的还是一样的

      ★ (3) 不使用中间量, 交换两个值
            假如 a=3, b=4, 想要将a和b的值互换, 可以如下
                a = a^b;
                b = a^b;
                a = a^b;
            或
                a^=b;
                b^=a;
                a^=b;
            实际发生的
                00000011   a
              ^ 00000100   b
              -----------
                00000111   赋值给 a
              ^ 00000100   b
              -----------
                00000011   赋值给 b
              ^ 00000111   a
              -----------
                00000100   赋值给 a
            a^=b, b^=a; 相当于 b = b^(a^b). 而b^a^b等于a^b^b. b^b^b的结果为0, 因为同一个数和本身相^(异或), 结果必为0, 因此b的值等于a^0, 即a
            之后, a^=b; 由于a的等于a^b, b的值等于b^a^b, 因此, 相当于 a=a^b^b^a^b, 同0^b, 等于b

6. 按位或
    或 | 运算
    两个对应的二进制位中只要有一个为1, 该位的结果值为1
    即: 0|0=0, 0|1=1, 1|0=1, 1|1=1

    按位或与赋值结合的运算符 |=

    1) 例
        00110000   十进制 48
      | 00001111   十进制 15
      -----------
        00111111   十进制 63
    
    2) 应用
        (1) 打开位 (设置位)
            有时需要打开一个值中特定位, 同时保持其他位不变. 例如计算机操控某个硬件.
              00001111   十进制 15
            | 10110110
            -----------
              10111111
            C语言表达式为 num | mask
            通过num与mask按位或运算, 根据10110110中为1的位, 把整数中对应的位设置为1, 其他位不变
