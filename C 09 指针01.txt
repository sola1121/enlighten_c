指针 pointer
    C指针属于派生类型, 依赖于其他类型存在.
    指针是C语言最重要的概念之一, 用于存储变量的地址.
    从根本上看, 指针是一个值为内存地址的变量(或数据对象).
    指针类型的变量本身占用的内存大小是固定的(无论该指针指向哪种数据类型), 在32位系统中为 4字节, 在64位系统中为 8字节.

    指针提供一种以符号形式使用地址的方法.
    因为计算机非常依赖地址, 指针在某种程度上把程序员想要的指令以更接近机器的方式表达.
    因此指针更有效率.

    在程序中定义了一个变量, 在对程序进行编译时, 系统就会给这个变量分配内存单元.
    编译系统根据程序中定义的变量类型, 分配一定长度的空间.
    C中的地址包括位置信息(内存编号, 或叫纯地址)和他所指向的数据的类型信息(用于标明所占内存有多大).
    通过地址, 能找到所需的变量单元, 地址所代表的就是该内存单元的在电脑内存中的位置.
    指针就是记录地址的变量, 用于指向变量所在.

    在电脑中, 实际的变量访问都是通过地址进行的.
    直接使用变量名进行内存访问的叫直接访问.
    通过将变量的地址存放在另一个变量中, 然后通过这另一个变量, 来找到原先变量的地址, 从而访问原来的变量的方式叫间接访问, 也就是指针访问, 这另一变量就是指针变量


--------------------------------------------------------------

声明指针
    类型名 * 指针变量名;

    C中的主要地址包括对象所在内存编号和该内存块的大小两个信息主成. 所以声明指针变量时必须指定指针所会指向的变量的类型(内存块大小).
        int * pi;
        char * str;
        double *pd1, *pd2;

    类型说明符表明了指针所指向对象的类型, 星号*表明声明的变量是一个指针
    星号*和指针名之间的空格可有可无. 习惯上在声明是使用空格, 解引用变量时省略空格


赋值指针
    使用&取地址运算符获取普通变量的地址. 也可以同类型指针间赋值.
        int * pi;
        pi = &num1;
        double * pd1 = &num2;

        pi = 3;   // 直接将整数赋值给指针也是可以的, 但是这会让指针指向一个未知的内存
    因为地址的内存编号实际上就是一个正整数, 所以可以将整数赋值给指针


获取指针指向值
    在指针前面使用* 解引用运算符, 就可以得到该指针所指向对象的值
        *pi;   // 解指针引用, 获取对应地址的存储的数据


指针操作
    赋值, 可以把地址赋给指针
    解引用, *解引用运算符给出指针指向地址上存储的值
    取地址, 和所有变量一样, 指针变量也有自己的地址和值. 对指针而言, &取地址运算符给出指针本身的地址
    指针与整数相加, 可以使用+加法运算符把指针与整数相加, 或整数与指针相加. 无论哪种情况, 整数都会和指针所指向类型的大小(以字节为单位)相乘, 然后把结果与初始地址相加
    递增指针, 递增指向数组元素的指针可以让指针移动至数组的下一个元素
    指针减去一个整数, 可以使用-减法运算符从指针中减去一个整数. 指针必须是第一个运算对象, 整数是第二个运算对象. 该整数将乘以指针指向类型的大小(以字节为单位), 然后用初始地址减去乘积
    递减指针, 递减指向数组元素的指针可以让指针移动至数组的上一个元素
    指针求差, 可以计算两个指针的差值. 通常求的两个指针分别指向同一个数组的不同元素, 通过计算求出两元素之间的距离. 差值的单位与数组类型的单位相同.
            只要两个指针都指向相同的数组(或者其中一个指针指向数组后面的第一个地址), C都能保证相减运算有效.
            如果两个指针指向两个不同数组的指针进行求差运算可能会得出一个值, 或者导致运行时错误.
    比较, 运用关系运算符可以比较两个指针的值, 前提是两个指针都指向相同的类型对象.

    注意, 这里的减法有两种. 可以用一个指针减去另一个指针得到一个整数, 或者用一个指针减去一个整数的到另一个指针

    在递增或递减指针时, 还需要注意. 编译器不会检查指针是否指向数组元素. C只能保证指向的数组任意元素的指针和指向数组后面第一个位置的指针有效
    但是如果递增或递减一个指针后超出了这个范围, 程序行为是为定义的. 
    另外, 可以解引用指向数组任意元素的指针. 但是即使指针指向数组后面一个位置是有效的, 也不能保证可以解引用这样的越界指针

    千万不要解引用未初始化的指针.
        如
            int * pt;
            *pt = 5;
    第二行的意思是把5存储在pt指向的位置. 但是pt未被初始化, 其值是一个随机值, 所以不知道5将存储在何处. 这会造成一些难以预料的错误.
    创建一个指针, 系统只分配了存储指针本身的内存, 并未分配存储数据的内存.
    因此在使用指针之前, 必须先用已分配的地址初始化他. 或者使用malloc()或calloc()函数指定指针内存大小

    
指针的运算例子
    指针与数组关系密切, 数组的计算机表达其实就是指针.
    对应指针pt的初值就是&array[0], 或者说array.
    与整数相加, 递增指针, 指针减去一个整数, 递减指针, 指针求差, 这些都是建立在数组上才有意义.

    指针有加减运算, 没有乘除运算, 指针的加减都是以其指向类型大小(字节)为运算长度的.
    在一定条件下, 可以对指针进行加减, 这就相当于数组中的下标运算.
    下标法 array[i]
    指针法 *(array+i)
    下标法和指针法两者是等价的. 在计算机执行中, 其实都是用指针法来处理数组的.
    如
        array + 2 == &array[2];   // 相同的地址
        *(array+2) == array[2];   // 相同的值

    如果指针变量pt已经指向数组中的一个元素, 则pt+1指向该数组中的下一个元素, pt-1指向该数组中的上一个元素
    数组的加不是简单的将地址加上指定整数, 而是将加上对应指定整数倍数的存储单元, 而这个存储单元大小是由类型决定的

    如果指针变量pt1和pt2都指向同一个数组中的元素, 则pt1-pt2, 结果是该两元素所在地址的差值除以数组类型大小的字节数, 表明其间差多少个元素

    在使用中, 如果指针指向一个数组, 那么会常常和自增或自减一起使用
        *pt_array++;
        *pt_array--;
    解引用运算符*和自增减运算符优先级一样, 作为一元运算符, 其结合律从右到左.
    也就使pt_array先与在右边的自增或自减相结合, 但由于是后缀形式的自增减, 所以会在序列点后起效.
    那么之后会与解引用相结合, 得出其指向的地址的值.
    在语句结束时, pt_array再完成自增减.
    注意
        自增减要在数组范围内
        只能使用指针, 而不能使用数组进行自增和自减, 数组名虽然表达的是首地址, 但是其还是分配了指定大小的内存块, 不能将其作为完全的指针操作.

    若使用前缀模式
        *++pt_array;
        *--pt_array;
    根据从右到左的结合律, pt_array先和自增或自减结合, 并运算, 然后在解引用.