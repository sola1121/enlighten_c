1. 断言库 assert.h
    assert.h头文件支持的断言库是一个用于辅助调试程序的小型库.
    他由assert()宏函数组成, 接受一个整型表达式作为参数.
    在编译好程序并运行时, 如果表达式求值为假(非零), assert()宏就在标准错误流stderr中写入一条错误信息, 并调用abort()函数终止程序. (abort()函数的原型在stdlib.h头文件中).
    assert()宏函数是为了标志出程序中某些条件为真的关键位置, 如果其中的一个条件为假, 就用assert()语句终止程序.
    通常, assert()的参数是一个条件表达式或逻辑表达式.
    如果assert()中止了程序, 他首先会显示失败的测试, 包含测试的文件名和行号.

    示例
        assert(x > 0);
        assert(a + b == 32);

    具体错误提示因编译器而异.
    当没有满足所给参数的条件, 运行时就会报错.

    同样, 可以使用条件语句实现相同的结果
        if (x < 0){
            printf("文件 %s, 错误行 %d\n", __FILE__, __LINE__);
            abort();
        }
        if (a+b!=32){
            printf("文件 %s, 错误行 %d\n", __FILE__, __LINE__);
            abort();
        }
    但是, 使用assert()具有能自动标识文件和出问题的行号, 还可以无需更改代码就能开启或关闭assert()机制.
    如果认为排除了程序的bug, 就可以把下面宏定义写在包含assert.h的位置前面
        # define NDEBUG
    并重新编译程序, 这样编译器就会禁用文件中的所有assert()语句. 
    如果程序又出现问题, 可以移除这条指令, 然后重新编译程序, 这样就重新启用了assert()语句.


2. 断言声明 _Static_assert
    对比于标准库assert.h头文件中定义的宏函数assert(), assert()是在运行时进行检查.
    _Static_assert声明, 在编译时检查assert()表达式.
    因此, assert()会导致正在运行的程序中止, 而_Static_assert()会导致程序无法通过编译.

    _Static_assert()接受两个参数.
    第一个参数是整型常量表达式, 第二个参数是一个字符串.
    如果第一个表达式求值为0(或_False), 编译器会显示字符串, 而且不编译该程序.

    (1) 使用例子
        # include "stdio.h"
        # include "limits.h"

        // CHAR_BIT 应为 8
        _Static_assert(CHAR_BIT == 16, "16-bit 字符被错误声明.");   // 在编译时表达式将会被检查

        int main(){
            puts("char 是16bits的.");
            return 0;
        }

        _Static_assert()被视为声明, 因此, 他可以出现在函数中, 或者在这种情况下出现在函数的外部.

        _Static_assert(整型常量表达式, 当不满足出现的提示字符串)
        第一个参数在编译期求值, sizeof表达式被视为整型常量.
        对比assert(), assert()在运行时才求值所给表达式, 而_Static_assert()在编译时就对表达式求值.