为了提高表示数据的能力, 结构可以让程序员创建新的数据形式.

结构需要结构布局告诉编译器程序员将如何组织数据
通过定义一个结构变量来让编译器为这些数据分配空间


结构声明 structure declaration
    描述了一个结构的组织布局

    使用关键字struct声明一个结构, 在其后的是一个可选标记.
        struct 标记名 {
            类型 变量1;
            类型 变量2;
            ...
        };
    如
        struct book {
            char ISBN[32];
            char title[512];
            char author[128];
            struct publish * publisher;
            float price;
        };

    在结构声明中, 用一对花括号括起来的是结构成员列表. 
    每个成员都用自己的声明来描述. 成员可以是任意一种C的数据类型, 包括结构本身.
    右花括号后面的分号是声明所必需的.

    如果把结构声明置于一个函数的内部, 他的标记就只限于函数内部使用. 
    如果把结构声明置于函数的外部, 那么该声明之后的所有函数都能使用他的标记.

    结构的标记名是可选择的.


定义结构变量 structure variable
    定义一个结构变量, 编译器将会使用指定的结构模板为对应变量分配空间.
        struct 标记名 变量名;
    如
        struct book library;
    将分配32 + 512 + 128 + sizeof(struct publish*) + sizeof(float)个字节

    也可以使用结构声明多个结构变量
        struct 标记名 变量1, 变量2, ...;
    
    相当于book结构声明创建了一个名为struct book的新类型

    声明结构的过程和定义结构变量的过程可以组合成一个步骤
        struct publish {
            char name[512];
            char address[512];
            char email[128];
            char phone[32];
        } publisher;

    组合后的结构声明和结构变量定义不需要使用结构标记
        struct {   // 无结构标记名
            char name[512];
            char address[512];
            char email[128];
            char phone[32];
        } publisher;
    
    如果打算多次使用结构模板, 还是选择带有标记名的结构形式.
    或者也可以使用typedef重新定义类型名, 用以声明定义变量.


初始化结构变量
    与初始化数组的语法类似, 使用在一对花括号中括起来的初始化列表进行初始化, 各初始化项用逗号隔开.
        struct book library = {
            "978-7-115-52163-7",
            "C Primer Plus",
            "Stephen Prata",
            &publisher,
            108.0
        };
    
    注意
        如果初始化静态存储期的变量(如, 静态外部链接, 静态内部链接, 静态无链接), 必须使用常量值.
        对于结构变量, 则是初始化列表中的值必须是常量表达式.
        所以在这里为book.publisher赋值&publisher不能在静态变量中使用.
    

结构初始化器
    C99和C11为结构提供了指定初始化器(designated initializer), 或者称为标记化结构初始化语法. 其语法与数组的指定初始化器类似.
        int nums[5] = {[2]=3, 4, [4]=6};   // int [5] = {0, 0, 3, 4, 6}
    结构的指定初始化器使用点运算符和成员名, 不是数组的方括号与下标, 来标识特定的元素.
        struct book library = {
            .price=108.0
            .publisher=&publisher;
        };
    可以按照任意顺序使用指定初始化器
    与数组类似的, 在指定初始化器后面的普通初始化, 为前面那一个被指定的成员或后面的成员提供初始值.


访问结构变量成员
    使用结构成员运算符 点"." 访问结构中的成员.
    点.运算符优先级为1, 与圆括号(), 下标运算符[]同级为最高级, 运算顺序从左到右
    在结构变量名后面加一个点运算符, 再在点运算符后面写上成员名
    如
        library.title;   // char [512];类型 
        library.price == 108.0;   // float类型
    每个成员的类型还是其在结构中声明时的类型.


结构数组
    声明结构数组
        声明结构数组和声明其他类型的数组类似.
            struct book library[10];   // 包含10个struct book类型变量的数组
    

    初始化结构数组
        对应数组的初始化, 可以在声明时一并初始化, 也可以在声明后使用下标挨个元素初始化
            struct book library[2] = {
                {"978-7-115-52163-7",
                 "C Primer Plus"},
                {"978-7-111-61793-5",
                 "C程序设计语言"},
            };

        
    标识结构数组成员
        首先应该先明确要访问数组中哪一个元素, 即哪一个结构变量
        用数组表示法需要使用方括号加范围内整数指明
        然后再使用点运算符配合要访问的成员名访问该结构变量对应的成员
            library[2].title;   // 数组中第三个结构的title成员, 是一个字符串
            library[0].price;   // 数组中第一个结构的price成员, 是一个float值
            library[3].ISBN[3];   // 数组中第四个结构的ISBN成员, 是一个字符串, 然后又对该字符串使用下标运算取了一个字符, 这就是char 字符


嵌套结构
    在结构中可以包含结构
    如
        struct data {
            int id;
            char describe[256];
            time_t time_clock;
        };

        struct list {
            size_t count;
            struct data data;   // 包含一个struct data 变量
            struct list * next;   // 包含一个指向自己类型的指针变量
        };

    初始化嵌套结构
        struct list head = {
            .count = 0,
            {.id=20, "data 20", time(NULL)},   // 初始化嵌套的struct data变量
            NULL   // 初始化指向自己类型的指针变量
        };

        运用了指定初始化器, 当然也可以对应位置依次初始化


结构的相互赋值
    不同于数组, 数组名是一个指针常量, 或者说是一个不可修改的左值, 所以不能用来互相赋值
    但是结构变量可以相互赋值


匿名结构
    匿名结构是一个没有名称的结构成员. 是C11标准的.

    可以在一个嵌套结构中使用一个匿名结构做成员
        struct person {
            int id;
            struct {char first_name[32], char last_name[32]}   // 匿名结构做成员
        };
    声明并初始化一个struct person变量
        struct person ted = {23, {"Ted", "Grass"}};
    

--------------------------------------------------------------

结构的复合字面量
    C99复合字面量可以用于数组和结构. 如果只需要一个临时结构值, 就很合适.
    语法是将结构类型名放在圆括号中, 后面紧跟一个用花括号括起来的初始化列表.
        (struct 标记名) {成员1的值, 成员2的值, ...}
    要取其地址为指针赋值, 只需要在圆括号前使用&取地址运算符
    
    如果函数接受一个结构变量, 可以把复合字面量作为实际参数传递
        void show_info(const struct data);
        传入复合字面量
        show_info((struct data){clock(), "数据内容"});

    如果函数结构一个结构指针变量, 可以把复合字面量的地址作为参数传递
        void show_info(const struct data *);
        传入复合字面量的地址
        show_info(&(struct data){clock(), "数据内容"});


--------------------------------------------------------------

伸缩型数组成员 flexible array member
    C99伸缩型数组成员指的是在结构的最后一个成员使用 类型名 成员名[] 来声明.
    看上去是一个没有定义长度的数组, 但其具有一些特性
        该数组不会立即存在
        使用伸缩型数组成员可以编写合适的代码, 就好像他确实存在并具有所需数目的元素一样.
    
    声明一个绳索性数组成员
        伸缩性数组成员必须是结构成员的最后一个
        结构中必须至少有一个成员
        伸缩型数组的声明类似与普通数组, 只是他方括号中是空的

        struct flex{
            int count;
            float scores[];   // 伸缩型数组成员
        };
    
    使用具有伸缩型数组成员的结构
        当声明完一个具有伸缩型数组成员的结构变量时, 并不能使用其中的伸缩型成员, 因为没有给这个数组预留存存储空间.
        当声明一个指向具有伸缩型数组成员的结构指针的时, 同时使用动态内存分配函数如malloc为该指针充分分配内存, 其他成员将一部分内存使用了, 剩下的就全是伸缩型数组成员的了.

        struct flex * pt = malloc(sizeof(struct flex)+sizeof(float*6));
        等同于
        struct flex * pt = malloc(sizeof(int)+sizeof(float)*6);   // 分配可以存储一个int和6个float的空间
        
        pt->count = 1;
        对于伸缩型数组成员, 可以像普通数组一样引用他们
        pt->scores[0] = 8.8;
        pt->scores[1] = 9.0;
        ...
        pt->scores[5] = 7.8;
    
    具有伸缩型数组成员的结构变量的特殊处理
        不能用结构进行赋值或拷贝
        如
            *pt1 = *pt2;   // 普通结构变量指针可以, 但是对于具有伸缩型数组成员的不行
        如果确实需要拷贝, 需要使用string.h中声明的memcpy()从内存进行

        不要以按值方式把这种结构传递给结构. 按值传递一个参数与赋值类似. 要把结构的地址传递给函数.

        不要使用带伸缩型数组成员的结构作为数组成员或另一个结构的成员.
        

--------------------------------------------------------------

结构的应用
    结构可以使用二进制模式通过fread, fwrite进行文件读写.

    由于结构可以存储不同类型的信息, 所以他是构建数据库的重要工具.
    数据库文件可以包含任意数量的结构. 存储在一个结构中的整套信息被称为记录record, 单独的项被称为字段field.

    结构还可以用来创建链式的结构, 可以看作新的数据形式. 这些形式包括队列, 二叉树, 堆, 哈希表, 图表.
    许多这样的形式都是链式结构(linked structure).
    每个结构都包含一两个数据项和一两个指向其他同类结构的指针. 
    这些指针把一个结构和另一个结构链接起来, 并提供一种路径能遍历整个彼此链接的结构
