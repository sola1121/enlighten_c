字符串的输入与输出
    如果想把一个字符串读入程序, 首先必须预留存储该字符串的空间, 然后用输入函数获取该字符串.


分配空间
    为了存储字符串, 首先需要为其分配足够的存储空间.
    计算机不能在读取字符串的时候同时计算他的长度, 然后分配空间, 这需要程序员来手动分配.
    错误写法
        char * name;   // name就是一个char指针, 只能存储现存的地址, 不能用来赋值字符串
        scanf("%s", name);
    编译可能会通过, 也可能会给出警告, 但是在读入name时, name可能会擦写掉程序中的数据或代码, 从而导致程序异常中止.
    因为scanf()要把信息拷贝到参数指定的地址上, 而此时该参数是个未初始化的指针, name可能会指向任何地方.

    最简单的空间分配-显式的指明数组的大小.
        char name[16];
    
    使用malloc()进行空间分配
        char * name = (char *) malloc(sizeof(char) * 16);


格式化输入和输出
    格式化输入
        int scanf ( const char * format, ... );
    在读取字符串时候, 使用scanf("%s", array); 向array数组写入字符串.
    但是%s只能读取一个单词, 即遇到空白字符会结束读取.

    格式化输出
        int printf ( const char * format, ... );
    在输出字符串的时候, 使用printf("%s", array); 从array数组读出字符串.


单个字符输入和输出
    必须配合循环和字符数组
    获取一个字符
        int getchar()

    输出一个字符
        int putchar(int c);

    例  
        int i = 0;
        char words[10];
        for (i=0; i<10 && words[i]!='\n'; i++){
            words[i] = getchar();
        }
        words[10] = '\0';

        i = 0;
        while(words[i]!='\0'){
            putchar(words[i]);
            i++;
        }

    例  
        char * get_str(char * str, size_t len){
        size_t i = 0;
        
        for(; i<len && (str[i]=getchar()) && str[i]!='\n'; i++);
        str[i] = '\0';

        while (getchar()!='\n')
            continue;

        return str;
    }


    int put_str(const char * str){
        int count = 0;
        while (*str){   // 空字符的数值是0, 在用于表达式判断的时候就是false, 循环将会停止
            putchar(*str++);
            count ++;
        }
        putchar('\n');

        return count;
    }


行输入和输出行
    C stdio.h标准库中定义的行输入
        char * gets ( char * str );
    注意
        这个是有缺陷的, 因为该函数只有一个参数, 其无法检查数组是否装得下输入行.
        即该函数只知道数组的开始处, 不知道数组中有多少个元素.
        这都是C相信程序员的思想作祟. C99标准建议不要使用他. C11标准直接废除了他.
        但是在编译器中, 为了能兼容以前的代码, 可能还是会有该函数存在.
    其从标准输入读取整行输入, 直至遇到换行符, 然后丢弃换行符, 存储其余字符, 并在这些字符的末尾添加一个空字符使其成 为一个C字符串.
    成功时返回字符串地址, 读到文件尾会返回空指针. 对空指针求值为0.
    例
        char words[12];
        gets(words);
    整行输入, 除了换行符, 都被存储在words中.
    
    如果输入字符串过长超过字符数组可存储长度, 会导致缓冲区溢出(buffer overflow), 即多余的字符超出了指定的目标空间.
    如果这些多余的字符只是占用了尚未使用的内存, 就不会出现问题.
    如果这些多余的字符擦写掉程序还总其他数组, 会导致程序的异常中止.
    比如运行时"Segmentation fault", 分段错误. 在Linux/Unix系统中, 说明该程序试图访问未分配的内存.
    或者还有其他想不到的状况发生.


    C stdio.h标准中定义的行输入
    为了代替不安全的gets(), C11标准新增了gets_s()函数
        char * gets_s( char * str, size_t n );
    第一个参数str是将要存储的字符数组地址, 第二个参数指明最多读入的字符数.
    其从标准输入读取整行输入, 直至遇到换行符, 然后丢弃换行符, 存储其余字符, 并在这些字符的末尾添加一个空字符使其成为一个C字符串
    若读到最大字符数都没有读到换行符. 
        首先会把目标数组中的首字符设置为空字符, 读取并丢弃随后的输入直至读到换行符或文件结尾, 然后返回空指针.
        接着, 调用依赖实现的"处理函数"(或程序员选择的其他函数), 可能会中止或退出程序.
    成功时返回字符串地址, 失败返回NULL
    例
        char words[12];
        gets_s(words, 11);
    注意
        其只将n-1个字符写入字符数组中
        在某些编译器中可能不支持该函数


    C stdio.h标准库中定义的行输出
        int puts ( const char * str );
    输出指定地址的字符串.
    fputs()在遇到空字符时就停止输出, 所以必须确保有空字符.
    puts()只显示字符串, 而且自动在显示的字符串末尾加上换行符.    
    注意
        如果没有所想输出的字符们末尾没有空字符\0, 即不是字符串
        puts()会一直向后输出, 直到遇到一个空字符
    例
        puts(words);   // 和 printf("%s\n", words); 效果一样
    因为双引号括起来的内容是字符串字面量, 且被视为该字符串的地址. 另外存储字符串的数组名也被看作是地址
    可以如下调用输出字符串
        puts(words+2);   // 将从第三个字符开始输出, 直到\0


文件流输入和输出
    可以使用处理文件的输入和输出来处理程序运行时字符串的输入和输出.
    只需要将文件流地址设置为stdin或stdout,stderr来获取输入或打印输出.

    C stdio.h标准库文件流输入
        char * fgets ( char * str, int num, FILE * stream );
    第一个参数是用以存储的字符数组地址, 第二个参数指明了读入字符的最大数量, 第三个参数指明要读入的文件.
    如果读入字符最大数量为n, 那么fgets将读入n-1个字符, 或者读到遇到第一个换行符位置. 并在末尾添加一个空字符使其成为C字符串.
    如果fgets读入到一个换行符, 其会将换行符存储到字符串中, 因为如果处理文件内容, 任何一个字符都是不能丢的.
    成功则返回字符串存储地址. 但是如果函数读到文件结尾, 他将返回空指针. 以保证不会指向有效数据. 在代码中用0代替.
    注意
        系统使用缓冲的I/O. 这意味着用户在使用Enter键之前, 输入都被存储在临时存储区(缓冲区).
        在按下Enter键就在输入中增加一个换行符, 并把整个输入发送给fegets().
        所以stdin中的字符串一定是带有一个换行符的, 如果输入字符个数合适, 那么fgets一定可以从stdin流中拿到一个换行符. 其内容可能总是会存有一个换行符.
    例
        char words[10];
        while( fgets(words, 10, stdin) != NULL && words[0] != '\n')   // 读取非空白行
            fputs(words, stdout);
        输入
            hello, world.
        输出
            hello, world.
    fgets()首先读取输入的前9个字符:hello, wo, 作为"hello, wo\0"存储
    接着fputs()打印该字符串, 因为fgets()没有保存换行符, 所以没有换行, 根据结尾的空字符缓冲区的内容被发送至屏幕上.
    然后进行下一个while迭代.
    fgets()继续从缓冲区中读取:rld.\n, 因为有一个换行符, 所以完成读取, 将会作为"rld.\n\0"存储
    接着fputs()打印该字符串, 这里fgets()保存了换行符, 当遇上换行符时, 光标会移动到下一行, 根据最后的空字符缓冲区的内容被发送至屏幕上.


    C stdio.h标准库文件流输出
        int fputs ( const char * str, FILE * stream );
    第二个参数指明要写入数据的文件.
    fputs()向指定文件流输出指定的内容, 不会做任何添加, 传入的是什么就输出什么.
    注意
        系统使用缓冲的I/O. 对于fgets()从stdin中获取的字符串, 末尾可能总是会有一个换行符, 然后才是添加的结尾标记空字符\0.
        fputs()把字符发送到输入流中, 当发送换行符时, 会将内容换行, 然后遇到紧跟在后面的空字符\0, 缓冲区中的内容被发送至屏幕上.
        可见, fputs()所输出的换行符其实来自fgets()保存的换行符号.


    处理换行符
        如果在保留内容的时候, 不想要fgets()保存下来的换行符, 可以像下面这样做
            while (words[i] != '\n')
                i++;
            words[i] = '\0';
        找到换行符所在位置, 将其替换为空字符


    使用例子
        # define STRSIZE 32
        char words[STRSIZE];
        int i;
        while ( fgets(words, STRSIZE, stdin)!=NULL && words[0]!='\n' )   // 读取非空白行
        {
            i = 0;
            while (words[i]!='\n' && words[i]!='\0')   // 找到换行符和空字符所在位置
                i++;
            if (words[i] == '\n')   // 该位置如果是换行符
                words[i] = '\0';   //把换行符替换为空字符
            else                  // 该位值不是换行符, 而是空字符
                while ( getchar()!='\n' )   // 清除输入流中剩下的字符
                    continue;
            
            puts(words);
        }


--------------------------------------------------------------

空字符和空指针
    空字符 '\0' 是用于标记C字符串末尾的字符, 其对应字符编码是0. 由于其他字符的编码不可能是0, 所以空字符不可能是字符串的一部分.

    空指针 NULL, 在C标准库 saddef.h中定义为 #define NULL ((void *)0)
    可以看作有一个值, 该值不会与任何数据的有效地址对应. 
    通常函数使用他返回一个有效地址表示某些特殊情况发生. 例如遇到文件结尾或未能按预期执行.

    空字符是整数类型, 而空指针是指针类型.
    两者容易混淆的原因是, 他们都可以用数值0来表示.
    但是从概念上看, 两者是不同类型的0.
    另外, 空字符是最简单的字符串, 占一个字节; 空指针是一个地址, 通常占4个或8个字节.
