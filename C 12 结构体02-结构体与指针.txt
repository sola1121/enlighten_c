示例
    struct data {
        clock_t time_clock;
        char describe[256];
    };

    struct list {
        size_t count;
        struct data data;
    };

    list的对象将会至少占用 size_t的8个字节, struct data中clock_t的8个字节, describe的256个字节, 共272个字节


指向结构的指针

    针对以上示例, 就像使用数组的指针比数组本身更容易操控一样, 指向结构的指针通常比结构本身更容易操控
    使用指针在传递数据的时候更有效率
    一些用于表示数据的结构中包含指向其他结构的指针


    声明和初始化结构指针
        声明结构的指针与其他类型的指针声明一样
            struct list * pt;   // 指向结构的指针
        声明并没有创建一个新结构, 但是指针pt可以指向任意现有的struct list结构变量
            struct list value;
            pt = &value;
        与数组不同, 结构变量名并不是结构变量的地址, 而是与普通变量一样, 因此要在结构变量名前面加上&取地址运算符.


    用指针访问结构成员
        struct list value;   // 普通的结构变量
        struct list * pt = &value;   // 指向value的指针
        对于普通的结构变量, 可以使用点.运算符访问成员(优先级1, 从左到右运算)
        如
            value.count;
        使用指向结构变量的指针, 可以先使用*解引用运算符(优先级2, 从右到左运算, 单目运算), 再使用点.运算符访问成员
        注意运算符优先级, *解引用得使用圆括号括起来
        如
            (*pt).count;
        针对于结构指针, 还可以使用->运算符访问成员(优先级1, 从左到右运算)
        如  
            pt->count;
        以上三种方式都是访问value的count成员, 其类型都是size_t


结构中的字符数组和字符指针
    如
        struct d1 {
            char array[32];   // 字符数组, 用来存储字符串
        } d1;

        struct d2 {
            char * point;   // 字符指针, 用来指向一个已存在的字符数组或字符串
        } d2;

    可以
        d1 = {"d1的数据"};
        d2 = {"d2的数据"};
    上面这两者都能正常运行
    d1的数据将会被存储在其内部的字符数组中, 会为其分配32个字节
    d2的只分配了8个字节用以保存地址(只创建了指针变量), 而地址所在, 即其指向的数据存储在编译器存储常量的地方, 对应程序运行时为所有字面常量所分配的空间.

    但是
        scanf("%s", d1.array);
        scanf("%s", d2.point);   // 这时可能会出问题
    当使用scanf()输入来存储数据, d1.array为字符数组, 会为其分配空间并用来存储输入的数据
    但是d2.point, 只分配了一个指针的大小, 通常8个字节, 是用来存储已有数据的地址的, 而新输入的内容不知道往哪里存储, 走运的话能运行, 但是终归还是会出错


结构, 指针, 动态内存分配malloc()函数
    对于结构成员是指针, 在没有可以指向的内存快时, 可以使用动态内存分配函数, 如malloc 
    先创建一块对应内存, 在使用该成员指向该内存, 即将新建的内存地址交给指针类型成员, 然后在对该地址内容进行赋值等操作
    如
        struct data {
            clock_t time_clock;
            char * describe;
        } data;
   
        data.time_clock = clock();
        data.describe = (char *) malloc(255+1);   // 让结构中成员指针先指向一块新分配的内存
        strcpy(data.describe, temp);   // 然后在对该内存的内容进行赋值
    这样可以灵活的分配空间, 比如配合strlen(), 分配新内存时使用(char *) malloc(strlen(temp)+1), 创建与将要保存的字符串相适应的大小

    因为字符串是使用的malloc()函数分配的空间, 所以应该使用free()进行释放
    在使用最后
        free(data.describe);
