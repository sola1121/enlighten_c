递归 recursion
    C允许函数自己调用自己, 这种行为就叫做递归

    如何结束递归是使用递归的难点, 因为如果递归代码中没有终止递归的条件测试部分, 一个调用自己的函数会无限递归

    可以使用循环的地方通常都可以使用递归. 有时用循环解决问题比较好, 但有时用递归更好. 递归的方案更简洁, 但效率却没有循环高

    递归的优缺点
        优点是递归为某些编程问题提供了最简单的解决方案.
        缺点是一些递归算法会快速消耗计算机的内存资源. 另外递归还不方便阅读与维护.

    例子
        void up_and_down(int n){
            printf("%d - %p\n", n, &n);   // 前置打印, 将在进入每级递归前, 调用
            if (n < 4)
                up_and_down(n+1);
            printf("%d - %p\n", n, &n);   // 后置打印, 将在递归转回控制的时候, 调用
        }

        int main(){
            up_and_down(1);
            return 0;
        }

        从参数层面来看递归
            首先, main()调用了带参数1的up_and_down()函数, (第1级), up_and_down(1)调用打印, 并判断
            判断为真, 第1级接着调用带参数2的自身, 记(第2级), up_and_down(2)调用前置打印, 并判断, if (2<3)
            判断为真, 第2级接着调用带参数3的自身, 记(第3级), up_and_down(3)调用前置打印, 并判断, if (3<4)
            判断为真, 第3级接着调用带参数4的自身, 记(第4级), up_and_down(4)调用前置打印, 并判断, if (4<4)
            判断为假, 第4级跳过条件语句, 调用其后置打印, 其中的参数为4 完成后结束自身, 进入到第3级
            第3级执行完剩下的条件语句, 调用其后置打印, 其中的参数为3, 完成后结束自身, 进入到第2级
            第2极执行完剩下的条件语句, 调用其后置打印, 其中的参数为2, 完成后结束自身, 进入到第1极
            第1级执行完剩下的条件语句, 调用其后置打印, 其中的参数为1, 完成后结束自身

        从执行层面来看递归
            可以假设有一条函数回溯调用链, func1()调用func2(), func2()调用func3(), func3()调用func4().
            当func4()结束时, 控制传回func3(), 当func3()结束时, 控制传回func2(), 当func2()结束时, 控制传回func1().
            递归的情况与此类似, 只不过func1(), func2(), func3(), func4()都是相同的函数.

        从例子层面看递归
            在一栋楼内, 每层楼都有一块积木, 你要从楼底到楼上, 挨个去捡积木并拼装, 直到捡到某个特定积木, 然后下楼返回底楼, 此时拼装好的成品就可以出货了.    


递归原理
    每级函数调用都有自己的变量
    每次函数调用都会返回一次. 当函数执行完毕后, 控制权将被传回上一级递归. 程序必须按顺序逐级返回递归.
    递归函数中位于递归调用之前的语句, 均按被调函数的顺序执行.
    递归函数中位于递归调用之后的语句, 均按被调函数相反的顺序执行.
    虽然每级递归都有自己的变量, 但是并没有拷贝函数的代码. 程序按顺序执行函数中的代码, 而递归调用就相当于又从头开始执行函数的代码.
    递归函数必须包含能让递归调用停止的语句. 通常函数使用if或其他等价的测试条件在函数形参等于某特定值时终止递归. 为此, 每次递归调用的形参都要使用不同的值.


尾递归 tail recursion
    尾递归是最简单的递归形式, 其是将递归操作置于函数的末尾, 即正好在return语句之前, 就不需要再进行任何运算工作了, 其就相当于循环do while.


双递归
    函数每一级递归都要调用函数本身两次.

    计算斐波那契数列, 第一个和第二个数都是1, 后续的每个数都是其前两个数之和
    如 1, 1, 2, 3, 5, 8, 13
    unsigned long long fibonacci(unsigned int num) {
        if (num > 2)
            return fibonacci(num-1) + fibonacci(num-2);
        else
            return 1;
    }


递归和倒序计算
    递归在处理倒序时非常方便, 甚至比循环简单.

    如编写一个函数, 打印一个整数的二进制.
    思路:
        用二进制表示5, 奇数的末尾一定是1, 偶数的末尾一定是0, 所以通过5%2即可确定5的二进制数的最后一位是1还是0.
        一般而言, 对数字n, 其二进制的最后一位是n%2. 因此计算第一位数字实际上是待输出二进制数的最后一位.
        使用递归, 在递归函数之前计算n%2, 在递归之后打印结果, 这样, 计算的第一个值正好使最后一个打印的值.
        是一个前置递归, 即将递归写在得出结果之前, 这样得出结果就是倒着来的

    void to_binary(unsigned long num) {
        int res;
        res = num%2;

        if (num>=2)
            to_binary(num/2);
        
        putchar(res==0 ? '0' : '1');
        return;
    }
