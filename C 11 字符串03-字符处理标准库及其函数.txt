C 提供了多个处理字符串的函数, ANSI C把这些函数的原型放在string.h头文件中

常用字符串操作

    获取字符串长度
        size_t strlen(const char *);
            返回一个字符串的长度, 不包括空字符


    拼接字符串
        char *strcat(char *dest, const char *src);
            把src指向的字符串拷贝至dest指向的字符串末尾. src字符串的第一个字符将覆盖dest字符串末尾的空字符.
            返回dest的值
        注意
            strcat()函数无法检查第一个字符数组是否能容纳第二个字符串. 如果分配给第一个数组的空间不够大, 多出来的字符溢出到相邻存储单元时就会出问题.
            要给拼接后的字符串长度加1才够空间存放末尾的空字符.

        char *strncat(char *dest, const char *src, size_t n);
            把src字符串中的n个字符拷贝至dest字符串末尾. src字符串的第一个字符将覆盖dest字符串末尾的空字符.
            不会拷贝src字符串中空字符和其后的字符, 并在拷贝字符的末尾添加一个空字符.
            返回dest的值
        strcat不能检查目标空间是否能容纳源字符串的副本, 使用strncat可以避免这样的问题.
        可以配合strlen()函数来计算字符串的长度, 应注意一定要留一个空字符的位置.


    比较字符串
        如果直接使用字符数组进行比较, 如 array_string1 == array_string2, 实际上是两个指针的比较, 比较的是这两个指针变量的值是否是同一地址.
        所以这里就需要字符串比较函数来比较两个字符串的内容.
        int strcmp(const char * str1, const char * str2);	
            基于字典顺序比较两个字符串
            如果两个字符串相同, 返回0
            当比较str1与str2相同下标位置的字符, 如果str1的字符在str2的字符前面, 则返回负数, 如果str1的字符在str2的字符后面, 则返回正数.
        补充:
            在前面还是在后面是根据字符码编码值决定的, 一般的为ASCII标准字符码, 其实就是机器排序序列(machine collating sequence), 是按照ASCII标准来的.
            而这个负数一般为-1或者str1[i]-str2[i], 正数为1或者str1[i]-str2[i], 因为-1和1非零, 作为判断表达式的时候为true, if (strcmp(str1, str2)) 如果不等就是真.

        int strncmp(const char * str1, const char * str2, size_t n);
            基于字典顺序比较两个字符串, 最多比较n个字节
            在比较n个字符后或遇到第一个空字符时停止比较

        不同长度的字符串比较
            当比较到某个字符串的结尾的时候, 末尾的后一位是空字符\0, 空字符在ASCII字码最前为0
            所以该字符一定比对位的小, 函数将返回负值.


    深拷贝字符串
        如果pt1和pt2都是指向字符串的指针, pt2=pt1; 代表的就是将pt1指向的地址赋值给pt2, 没有拷贝内容的本身, 属于浅拷贝
        如果希望拷贝整个字符串, 需要用到深拷贝.
    
        char *strcpy(char* str1, const char* str2);
            把str2指向的字符串(包括空字符)拷贝至str1指向的位置
            返回str1的值
        注意
            第一个参数和第二个参数都不必指向数组的开始, 因此可以
                strcpy(words, array+5);
                strcpy(words+2, array);

        char *strncpy(char* str1, const char* str2, size_t n);
            把str2指向的字符串拷贝至str1指向的位置, 拷贝字符数不超过n, 相当于截取str2的n个字符拷贝给str1
            该函数不会拷贝空字符后面的字符
            如果源字符串的字符少于n个, 目标字符串就以拷贝空字符结尾
            如果源字符串有n个或超过n个字符, 就不拷贝空字符
            返回str1的值
        strcpy不能检查目标空间能否容纳源字符串的副本, 使用strncpy可以避免这样的问题.
        可以配合strlen来计算目标数组的长度, 记得一定要为空字符多留一位.


        用于字符串赋值
            char words[10];
            strcpy(words, "hello");
            strcpy(words, (char [10]){'h', 'e', 'l', 'l', 'o', '\0'});
            strcpy(words, "使用字符串字面量可以存储中文.");
            strncpy(words, "hello, world.", 5);

            memset(words, 0, 10);   // 将字符数组起始位置到结束重置为0, 即空字符


    查找字符串中的字符
        char *strchr(const char * str, int ch);
            如果str字符串中包含ch字符, 返回指向str字符串首次初次出现的ch字符的指针(末尾的空字符也是字符串的一部分, 所以在查找范围内)
            如果在str字符串中未找到ch字符, 则返回空指针NULL

        char *strrchr(const char *str, int ch);
            从字符串str尾(右边)开始查找字符ch首次出现的位置(末尾的空字符也是字符串的一部分, 所以在查找范围内)
            如果在str字符串中未找到ch字符, 则返回空指针NULL


    查找字符串中的字符串
        char *strpbrk(const char *str, const char *breakset);	
            strpbrk为string pointer break缩写. 
            在字符串str中查找breakset中任意字符第一次出现的位置的指针值. 如果有返回str1的值.
            如果在str字符串中未找到任何breakset字符串中的字符, 则返回空字符'\0'
            通常, breakset是分隔符的集合. 不支持多字节字符集.

        char *strstr(const char *haystack, const char *needle);	
            在字符串haystack中查找字符串needle第一次出现的位置, 返回该位置的指针, heystack的长度必须长于needle
            没有在haystack中找到needle, 则返回空指针NULL


    补充

        void *memcpy(void *dest, const void *src, size_t n);
            将n字节长的内容从一个内存地址复制到另一个地址; 如果两个地址存在重叠, 则最终行为未定义

        void *memmove(void *dest, const void *src, size_t n);
            将n字节长的内容从一个内存地址复制到另一个地址; 与memcpy不同的是它可以正确作用于两个存在重叠的地址

        void *memchr(const void *s, char c, size_t n);
            在从s开始的n个字节内查找c第一次出现的地址并返回, 若未找到则返回NULL

        int memcmp(const void *s1, const void *s2, size_t n);
            对从两个内存地址开始的n个字符进行比较

        void *memset(void *, int, size_t);	
            用某种字节内容覆写一段内存空间

        int strcoll(const char *, const char *);	
            基于当前区域设置的字符顺序比较两个字符串

        char *strerror(int);
            返回错误码对应的解释字符串, 参见errno.h（非线程安全函数）

        size_t strspn(const char *s, const char *strCharSet);	
            从字符串s的起始处开始, 寻找第一个不出现在strCharSet中的字符, 返回其位置索引值. 
            换句话说, 返回从字符串s的起始位置的完全由strCharSet中的字符构成的子串的最大长度. strspn为string span的缩写. 不支持多字节字符集. 

        size_t strcspn(const char *s, const char *strCharSet);	
            从字符串s的起始处开始, 寻找第一个出现在strCharSet中的字符, 返回其位置索引值. 
            换句话说, 返回从字符串s的起始位置的完全由不属于strCharSet中的字符构成的子串的最大长度. strcspn为string complement span的缩写. 不支持多字节字符集. 

        char *strtok(char *strToken, const char *strDelimit );	
            将一个字符串strToken依据分界符（delimiter）分隔成一系列字串. 
            此函数非线程安全, 且不可重入; 但MSVC实现时使用了thread-local static variable因而是线程安全的但仍然是不可重入, 即在单线程中不能对两个源字符串交替调用该函数来分析token, 应当对一个字符串分析完成后再处理别的字符串. 

        size_t strxfrm(char *dest, const char *src, size_t n);	
            根据当前locale转换一个字符串为strcmp使用的内部格式


--------------------------------------------------------------

在stdio.h 中的字符串处理函数

    int sprintf(char * restrict s, const char * restrict format, ...);
        把数据写入字符串, 因此该函数可以把多个元素组合成一个字符串.
        第一个参数是目标字符串的地址, 第二个参数是格式化字符串, 其他为代写入项的列表.
        如果成功, 则返回写入的字符总数, 不包括字符串追加在字符串末尾的空字符. 如果失败, 则返回一个负数.

    int sscanf(const char * restrict s, const char * restrict format, ...);
        把数据从字符串读出, 该函数根据格式化字符串读出各个数据
        第一个参数是被读取字符串的地址, 第二个参数是格式化字符串, 其他为对应项的列表.
        如果成功, 该函数返回成功匹配和赋值的个数. 如果到达文件末尾或发生读错误, 则返回 EOF.


--------------------------------------------------------------

    数字既能以字符串形式存储, 又能以数值形式存储. 比如, 把数字存储为字符串就是存储数字字符.
    C要求用数值形式进行数值运算. 但是在屏幕上显示数字则要求字符串形式, 因为屏幕显示的是字符.
    在输入和输出时可以使用格式化字符串相关函数进行类型的切换, 也可以使用stdlib.h中定义的数值转换函数.

C标准库 stdlib.h
    stdlib.h中有定义数值转换函数, 伪随机数生成函数, 动态内存分配函数, 过程控制函数.

    数值转换函数

    double atof (const char* str);
        把字符串转换为双精度浮点数. 相当于strtod(s, (char**)NULL).

    int atoi (const char * str);  
        把字符串转换为整型. 相当于(int)strtol(s, (char**)NULL, 10).

    long int atol ( const char * str );   
        把字符串转换为长整型. Equivalente a strtol(s, (char**)NULL, 10).

    long long int atoll ( const char * str );  
        把字符串转换为长长整型. Equivalente a strtol(s, (char**)NULL, 10). 这是C99新增加的库函数. 

    double strtod (const char* str, char** endptr);  
        把字符串转换为双精度浮点数, 检查结果是否溢出, 并返回字符串不能转换部分的地址. 如果没有执行有效的转换, 则返回零.

    float strtof (const char* str, char** endptr);  
        把字符串转换为单精度浮点数, 检查结果是否溢出, 并返回字符串不能转换部分的地址. 如果没有执行有效的转换, 则返回零.

    long int strtol (const char* str, char** endptr, int base);	
        把字符串转换为长双精度浮点数, base规定其进制, 检查结果是否溢出, 并返回字符串不能转换部分的地址. 如果没有执行有效的转换, 则返回零.

    long double strtold (const char* str, char** endptr);	
        把字符串转换为长整型, 检查结果是否溢出, 并返回字符串不能转换部分的地址. 如果没有执行有效的转换, 则返回零.

    long long int strtoll (const char* str, char** endptr, int base);	
        把字符串转换为long long int, base规定其进制, 检查结果是否溢出, 并返回字符串不能转换部分的地址. 如果没有执行有效的转换, 则返回零.

    unsigned long int strtoul (const char* str, char** endptr, int base);	
        把字符串转换为无符号长整形, base规定其进制, 检查结果是否溢出, 并返回字符串不能转换部分的地址. 如果没有执行有效的转换, 则返回零.

    unsigned long long int strtoull (const char* str, char** endptr, int base);	
        把字符串转换为unsigned long long int, base规定其进制, 检查结果是否溢出, 并返回字符串不能转换部分的地址. 如果没有执行有效的转换, 则返回零.

    注意
        对于可以转换的进制, 函数最多可以转换36进制, 'a'~'z'字符都可用作数字.

    例
        int i;
        char buffer[256];
        printf ("输入一个数字字符: ");
        fgets (buffer, 256, stdin);
        i = atoi (buffer);
        printf ("\n所输入的数字为: %d. 其两倍为: %d.\n", i, i*2);

        char str[30] = "20.30300 字符部分";
        char *ptr;
        double ret;
        ret = strtod(str, &ptr);
        printf("数字(double)是 %lf\n", ret);
        printf("字符串部分是 |%s|", ptr);


    多字节字符/宽字符转换

    int mblen (const char* pmb, size_t max);
        计算多字节字符的长度并确定是否为有效字符 .

    int mbtowc (wchar_t* pwc, const char* pmb, size_t max);
        多字节字符转换为宽字符.

    int wctomb (char* pmb, wchar_t wc);
        宽字符转换为多字节字符.


    多字节字符串/宽字符串转换

    size_t mbstowcs (wchar_t* dest, const char* src, size_t max);
        多字节字符串转换为宽字符串.

    size_t wcstombs (char* dest, const wchar_t* src, size_t max);
        宽字符串转换为多字节字符串.


--------------------------------------------------------------

C标准库 ctype.h

    其中有一系列与字符相关的函数. 虽然这些不能处理整个字符串, 但是可以处理字符串中的字符

    如
        int islower( int ch );   判断单个字符是否为小写, 如果是则返回true, 否则返回false
        int isupper( int ch );   判断单个字符是否为大写, 如果是则返回true, 否则返回false
        int isspace( int ch );   判断单个字符是否为空白字符, 包括制表符\t, 回车符\r, 换行符\n等, 如果是则返回true, 否则返回false
        int isprint( int ch );   判断单个字符是否可以打印, 如果是则返回true, 否则返回false

        int tolower( int ch );   将单个字符转换为小写并返回
        int toupper( int ch );   将单个字符转换为大写并返回 