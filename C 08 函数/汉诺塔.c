# include "stdio.h"

/*
汉诺塔(Hanoi)游戏. 
该游戏是在一块铜板装置上, 有三根杆(编号A, B, C), 在A杆自下而上, 由大到小按顺序放置64个金盘. 

游戏的目标:
    把A杆上的金盘全部移到C杆上, 并仍保持原有顺序叠好. 

操作规则:
    每次只能移动一个盘子, 并且在移动过程中三根杆上都始终保持大盘在下, 小盘在上, 操作过程中盘子可以置于A, B, C任一杆上.

分析:
    对于这样一个问题, 任何人都不可能直接写出移动盘子的每一步, 但可以利用下面的方法来解决. 
    设移动盘子数为N, 从上到下依次为1~N, 为了将这N个盘子从A杆移动到C杆, 可以做以下三步：
        (1)以C盘为中介, 从A杆将1至N-1号盘移至B杆.
        (2)将A杆中剩下的第N号盘移至C杆.
        (3)以A杆为中介, 从B杆将1至N-1号盘移至C杆.
    
为什么这里以1至N-1为整体移动.
    因为从整体上看, 依次一个个移动, 所达到的目的就是将1至N-1个移动到缓存点B, 从A点把剩下的大的移动到C, 然后在将A做缓存点, 将1至N-2移动到A, 将B中剩下的大的移动到C.

算法求解:
    解法的基本思想是递归. 
    假设有 A, B, C 三个塔, A 塔有 N 块盘, 目标是把这些盘全部移到 C 塔. 
    那么先把 A 塔顶部的 1到N-1 块盘移动到 B 塔, 再把 A 塔剩下的大盘移到 C, 最后把 B 塔的 1~N-1 块盘移到 C. 

如此递归地使用下去, 就可以求解. 

*/



void hanoi(int n, char A, char B, char C){
    if (n==1){
        printf("%c -> %c\n", A, C);   // 递归出口, 最后一步, 完成A位置 移动到 C位置
        return;
    } else {
        hanoi(n-1, A, C, B);   // A位置 移动到 B位置
        printf("%c -> %c\n", A, C);
        hanoi(n-1, B, A, C);   // B位置 移动到 C位置
    }
}



int main(void){
    char a = 'A', b = 'B', c = 'C';
    int n = 4;

    hanoi(4, a, b, c);

    return 0;
}