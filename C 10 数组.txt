数组 array

    数组是一组数据类型相同的元素, 其中元素按顺序存储在内存中.
    C把数组看作是派生类型, 因为数组是建立在其他类型的基础之上的.
    也就是说无法简单地声明一个数组. 在声明数组时必须说明其元素的类型.
    保存的元素也可以是数组类型, 在这种情况下, 创建的是数组的数组, 即二维数组.

    数组名的值是个指针常量(或者说, 数组名是不可修改的左值)


--------------------------------------------------------------

声明一个一维数组
    通过声明数组告诉编译器数组中内含多少元素和这些元素的类型.
        type array_name[size];
    方括号[]表明对应的变量名为数组, 方括号中的整数常量表明数组中的元素个数.
    也可以不写数组元素的个数, 但必须伴随初始化, 这样编译器可以判断给定的数组元素多少.
        type array_name[] = {value1, value2, ...};

    对于传统的C数组, 必须用常量表达式指明数组的大小, 所以数组大小在编译的时候就已确定.
    C99/C11新增了变长数组作为编译器可选项, 可以用变量表示数组大小, 虽然这在C++中已经习以为常了.
    这意味着变长数组的大小延迟到程序运行时才确定.
    不过在实践中, 很多C编译器都没有实现变长数组.


给数组元素赋值
    识别数组元素的数字被称为下标(subscript), 索引(indice)或偏移量(offset)

    声明数组后, 可以借助数组下标(或者说索引)给数组元素赋值.
        array_name[3] = value;
    所赋值value应该和数组保存的类型一致.

    注意:
        C不允许把数组作为一个单元赋给另一数组, 除初始化以外不允许使用花括号列表的形式赋值.


访问数组中的元素
    整个数组有一个数组名, 通过整数下标访问数组中单独的元素(element)
        array_name[3];   // 访问一维数组中第4个元素
    考虑到影响执行的速度, C编译器不会检查数组的下标是否正确.
    因此, 如果下标值超过数组容量, 会导致数据被放置在已被其他数据占用的地方, 可能会破坏程序的结果甚至导致程序异常中断
    下标必须是正整数, 并且从0开始计数, 对于内含n个元素的数组, 其最后一个元素的下标是n-1


数组的边界
    在使用数组时, 要防止数组下标超出所指定的数组大小. 也就是说, 必须保证下标是有效值.

    编译器不会检查数组下标是否使用得当. 在C标准中, 使用越界下标的结果是未定义的. 这意味者程序看上去可行, 但是运行结果却很奇怪, 或异常中止.
    这是因为C信任程序员的原则.

    要记住, 数组元素的编号从0开始, 到指定元素个素n-1结束.


指定数组的大小
    C99标准之前, 声明数组时只能在方括号中使用整型常量表达式. 
    所谓整型常量表达式, 是由整型常量构成的表达式. sizeof表达式被视为整型常量, 但是与C++不同, const限制的变量不是, 其为常变量, 还是变量.
    另外, 表达式的值必须是大于0的整数.

    如  
        int nums[0];   // 无效, 数组大小必须大于0
        int nums[(int) 3.14];   // 有效, 已被强制转换为整型
        float nums[5*2 + 6];   // 有效
        float nums[sizeof(int) + 3]   // 有效
    
    在C99中, 规定了可以使用大于零的整型变量作为数组长度的指定.
    在C11中, 这一规定被设置为可选项, 一般C编译器都不会支持.
    如果编译器支持变长数组(variable-length array), 即VLA, 还可以使用大于零的整型变量指定数组长度
        int len = 3;
        float array[len];
    如果使用C++编译器, 这是可行的, C++支持使用变量指定数组长度.


--------------------------------------------------------------

初始化数组
    数组通常被用来顺序存储程序需要的数据.
    可以使用逗号分隔的值列表(用花括号括起来)来初始化数组, 各值之间用逗号分隔.
    如
        int nums[6] = {1, 2, 3, 4 , 5, 6};

    使用const声明数组
        有时候需要把数组设置为只读.
        这样, 程序只能从数组中检索值, 不能把新值写入数组.
        要创建只读数组, 应该用const声明并同时初始化数组. 一旦数组声明为const, 便不能再为其赋值.
        如
            const int weeks[7] = {1, 2, 3, 4, 5, 6, 7};
        这样程序在运行过程中就不能修改数组中的内容.

    在使用数组前, 必须先初始化他. 与普通变量类似, 在使用数组元素前, 必须先给他们赋初值.
    编译器使用的值是内存相应位置上的现有值. 如果进行读取使用, 可能会造成意想不到的破坏.

    存储类别警告
        数组和其他变量类似, 可以把数组创建成不同的存储类别(storage class).
        在未指定存储类型, 都是auto(自动存储类别), 意思是这些数组在函数内部声明, 且声明时未使用static关键字

        对于一些其他存储类别的变量和数组, 如果在声明时未初始化, 编译器会自动把他们的值设置为0.

    如果不初始化数组, 数组元素和未初始化的普通变量一样, 其中存储的都是垃圾值.
    初始化数组时, 使用的初始化列表中的项数与数组的指定大小不一致. 
    当初始化列表中的值少于数组元素个数时, 编译器会将剩余的元素初始化为0. 即部分化初始化数组, 剩余的元素会被初始化为0.
    当初始化列表中的值多于数组元素个数时, 编译器将会报错.


经典数组长度判断
        sizeof array/sizeof array[0];
    或写作
        sizeof(array)/sizeof(array[0]);
    sizeof返回值为size_t类型, 以字节为单位. 
    运算整个数组的时候, 会得出整个数组的所占的字节数, 运算数组中的元素的时候, 会的得出单个数组元素所占的字节数.
    二者相除, 得出数组的长度.
    处理的必须是数组变量才行, 指针的话不行. 因为sizeof会计算指针变量的大小, 而不是整个数组的大小


指定初始化器(C99)
    指定初始化器(designated initializer).
    利用该特性可以初始化指定位置的数组元素.
    如, 初始化数组最后一个元素
        传统的做法是必须初始化最后一个元素之前的所有元素
            int nums[6] = {0 , 0, 0, 0, 0, 6};
        使用指定初始化器
            int nums[6] = {[5]=6};   // 将nums[5]位置初始化
    
    对于一般的初始化, 在初始化一个元素后,, 未初始化的元素会被设置为0.

    如果指定初始化器后面有更多的值, 那么后面这些值将被用于初始化指定后面的元素.
        int nums[6] = {[2]=3,4,5,6};
    如果再次初始化指定值, 那么最后的初始化将会被取代之前的初始化.
        int nums[6] = {[2]=3,4,5,6,[5]=0};   // nums[5]会被初始化为0


--------------------------------------------------------------

多维数组
    可以理解为数组的数组, 即定义一个数组-主数组(master array), 其元素也是数组.
    也可以将其看作一个代表多项式方程组的矩阵, 一行一方程, 即第一个数组是一个方程, 这个方程也是一个数组.


声明一个二维数组
    float matrix[3][4];   // 3个数组, 数组元素为大小为4的数组

    多维数组在内存中也是按顺序存储的. 所以就算是多维, 也只需要声明一个类型.
    先存储第一个数组元素, 然后在后面接上第二个, 以此类推, 最后这段内存又组成大的一个数组, 共同为二维数组.


初始化二维数组
    初始化二维数组是建立在初始化一维数组的基础上的. 要明确, 二维数组第一维就是普通的一维数组, 而存储的内容是另一个数组.

    int matrix[3][4] = {
        {11, 12, 13, 14},
        {21, 22, 23, 34},
        {31, 32, 33, 34}
    };

    初始化时候, 也可以省略花括号, 只保留最外面的一对花括号, 由此可见多维数组在内存中就是一个一维数组
    int matrix[3][4] = {11, 12, 13, 14, 21, 22, 23, 24, 31, 32, 33, 34};
    但是需要注意, 要保证初始化的数值个数正确. 
    所给项数少于所指定的个数, 即按先后顺序逐行初始化, 直到用完所有的值, 后面没有初始化的元素被统一初始化为0.
    int matrix[2][3] = {{11, 12}, {21,22}};
    matrix[0] 为数组 (int [3]){11, 12, 0}
    matrix[1] 为数组 (int [3]){21, 22, 0}

    int matrix[2][3] = {11, 12, 21, 22};
    matrix[0] 为数组 (int [3]){11, 12, 21}
    matrix[1] 为数组 (int [3]){22,  0,  0}


其他多维数组
    声明一个三维数组
        three_dimension[10][20][20];
    
    可以把一维数组想象成一行数据, 把二维数组想象成数据表, 把三维数组想象成一叠数据表.


多维数组数组的遍历
    一维数组只需要一个循环就可以遍历
    而二维数组需要两个嵌套循环遍历, 一个遍历其本省数组, 第二个遍历其所指向元素, 这个元素是一个数组.
    三维自然也就需要三个嵌套循环遍历, 之后以此类推.


--------------------------------------------------------------

数组与指针
    C把数组名解释为数组首元素的地址.
    换言之数组名与指向该数组首元素的指针等价.
    指针加上一个整数或递增指针, 指针的值以所指向对象的大小为单位改变.
    如
        array[i] == *(array+i);
    如果array是一个记录double类型的数组, 那么array+1, 意味着指针array其值增加8, 因为double具有8个字节, 这使指针array表示下一个元素
    数组和指针关系密切, 以上两种表示方法分别为数组表示法和指针表示法. 
    他们之间的关系允许在处理数组的函数中使用数组表示法, 即使函数的形式参数是一个指针, 而不是数组.

数组做函数形参
    对于C语言, 不能把整个数组作为参数传递给函数, 但是可以传递数组的地址. 因此函数对应的形式参数是指针.
    然后函数用传入的地址操控原始数组.
    如果不想通过该指针修改原始数组, 可以在声明函数的形式参数时使用const关键字.
    在被调用函数中可以使用数组表示法或指针表示法, 无论哪种方法, 实际上是用的都是指针变量

    多维数组传递, 因为任何多维数组实际上在内存中就是以一维数组的方式顺序排列的
    对于一维数组, 可以使用一个对应类型的指针直接作为参数, 程序默认以指定类型大小读取元素
    对于多维数组, 也是一样, 先使用一个对应类型的指针指向那一块内存地址, 然后在告诉编译器这个指针指向的内存分段, 即表示存储的元素是数组(多个对象作为一个元素)而不是单个元素
    如, 一个三维数组
        void sum_matrix(int (*matrix3d)[4][8]);
        void sum_matrix(int matrix3d[][4][8]);
    因为在函数形参中空的方括号[]等同于指针运算符, 所以以上两者都可以
    先是声明一个指针int *matrix, 然后在告诉编译器这个指针指向的内存分段int (*matrix)[4][8]
    指向的这块内存为4个数组, 这4个数组中又有8个元素

    为了处理数组, 函数必须知道从何处开始读取数据和要读取多少个数组元素.
    数组提供了地址, 元素个数可以内置在函数中或作为单独的参数传递.


--------------------------------------------------------------

变长数组 VLA
    C99新增了变长数组(variable-length array, VLA), 允许使用变量表示数组的长度
    C11规定, 变长数组作为编译器的可选特性, 而不是强制实现, 所以C编译器不一定会支持使用变长数组

    变长数组有一些限制. 变长数组必须是自动存储类别, 即auto, 这意味着无论在函数中声明还是作为函数形参声明, 都不能使用静态static或extern存储类别说明符号
    而且不能在声明中初始化他们.

    变长数组中的变不是指可以修改已经创建了的数组大小. 一旦创建了变长数组, 他的大小则保持不变.
    这里的变指的是在创建数组时, 可以使用变量指定数组的长度.

    变长数组允许动态内存分配, 这说明可以在程序运行时指定数组的大小.
    普通C数组都是静态内存分配, 即在编译时确定数组的大小. 由于数组大小是常量, 所以编译器在编译的时就知道了.

    变长数组的用处
        可以在函数中动态的创建数组, 而不用使用malloc()或者calloc()来创建
        如
            int sum_matrix(unsigned int row, unsigned int column, int matrix[row][column]);
        形参中row和column必须在matrix之前声明
        逗号运算符运算顺序从左到右, 而matrix在row和column的右边声明, 所以matrix是在调用的时候创建的
    
    C99/C11规定, 可以省略原型中的形参名, 但是在使用变长数组的时候, 必须使用星号开代替省略的维度
        int sum_matrix(unsigned int, unsigned, int matrix[*][*]);

    const和数组大小
        C99/C11规定, 允许在声明变长数组时使用const变量, 即常变量.
        所以该变长数组的定义必须是声明在块中的自动存储类别auto数组.
