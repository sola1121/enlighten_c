存储类别 storage class

    C提供了多种不同的模式或存储类别.
    自动, 寄存器, 静态外部链接, 静态内部链接, 静态无链接, 动态分配存储期.

    存储类别      存储期   作用域   链接    声明方式
    -------------------------------------------------------------------
    自动          自动     块      无       块内
    寄存器        自动     块      无       块内, 使用关键字register
    静态外部链接   静态     文件    外部      所有函数外
    静态内部链接   静态     文件    内部      所有函数外, 使用关键字static
    静态无链接     静态     块      无       块内, 使用关键字static

    作用域
        块作用域: 从定义处到包含该定义的块的末尾
        文件作用域: 从其所定义处到文件末尾
    链接
        无链接: 只能在当前块中使用
        内部链接: 能在所在翻译单元中使用
        外部链接: 能在多个翻译单元中使用
    存储期
        自动存储期: 执行进入所在块即开辟空间, 退出所在块即回收所开辟空间
        静态存储期: 程序执行开始便为其分配存储空间, 并一直保持到程序结束

        补充
            还有使用动态内存分配的动态类存, 其存储期是由动态分配开始, 直到调用free()结束, 是显式手动的.

    例
        int num1;   // 具有外部链接的文件作用域, 静态存储期, 即全局变量, 且对其他文件(翻译单元)也可见
        static int num2;   // 具有内部链接的文件作用域, 静态存储期, 即全局变量, 只对所在翻译单元可见

        int main(){
            ...
            int num3;   // 块作用域, 无链接, 自动存储期, 即局部变量, 只对当前整个块可见
            static int num4;   // 块作用域, 无链接, 静态存储期, 即局部变量, 只对当前整个块可见, 但是变量会在程序执行期间一直存在
            register int num5;   // 块作用域, 无链接, 自动存储期, 即局部变量, 只对当前整个块可见, 但是可能存储到更快的内存或CPU寄存器中, 不能获得地址
            ...
        }


--------------------------------------------------------------

自动变量 auto关键字
    auto在C++为自动类型判断, 而在C中是存储类别说明符(storage-class specifier).

    自动变量具有块作用域, 无链接, 自动存储期.
    即从定义处到包含该定义的块的末尾, 属于定义他们的块, 函数, 函数原型私有, 执行到所在块为其分配内存空间, 完成块回收所分配空间.

    块作用域, 无链接, 意味着他们是局部变量.
    只有在变量定义所在的块中才能通过变量名访问该变量(通过函数参数传递变量值和地址属于间接方法).

    另一个函数可以使用同名变量, 但是该变量是存储在不同内存位置上的另一个变量.

    嵌套块
        内层块中的同名变量会隐藏外层块中的变量.
        int loop(int times){
            int m;                        // m的作用域
            scanf("%d", &m);
            {
                int n;                    // m和n的作用域
                for (n=m; i<times; n++)
                    puts("n 在一个子块中");
            }
            return m;                     // m的作用域, n已经消失
        }
        n只在其声明的内层块中可见. n可在只使用他的时候占用内存.
        变量times和m分别定义在函数头和外层块中, 他们的作用域是整个函数, 而且在调用函数到函数结束期间都会一直存在.

        当内层块中声明的变量与外层块中的变量同名, 内层块会隐藏外层块的定义, 当离开内层块后, 外层块变量的作用域又回到了原来的作用域.
            int main(){
                int count = 0;
                printf("在main()中的count: %p, %d\n", &count, count);

                while (count++ < 23){   // 外层main里面声明的count
                    int count = 100;   // 内层while子块中的count
                    printf("%p, %d\n", &count, count);
                }

                return 0;
            }
        while子块内层中的count会隐藏外层main中的count.

    没有花括号的块
        if或循环语句, 即使没有花括号, 整个语句是一个块, 其所执行的部分属于整个语句的子块(sub-block).
            int main(){
                int count=0;
                printf("在main()中的count, %p, %d.\n", &count, count);

                for (int count=100; count<120; count++)   // for循环语句中的count
                    printf("%p, %d\n", &count, count);

                for (int count=100; count<120; count++){   // for循环语句中的count
                    int count = -30;                // for循环语句执行部分的子块中的count
                    ++ count;                       // 对for循环语句执行部分的子块中的count进行运算
                    printf("for循环语句执行部分的子块中的count: %p, %d\n", &count, count);
                }
                
                return 0;
            }
    注意
        有些编译器并不支持C99/C11这些作用域规则(Microsoft Visual Studio 2012就是其中之一).
        有些编译会提供激活这些规则的选项. 得指明使用的C语言标准, 使用-std=c11 选项.

    自动变量的初始化
        自动变量不会初始化, 除非显式初始化他. 任何只声明而没有显式初始化的自动变量保存的内容都是未定义的.


寄存器变量 register关键字
    变量通常存储在计算机内存中. 但是编译器会使用更快的内存或CPU寄存器存储他们.
    因为寄存器变量可能存储在CPU寄存器中, 所以不能获取寄存器变量的地址.

    绝大多数方面, 寄存器变量都和自动变量一样, 为块作用域, 无链接, 自动存储期.
    即从定义处到包含该定义的块的末尾, 属于定义他们的块, 函数, 函数原型私有, 执行到所在块为其分配内存空间, 完成块回收所分配空间.
    如 
        void echo(register int num); 

        int main(){
            register int num;
        }
    可声明为register的数据类型有限. 这是因为在CPU中的寄存器空间有限, 一般就32位或者64位


静态变量 static关键字
    静态变量(static variable)
        静态变量在内存中地址不会改变.
        静态变量在编译时便初始化, 未显式初始化的将会被赋值0, 在程序执行期间会一直存在.
        具有文件作用域的变量具有(一定是)静态存储期.

    块作用域的静态变量
        变量在块中, 为块作用域, 无链接, 自动存储期, 当以存储类别说明符static声明该变量, 将会提供给该变量静态存储期.
        使该变量在该块中可见, 但在整个程序执行期间都存在.
            void fun(){
                static int num = 0;   // 在编译时初始化一次. 虽然变量只在函数执行到函数块时才可见, 但是在整个函数执行期间都是存在的.
                num ++;
                printf("%d", num);
            }
        每次调用fun的值都会递增1
        不同于自动变量的在每次调用函数时候会初始化一次(运行时行为), 静态变量只在编译时会初始化一次(编译时行为). 如果没有显式的初始化静变量, 其会被初始化为0.
        静态变量和外部变量在程序被载入内存时已执行完毕.

        不能在函数的形参中使用static
            void fun(static int num);   // 错误

    外部链接的静态变量
        外部链接的静态变量具有文件作用域, 外部链接, 静态存储期.
        即从他的定义处到该定义所在文件的末尾均可见, 可以在多文件程序中使用, 在程序的执行期间一直存在.

        该类别有时称为外部存储类别(external storage class), 该类别的变量称为外部变量(external variable).
        把变量的定义性声明(defining declaration)放在所有函数的外面便创建了外部变量.
        外部变量具有静态存储期, 在编译阶段变量初始化, 在程序运行阶段, 所声明的外部变量一直存在.

        为了指出该函数使用了外部变量, 可以在函数中用关键字extern再次声明.
        如果一个源代码文件使用外部变量定义在另一个源代码文件中, 则必须用extern在该文件声明该变量
            int ex_num;            // 外部定义的变量
            double ex_array[10];   // 外部定义的数组
            extern char ex_ch;     // 从另一个文件引入, 需是另一个文件的全局变量
            
            void next();

            int main(){
                extern int ex_num;   // 可选的声明

                extern double ex_array[];   // 可选的声明
                ...
            }

            void next(){
                ...
            }
        注意, 在main中声明ex_array数组时(这是可选的声明)不用指明数组大小, 因为第一次声明已经提供了数组大小信息.
             main中的两条extern声明完全可以省略, 因为外部变量具有文件作用域, 所以ex_num和ex_array从声明处到文件结尾都可见.
        如果省略掉main函数中的extern关键字, 相当于在main中创建了一个自动变量, 即main中的局部变量.
        在执行main函数块中的同名变量时, 外部的文件作用域中的同名变量将会被隐藏.
        若需要使用与外部变量同名的局部变量, 在局部变量声明时, 可以显式的使用auto来指明其存储类别.

        初始化外部变量
            可以显式初始化外部变量, 但是与自动变量显式初始化不同的是, 如果未初始化外部变量, 其会被初始化为0.
            只能使用常量表达式初始化文件作用域变量. 比如使用另一个变量 int num = x*2; 这样就不行.

        使用外部变量
            外部变量具有文件作用域, 外部链接, 静态存储期
            即从他的定义处到该定义所在文件的末尾均可见, 可以在多文件程序中使用, 在程序的执行期间一直存在.
                double num = 3.14159;

                int main(){
                    extern double num;   // 显式声明使用外部变量
                    ...
                }

                void fun(){
                    scanf("%ld", &num);   // 没有显式的声明外部变量, 而直接使用
                }

        外部名称
            C99和C11标准都要求编译器识别局部标识符的前63个字符和外部标识符的前31个字符.
            外部变量名比局部变量名的规则严格, 是因为外部变量名还要遵循局部环境规则.

        定义和声明
                double num = 3.14159;

                int main(){
                    extern double num;
                }
            第一次对num的声明称为定义式声明(defining declaration), 第二次声明被称为引用式声明(referencing declaration).
            关键字extern表明该声明不是定义, 因为他指示编译器到别处查询其定义.

                extern double num;
                int main(){

                }
            在函数外使用引用式声明, 编译器会假设num实际的定义在该程序的别处, 也许在别的文件中.
            该声明并不会引起分配存储空间.
            因此, 不要用关键字extern关键字创建外部定义, 只用他来引用现有的外部定义.

                /* 文件 file1.c */
                char ex_ch = 'a';

                /* 文件 file2.c */
                int main(){
                    extern char ex_ch;
                }
            外部变量只能初始化一次, 且必须在定义该变量时进行. 因此不能在定义式声明后再对外部变量赋值.
            要在不同文件中使用外部变量, 需要将这些文件放在一起编译.
                gcc file1.c file2.c -o file.out
            注意
                在编译中只能有一个main
        
        外部链接的静态变量在多文件的应用
            复杂的C程序通常由多个单独的源代码文件组成. 有时这些文件可能要共享一个外部变量.
            C通过在一个文件中进行定义式声明, 然后在其他文件中进行引用式声明来实现共享.
            也就是说, 除了一个定义式声明外, 其他声明都要使用extern关键字. 而且只有定义式声明才能初始化变量.

            注意
                如果外部变量定义在一个文件中, 那么其他文件在使用该变量之前必须先用extern关键字声明他.
                也就是说, 在某文件中对外部变量进行定义式声明只是单方面允许其他文件使用该变量, 其他文件在用extern声明之前不能直接使用他.


    内部链接的静态变量
        内部链接的静态变量, 具有文件作用域, 内部链接, 静态存储期.
        即从他的定义处到该定义所在文件的末尾均可见, 能在所在翻译单元(所在文件)中使用, 在程序的执行期间一直存在.

        用存储类别说明符static定义
            static int num = 1;
            int main(){
                ...
            }

        过去这种变量称为外部静态变量(external static variable), 但是这个术语有点自相矛盾(这些变量具有内部链接).
        但是, 没有合适的新简称, 所以只能用内部链接的静态变量(static variable with internal linkage).


-------------------------------总结-----------------------------

存储类别说明符
    static关键字与extern关键字的含义取决于上下文.

    C语言有6个关键字作为存储类别说明符
        auto, register, static, extern, _Thread_local, typedef.
    
    typedef关键字与任何内存存储无关, 把他归类与类型类别说明符有一些语法上的原因.
    尤其是, 在绝大多数情况下, 不能在声明中使用多个存储类别说明符, 所以这意味着不能使用多个存储类别说明符作为typedef的一部分.
    唯一例外的是_Thread_local, 他可以和static和extern一起使用.

    auto说明符表明变量是自动存储期, 只能作用于块作用域的变量声明中.
    由于在块中声明的变量本身就具有自动存储期, 所以使用auto主要是为了明确表达要使用与外部变量同名的局部变量的意图.

    register说明符用于块作用域变量, 他把变量归为寄存器存储类别, 请求最快速访问该比啊量. 同时, 还保护了该变量的地址不被获取.

    static说明符创建的变量具有静态存储期, 载入程序时创建对象, 当程序结束时对象消失.
    如果static应用于文件作用域声明, 作用域受限于该文件.
    如果static用于块作用域声明, 作用域受限于该块. 
    因此, 只要程序在运行对象就存在并保留其值, 但是只有在执行块内代码时, 才能通过标识符访问.
    文件作用域的静态变量具有内部链接.
    块作用域的静态变量无链接.

    extern说明符表明声明的变量定义在别处.
    如果包含extern的声明具有文件作用域, 则引用的变量必须具有外部链接.
    如果包含extern的声明具有块作用域, 则引用的变量可能具有外部链接或内部链接, 取决于对应变量的定义式声明.

    不同存储类型变量的对比
        自动变量具有块作用域, 无链接, 自动存储期.
        为局部变量, 属于其定义所在的块(通常指函数)私有.

        寄存器变量的属性和自动变量相同, 但是编译器会使用更快的内存或CPU寄存器存储他们.
        不能获取寄存器变量的地址.

        具有静态存储期的变量可以具有外部链接, 内部链接, 无链接. 
        在同一个文件所有函数的外部声明的变量是外部变量, 具有文件作用域, 外部链接, 静态存储期. --外部链接的静态变量(对于多个翻译单元的全局变量)
        如果在这种声明前面加上关键字static, 那么其声明的变量具有文件作用域, 内部链接, 静态存储期. --内部链接的静态变量(对于当前翻译单元的全局变量)
        如果在函数中用static声明一个变量, 则该变量具有块作用域, 无链接, 静态存储期. --块作用域的静态变量

        具有自动存储期的变量, 程序在进入该变量的声明所在块时才为其分配内存, 在退出该块时释放之前分配的内存. 如果未初始化, 自动变量中的是垃圾值. 
        具有静态存储期的变量, 程序在编译时为该变量分配内存, 并在程序的运行过程中一直保留这块内存. 如果未初始化, 静态变量变量会被设置为0.

        具有块作用域的变量是局部的, 属于包含该声明的块私有. 
        具有文件作用域的变量对文件(或翻译单元)中位于其声明后面的所有函数可见.
        具有外部链接的文件作用域变量, 可用于该程序的其他翻译单元.
        具有内部链接的文件作用域变量, 只能用于其声明所在的文件内.
