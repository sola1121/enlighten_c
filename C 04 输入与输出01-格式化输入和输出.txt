C 中最常规使用 scanf 和 printf 与用户进行输入与输出的交互, 属于标准输入输出函数, 在 stdio.h 头文件中定义
他们都要和转换说明(conversion specification)配合使用

空白字符 - 制表符 \t, 空格 (space), 换行符 \n.


--------------------------------------------------------------

int scanf(const char *restrict format, ...)

scanf的返回值 - 返回成功读取的项数. 如果没有读取任何项, 且需要读取一个数字而用户却输入一个非数值字符按串, 则返回0
               当scanf检测到文件结尾(EOF)时, 会返回EOF, EOF在stdio.h 中一般定义为-1, 是一个特殊值

    scanf将对应转换说明的内容, 放入指定的地址, 就是说, scanf的赋值对象是指针, 或者说变量所在的地址, 其行为是将内容直接放入内存地址.

    遇到第一个空白(空格, 制表符, 换行符)时不再读取输入, 未读取的输入依然在stdin流(标准输入)中, 下次会接着读取.
    唯一例外的是%c转换说明. 根据%c, scanf会读取每个字符, 包括空白.


scanf()转换说明
    %c : 把输入解释成字符
    %s : 把输入解释成字符串. 从第一个非空白字符开始, 到下一个空白字符之前的所有字符都是输入
    %d 或 %i: 把输入解释成有符号十进制整数
    %u : 把输入解释成无符号十进制整数
    %o : 把输入解释成有符号八进制整数
    %x, %X : 把输入解释成有符号十六进制整数
    %f, %e, %E, %g, %G, %a, %A : 把输入解释成浮点数
    %p : 把输入解释成指针(地址)

scanf()转换说明的修饰符
    修饰符需要配合转换说明来使用
    * : 抑制赋值, 即跳过多余的项
        如: "%*d"
    数字 : 最大字段宽度. 输入达到最大字段宽度处, 或第一次遇到空白字符时停止
          如: "%10s"
    hh : 把整数作为signed char 或 unsigned char类型读取
         如: "%hhd", "%hhu"
    ll : 把整数作为long long 或 unsigned long long类型读取
         如: "%lld", "%llu"
    h 或 l 或 L : "%hd", "%hi" 表明把对应的值存储为short int 类型
                 "%ho", "%hx", "%hu" 表明把对应的值存储为unsigned short int 类型
                 "%ld", "%li" 表明把对应的值存储为long 类型
                 "%lo", "%lx", "%lu" 表明把对应的值存储为unsigned long 类型
                 "%le", "%lf", "%lg" 表明把对应的值存储为double 类型
                 在e, f, g 前面使用L 而不是l, 表明把对应的值存储为long double 类型.
                 如果没有修饰符, d, i, o, x表明对应的值被存储为int 类型, f, g表明把对应的值存储为float 类型
    j : 在整型转换说明后面时, 表明使用intmax_t或uintmat_t类型
        如: "%jd", "%ju"
    z : 在整型转换说明后面时, 表明使用size_t类型
        如: "%zd", "%zo"
    t : 在整型转换说明后面时, 表明使用表示两个指针差值的类型
        如: "%td", "%tx"

说明
    scanf与printf的转换说明几乎相同. 主要区别是, 对于float类型和double类型, printf都使用%f, %e, %E, %g, %G转换说明.
    而scanf只把他们用于float类型, 对于double类型, 要使用l修饰符.

    更好的替代方式

    int getchar();
    从stdin中获取一个字符

    char *fgets(char * restrict s, int n, FILE *restrict stream)
    从指定文件流中获取一行字符串

scanf()如何读取字符
    假设scanf根据一个%d转换说明读取一个整数. 即scanf("%d", &num);
    scanf函数每次读取一个字符, 跳过所有的空白字符, 直至遇到第一个非空白字符才开始读取.
    因为要读取整数, 所以scanf希望发现一个数字字符或者一个正负号.
    如果找到一个数字或符号, 便保存该字符, 并读取下一个字符.
    如果下一个字符是数字, 便保存该数字并读取下一个字符.
    scanf不断地读取和保存字符, 直至遇到非数字字符. 当遇到非字符, 便认为读到了整数的末尾.
    然后scanf把非数字字符放回输入. 这就是说, 在下一次读取输入时, 首先读到的是上一次读取丢弃的非数字字符.
    最后, scanf计算已读取数字(可能还有符号)相应的数值, 并将计算后的值放入指定的变量中.

    如果使用字段宽度, 如, scanf("%2d", &num), scanf会在字段结尾或第一个空白字符处停止读取.

    如果第一个非空白字符是字母字符而不是数字, scanf将停在哪里, 什么也不获取, 将输入放回.
    在下一次读取时, 首先读到的还是该字母字符. 
    如果只是要求读取%d, 即整数, scanf就一直无法越过该字母字符.
    另外, 如果使用带多个转换说明的scanf, C规定在第一个出错处停止读取输入.
    若使用其他数值匹配的转换说明, 如%x, 那么一些字母字符也是允许的.

    如果使用%s转换说明, scanf会读取除空白以外的所有字符. scanf跳过空白开始读取第一个非空白字符, 并保存非空白符直到再次遇到空白.
    这意味着scanf更具%s转换说明读取一个单词, 即不包含空白字符的字符串.
    如果使用字段宽度, scanf在字段末尾或第一个空白字符处停止读取.
    无法利用字段宽度让只有一个%s的scnaf读取多个单词.
    最后注意, 当scanf把字符串放进指定内存地址(一般是一个char数组)时, 他会在字符序列末尾加上'\0', 让数组中的内容成为一个C字符串.

scanf格式字符串中的普通字符
    scanf函数允许把普通字符放在格式字符串中. 除空格字符外的普通字符必须与输入字符串严格匹配.
    如:
        scanf("%d, %d", &num1, &num2);
        scanf()函数将其解释为用户将会输入一个数字, 一个逗号, 再输入一个数字
    scanf会跳过第二个整数前面的空白, 所以 
        22, 33

        22,
        33
    以上两种输入格式都没问题
    格式字符串中的空白意味着跳过下一个输入项前面的所有空白, 所有的空白也包括没有空格的情况.
    注意:
        如上情况, 在scanf格式化中使用的空白字符都会被忽略, 如在格式化字符中使用换行符, 空白等
        但是这些空白字符会被从输入流stdin中拿走, 因为空白字符会被忽略, 所以不是只拿一个, 而是对应位置的全部, 如果没有指定, 就不会被拿走.

    除了%c之外, 其他转换说明都会自动跳过待输入值前面的所有空白. scanf("%d%d", &num1, &num2);和scanf("%d %d", &num1, &num2);行为相同
    如果在格式字符串中把空格放到%c前面, scanf便会跳过空格, 从第一个非空白字符开始读取.
    如:
        scanf("%c", &ch);   // 从输入中的第一个字符开始读取
        scanf(" %c", &ch);   // 从第一个非空白字符开始读取


--------------------------------------------------------------

int printf(const char * restrict format, ...)

printf的返回值 - 返回打印字符的个数, 如果有输出错误, 则返回一个负值

printf()转换说明
    %c : 单个字符
    %s : 字符串
    %d 或 %i : 有符号十进制整数
    %u : 无符号十进制整数
    %f : 浮点数, 十进制记数法
    %o : 无符号八进制整数
    %x 或 %X : 无符号十六进制整数, 使用十六进制数0f 或 0F
    %a 或 %A : 浮点数, 十六进制数和p记数法
    %e 或 %E : 浮点数, e记数法, 对应指定的大小写
    %g 或 %G : 根据值的不同, 自动选择%f, %e, %E. %e或%E格式用于指数小于-4或者大于或等于精度时
    %p : 表示地址, 通常是一个十六进制数. 每个十六进制对应4位
    %% : 打印一个百分号

printf()转换说明的修饰符
    修饰符需要配合转换说明来使用
    标记 : - + 空格 # 0, 可以不使用标记或使用多个标记
          - , 待打印项左对齐. 即从字段的左侧开始打印该项. 如: "%-23s"
          + , 有符号值若为正, 则在之前面显示加号, 若为负, 则在值前显示减号
          空格 , 有符号值若为正, 则在值前面显示前导空格(不显示任何符号), 若为负, 则在值前面显示减号. +标记并覆盖空格. 如: "% 4.3f"
          # , 把结果转换为另一种形式.
              如果是%o格式, 则以0开始; 如果是%x或%X格式, 则以0x或0X开始
              对于所有浮点格式, #保证了即使后面没有任何数字, 也打印一个小数点字符
              对于%g和%G格式, #防止结果后面的0被删除
              如: "%#o", "%#8.0f", "%+#10.3e"
          0 , 对于数值格式, 用前导0代替空格填充字段宽度.
              对于整数格式, 如果出现-标记或指定精度, 则忽略该标记
              如: "%010d", %08.3f"
    数字 : 最小字段宽度.
          用十进制整数来表示输出的最少位数.
          若实际位数多于定义的宽度, 则按实际位数输出.
          若实际位数少于定义的宽度, 则补以空格或0.
          如果该字段不能容纳待打印的数字或字符串, 系统会使用更宽的字段. 
          如: "%5d"
    .数字 : 精度. 
           如果输出数字, 则表示小数的位数.
           如果输出的是字符, 则表示输出字符的个数.
           若实际位数大于所定义的精度数, 则截去超过的部分.
           对于%e, %E, %f转换, 表示小数点右边数字的位数
           对于%g, %G转换, 表示是有效数字最大位数
           对于%s转换, 表示待打印字符的最大数量
           对于整型转换, 表示待打印数字的最小位数
           如有必要, 使用前导0来达到这个位数
           只使用.表示其后跟随一个0, 所以%.f和%.0f相同
           如: "%6.4f"
    h : 和整型转换说明一起使用, 表示short int 或 unsigned short int类型的值
        如: "%hu", "hx", "%4.8hd"
    hh : 和整型转换说明一起使用, 比哦啊是signed char 或 unsigned char类型的值
         如: "%hhu", "%hhx", "%4.8hhd"
    j : 和整型转换说明一起使用, 表示intmax_t 或 uintmax_t类型的值. 这些类型在stdint.h
        如: "%jd", "%8jx"
    l : 和整型转换说明一起使用, 表示long int 或 unsigned long int类型的值
        如: "%ld", "%8lu"
    ll : 和整型转换说明一起使用, 表示long long int 或 unsigned long long int类型的值
         如: "%lld", "%8llu"
    L : 和浮点转换说明一起使用, 表示long double类型的值
        如: "%Lf", "%10.4Le:
    t : 和整型转换说明一起使用, 表示ptrdiff_t类型的值. ptrdiff_t是两个指针差值的类型
        如: "%td", "%12ti"
    z : 和整型转换说明一起使用, 表示size_t类型的值. size_t表示字节数, 实质是无符号整数


说明
    %f, 默认情况下, 打印数字所需的位数和小数点后打印6位数字
    %e, 默认情况下, 编译器在小数点的左侧打印1个数字, 在小数点的右侧打印6个数字

printf()如何打印字符
    printf("%d, " "%d, " "%d, " "%d\n", num1, num2, num3, num4);

    该调用告诉计算机把变量num1, num2, num3, num4的值传递给程序.
    程序把传入的值放入被称为栈(stack)的内存区域. 计算机根据变量类型把这些值放入栈中. 各占各个对应的字节大小.
    接下来就是printf函数调用这些数据, 该函数根据转换说明(注意, 不是根据实际的变量类型)从栈中读取值. %d就是表示读取4个字节.
    从栈中依次读取对应的字节, 然后对应转换说明, 将其转换为对应的字符以输出.

转换说明的意义
    转换说明把以二进制格式储存在计算机中的值转换成一系列字符(字符串)以便于显示.
    例如:
        数字76, 在计算机内部的储存格式是二进制数01001100
        %d转换说明将其转换成字符'7'和'6'
        %x将其转换成十六进制记数法"4c"
        %c将其转换成字符'L'
    
    转换不匹配
        格式字符串中的转换说明一定要与标准输入输出后面的每个项相匹配, 若忘记, 会导致严重的后果.

        整型的混淆
            short posi_num = 336;
            short nega_num = -336;
            printf("负数short, 无符号short: %hd , %hu\n", nega_num, posi_num);   // -336, 65200
            printf("作为int, 作为字符char: %d, %c\n", posi_num, posi_num);   // 336, P

            short int的大小是2个字节, 其实系统使用二进制补码来表示有符号整数. 
            这种方法, 数字0~32767代表他们本身, 而数字32768~65535则表示负数, 其中65535表示-1, 65543表示-2, 以此类推.
            因此-336表示为65200(即65535-336), 所以被作为无符号整型的时候, 就会输出65200

            将short int 转换为char, 因为char只有一个字节, 即当将一个大于255的值转换为字符时
            printf转换 %c只会查看存储336的2字节中的后一个字节
            这种截断相当于用一个整数除以256, 只保留其余数. 即取模336为80, 对应的ASCII值是字符'P'

        浮点的混淆
            long d_num = 1234567890;
            float f_num = 3.0;
            printf("整型打印为ld, 浮点打印为ld: %ld, %ld\n", d_num, f_num);   //  1234567890, 140724822817096
            printf("整型打印为.1e, 浮点打印为.1e: %.1e, %0.1e\n", d_num, f_num);   // 3.0e+00, 9.5e-130

            long在这里是8个字节, float 是4个字节
            使用ld打印, 在处理float的时候, 不仅会打印其4个字节, 还会将紧邻的另外不属于float数据的4个字节也打印给转换打印
            使用e打印, 在处理long的时候, 仅将其中4个字节进行转换打印


scanf和printf的*修饰符
    scanf和printf都可以使用*修饰符, 但两者用法不太一样.
    scanf中, *表示跳过标记的项
    printf中, *表示匹配一个变量

    printf的*修饰符
        通过程序来指定字段的宽度
        如: 
            int width, number;
            printf("输入字段宽度: "); scanf("%d", &width);
            printf("输入需要保存的数字: "); scanf("%d", &number);
            printf("输出保存的数字: %*d \n", width, number);

            输出
            输入字段宽度: 4
            输入需要保存的数字: 3
            输出保存的数字:    3
        若用于浮点值指定精度和字段宽度, 那这个功能将会很实用.

    scanf的*修饰符
        让scanf跳过相应的输入项
            int number;
            scanf("%*d %*d %d", &number);   // 将会跳过前两个%d输入

            scanf("%*s");   // 将输入流中非空白字符读取掉


--------------------------------------------------------------

刷新缓冲区
    从缓冲区把数据发送到屏幕或文件被称为刷新缓冲区.
刷新输出
    C标准规定: 当缓冲区满, 遇到换行字符, 需要输入的时候, 把缓冲区中的内容发送到屏幕

可以使用 int fflush(FILE * fp); 缓冲内容输入fp指向, 指定fp, 刷新缓冲区.


本地化设置
    locale.h
    改变printf, scanf, strtod的行为, 让其符合设定的环境, 如在荷兰, 使用逗号表示小数点.
    设置后, 会在全局生效, 之后程序所有的工作都会符合所设置的环境.
 
    char *setlocale(int __category, const char *__locale);
    用于设置或返回当前的环境