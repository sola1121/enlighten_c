1. 字符串库 string.h
    字符数组操作
    不能把一个数组赋给另一个数组, 所以要通过循环把数组中的每个元素赋给另一个数组相应的元素.
    但对于字符串, 可以使用strcpy()和strncpy()函数来处理字符数组, 但对于其他类型的数组就不行.
    对于任意类型的数组, 可以使用string.h中内存处理函数, 如拷贝一个数组到另一个数组, 可以使用memcpy().

    由于这些函数直接处理内存块, 所以这些函数被设计用于处理任何数据类型, 所有他们的参数都是指向void指针.
    C允许把任何类型的指针赋给void*类型的指针.
    这会导致函数无法知道待拷贝的数据类型, 因此通常都会使用额外参数指明待拷贝的字节数.
    注意
        对数组而言, 字节数一般与元素个数不同.
        如一个有10个double类型的元素的数组, 要使用10*sizeof(double)指定字节数, 而不是10

    1) memchr()
        从给定数组中搜索匹配字符项

        void* memchr( const void* ptr, int ch, size_t count )
            第一个参数ptr, 指向要执行搜索的内存块
            第二个参数ch, 以int形式传递的值, 但是函数在每次字节搜索时是使用该值的无符号字符形式
            第三个参数count, 要被分析的字节数
            在参数ptr所指向的字符串的前count个字节中搜索第一次出现字符ch(一个无符号字符, 为int类型)的位置
            该函数返回一个指向匹配字节的指针, 如果在给定的内存区域未出现字符, 则返回 NULL

    2) memcmp()
        比较两个存储区

        int memcmp( const void* lhs, const void* rhs, size_t count );
            第一个参数, 左内存块lhs, 是一个指向内存块的指针
            第二个参数, 右内存块rhs, 是一个指向内存块的指针
            第三个参数count, 要被比较的字节数
            把存储区lhs和存储区rhs的前count个字节进行比较
            lhs小于rhs, 返回<0
            lhs等于rhs, 返回0
            lhs大于rhs, 返回>0

    3) memset, memset_s
        用一个值填满指定存储区
        注意
            对数组而言, 字节数一般与元素个数不同.
            如果要设置数组中10个double类型的元素, 要使用10*sizeof(double), 而不是10

        void *memset( void *dest, int ch, size_t count )
            第一个参数dest, 指向要填充的内存块
            第二个参数ch, 要被设置的值. 该值以int形式传递, 但是函数在填充内存块时是使用该值的无符号字符形式
            第三个参数count, 要被设置为该值的字节数
            复制字符ch(一个无符号字符, 为int类型)到参数dest所指向的字符串的前count个字符
            该值返回一个指向存储区dest的指针

        C11标准开始
        errno_t memset_s( void *dest, rsize_t destsz, int ch, rsize_t count )
            和memset()函数相似, 多了第二个参数 rsize_t destsz, 用以指明要填充的内存块大小, 且参数count类型也变为了rsize_t类型
            并且将会有返回值, 当成功返回0, 失败则返回非0值
            处理的结果为一个指向存储区dest的指针
        当dest是一个空指针
        当destsz或count比RSIZE_MAX大
        当count比destsz大(将会发生缓冲区溢出)
        会使该函数在运行时返回错误, 而且在存储ch于[dest, dest+destsz)之间每一个位置后, 会同时调用当前安装的约束处理函数

        如果dest所指向的字符数组大小在dest < count <= destsz, 其行为是未定义的; 换句话说, destsz的一个错误值不会暴露将会发生的缓冲区溢出
        和所有边界检查函数一样, 只有在执行阶段__STDC_LIB_EXT1__被定义, 并且需要用户在包含string.h头文件前定义__STDC_WANT_LIB_EXT1__为1, memset_s才能保证可用

        注意
            如果这个函数修改的对象在其剩余的生命周期内不再被访问, memset()函数可能会被优化掉(在as-if规则下).
            因此, 这个函数不能用来刷新内存. 例如用0来填充保存密码的数组.
            对于memset_s()函数来说, 这种优化是被禁止的. 其被保证定会执行内存写入.


    4) memcpy, memcpy_s, memmove, memmove_s
        拷贝一个存储区内容到另一个存储区
        注意
            对数组而言, 字节数一般与元素个数不同.
            如果要拷贝数组中10个double类型的元素, 要使用10*sizeof(double), 而不是10

        void* memcpy( void *restrict dest, const void *restrict src, size_t count )
            第一个参数dest, 指向用于存储复制内容的目标数组, 类型强制转换为 void* 指针
            第二个参数src, 指向要复制的数据源, 类型强制转换为 void* 指针
            第三个参数count, 要被复制的字节数
            从存储区src复制count个字节到存储区dest
            该函数返回一个指向目标存储区dest的指针

        restrict类型限定符要求dest与src指向不同的内存地址, 即memcpy()假设两个内存区域之间没有重叠
        如果两个区域出现重叠, 其行为是未定义的, 这意味着该函数可能正常工作, 也可能失败
        编译器不会在本不该使用memecpy()时禁止使用, 交由程序员判断

        C11标准开始
        errno_t memcpy_s( void *restrict dest, rsize_t destsz, const void *restrict src, rsize_t count )
            和memcpy()函数相似, 多了第二个参数 rsize_t destsz, 表明所要修改的目标中的最大字节数, 通常是目标对象的大小, 且参数count类型也变为了rsize_t类型
            并且将会有返回值, 成功返回0, 失败则返回非0值, 在错误时, 如果dest不是一个空指针, 并且destsz有效, 向目标数组写入destsz个零字节
            处理的结果为一个指向存储区dest的指针
        当dest或src是一个空指针
        当destsz或count比RSIZE_MAX大
        当count比destsz大(将会造成缓冲区溢出)
        当目标地址和源地址重叠
        会使该函数在运行时返回错误, 并在dest和destsz有效的前提下使整个目标从[dest, dest+destsz)被清零, 同时调用当前安装的约束处理函数

        如果dest所指向的字符数组大小在dest < count <= destsz, 其行为是未定义的; 换句话说, destsz的一个错误值不会暴露将会发生的缓冲区溢出
        和所有边界检查函数一样, 只有在执行阶段__STDC_LIB_EXT1__被定义, 并且需要用户在包含string.h头文件前定义__STDC_WANT_LIB_EXT1__为1, memset_s才能保证可用

        注意
            memcpy()函数可以用来设置由分配函数得到的有效对象.
            memcpy()函数是内存到内存拷贝的的最快库例程. 通常比strcpy()函数更有效率, strcpy()函数必须要先扫描其要拷贝或memmove的数据, memcpy()函数必须要对重叠的输入做好预防措施
            一些C编译器适合的内存拷贝循环转换为memcpy()调用.
            当严格的别名禁止将同一内存作为两种不同类型的值进行检查时, 可以使用memcpy()来转换这些值.

        void* memmove( void* dest, const void* src, size_t count )
            第一个参数dest, 指向用于存储复制内容的目标数组, 类型强制转换为 void* 指针
            第二个参数src, 指向要复制的数据源, 类型强制转换为 void* 指针
            第三个参数count, 要被复制的字节数
            从src复制count个字符到dest, 但是在重叠内存块这方面, memmove()是比memcpy()更安全的方法.
            memmove()拷贝过程类似于先把所有字节拷贝到一个临时缓冲区, 然后再拷贝到最终目的地, 所以对于重叠的拷贝区域, 也不会出现大问题.
            该函数返回一个指向目标存储区dest的指针

        C11标准开始
        errno_t memmove_s(void *dest, rsize_t destsz, const void *src, rsize_t count)
            和memmove()函数相似, 多了第二个参数 rsize_t destsz, 表明所要修改的目标中的最大字节数, 通常是目标对象的大小, 且参数count类型也变为了rsize_t类型
            并且将会有返回值, 成功返回0, 失败则返回非0值, 在错误时, 如果dest不是一个空指针, 并且destsz有效, 向目标数组写入destsz个零字节
        当dest或src不是空指针
        当destsz或count比RSIZE_MAX大
        当count比destsz大(将会造成缓冲区溢出)
        会使该函数在运行时返回错误, 并在dest和destsz有效的前提下使整个目标从[dest, dest+destsz)被清零, 同时调用当前安装的约束处理函数

        如果dest所指向的字符数组大小在dest < count <= destsz, 其行为是未定义的; 换句话说, destsz的一个错误值不会暴露将会发生的缓冲区溢出
        和所有边界检查函数一样, 只有在执行阶段__STDC_LIB_EXT1__被定义, 并且需要用户在包含string.h头文件前定义__STDC_WANT_LIB_EXT1__为1, memset_s才能保证可用

        注意
            memmove()函数可以用来设置由分配函数得到的有效对象.
            尽管被指定为 "as if" 使用了一个临时缓冲区, 但这个函数的实际实现并不产生开销或重复复制或需要额外的内存.
            一个常见的方法(glibc和bsd libc)是, 如果目的地在源码之前开始, 就从缓冲区的开头向后复制字节, 否则就从末端向前复制, 当没有任何的重叠的时候, 就退回到更有效的memcpy()函数的方式.
            当严格的别名禁止将同一内存作为两种不同类型的值进行检查时, 可以使用memmove()来转换这些值.


    5) memccpy
        拷贝一个存储区到另一个, 并在拷贝到指定符号的时候停止

        C23标准开始
        void *memccpy(void * restrict dest, const void * restrict src, int c, size_t count)
            第一个参数dest, 目标拷贝存储区
            第二个参数src, 要被赋值的数据源
            第三个参数c, 终止字符, 将会先被转换为无符号字符
            第四个参数count, 要被复制的字节数
            从src赋值count个字符或者复制到c给dest, 当满足给定长度, 或指定字符时候满足任一停止复制, 当达到c时候, c也会被赋值
            该函数调用成功, 返回指向目标存储区dest的指针, 注意是void *类型的, 如果不成功, 返回NULL


        如果访问发生在dest数组结束之后, 行为不定.
        如果两个区域出现重叠, 行为不定.
        如果dest或src是一个无效或空指针, 行为不定.

        该功能与POSIX memccpy相同.

        memccpy(dest, src, 0, count);的行为和strncpy(dest, src, count)的行为相同
        除了前者返回一个指向写入的缓冲区的指针, 并且不会对目标数组进行零填充. 因此, memccpy对于高效连接多个字符串非常有用.
