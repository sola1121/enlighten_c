在stdlib.h 标准库中, 动态内存管理函数

    所有通过动态内存分配创建的内存, 其存储期都是从创建时起, 到使用free()释放内存为止.
    对应的为动态存储期.
    要记住使用free()释放所创建的内存块.

    通过malloc, calloc, realloc 动态分配的内存, 默认为0.


分配指定大小内存 malloc() 函数

    void* malloc (size_t size);
        分配size字节的未初始化内存块
        如果分配成功, 返回数组的地址, 否则返回NULL

    malloc返回动态分配内存块的首地址. 可以把该地址赋值给一个指针变量, 并使用指针访问这块内存.
    malloc成功后返回的为void*类型的指针, 该类型相当于一个通用指针. 将指向void的指针赋给任意类型的指针可以不用考虑匹配类型的问题.

    例
        double * pt = (double *) malloc(sizeof(double)*31);   // 动态的创建一块具有31个double长度的内存块, 并将返回的首地址赋值给pt
    注意
        在C中, 不一定要使用强制类型转换(double*), 但是在C++中必须使用. 为了能兼容C++, 和理解代码, 推荐显式的将转换写出来.
    数组名是该数组首元素的地址. 使用指针指向这个块的首元素, 便可像使用数组名一样使用他.
    因此, pt既可以使用指针表示法引用内容数据, 也可以使用数组表示法引用内容数据.
        *(pt+3);
        pt[3];
    以上方式为创建动态数组(dynamic array). 这种数组和普通数组不同, 可以在程序运行时选择数组的大小和分配内存.


分配对应数目个指定大小的内存 calloc() 函数 

    void* calloc (size_t num, size_t size);
        为内含num个成员的数组分配字节空间, 每个元素占size字节大
        空间中的所有位都初始化为0
        如果分配成功, 该函数返回数组的地址, 否则返回NULL

    例
        double * pt = (double*) calloc(31, sizeof(double));


为指定地址重新分配指定大小内存 realloc() 函数

    void* realloc (void* ptr, size_t size);
        把ptr指向的内存块大小改为size字节, size字节内的内存块内容不变.
        该函数返回块的位置, 他可能被移动.
        如果不能重新分配空间, 函数返回NULL, 原始块不变
        如果ptr为NULL, 其行为与调用带size参数的malloc()相同
        如果size是0, 且ptr不是NULL, 其行为与调用带ptr参数的free()相同


释放指定地址所分配的内存 free() 函数

    void free (void* ptr);
        释放ptr指向的空间, ptr应该是之前调用malloc, calloc, realloc返回的值 
        或者ptr也可以是空指针NULL, 当为空指针时, 该函数什么也不做
        如果ptr为其他值, 其行为是未定义的

    free()只能用来释放由malloc, calloc, realloc创建的内存. 不能用free()释放通过其他方式(如声明一个数组)分配的内存.
    一些操作系统在程序结束时会自动释放动态分配的内存, 但有的系统不会, 所以保险起见, 一定要手动free()
    不能使用free()释放同一块内存多次

    free()的参数为void*, 指向void的指针, 可以兼容不同的指针类型, 因此传入的被释放指针可以不用显式转换.

    粗心的代价
        void create_value(size_t len){
            double * value = (double*) malloc(sizeof(double)*len);
            ...
            /* free(value) */
        }
        每次调用create_value(len), 就会分配一块len字节大小的, 函数完成, 其块作用域的变量value消失, 但是没有free()回收所创建的内存块
        这块被分配的内存就无法在被引用, 从而释放, 而永远存在.
        当调用的次数足够多, 这些无法释放的内存将会占满系统内存.
        这样的问题就是内存泄漏(memory leak).


存储类别和动态内存分配
    系统为程序分配的内存由三部分组成
        用于供具有外部链接, 内部链接, 无链接的静态变量使用
        用于供自动变量使用
        用于供动态内存分配
    
    静态存储类别所用的内存数量在编译时确定, 只要程序还在运行, 就可访问存储在该部分的数据.
    静态存储类别的变量在程序开始执行时被创建, 在程序结束时销毁.

    自动存储类别的变量在程序进入变量定义所在块时存在, 在程序执行离开块时消失. 
    随着程序调用函数和结束, 自动变量所用的内存数量也相应地增加和减少.
    这部分内存通常作为栈来处理, 即遵循先入后出(FILO)

    动态分配的内存在调用相应的动态内存分配函数时存在, 在调用free()后释放.
    这部分内存由程序员管理, 而不是一套规则. 所以内存块可以在一个函数中创建, 在另一个函数中销毁.
    动态内存分配的未使用内存块分散在已使用的内存块之间. 因为可能分配到不同时期回收的自动变量的内存.
    使用动态内存通常比使用栈内存慢.


--------------------------------------------------------------

三种创建数组的方法

    声明数组时, 用常量表达式表示数组的维度, 用数组名访问数组的元素. 可以用静态内存或自动内存创建这种数组.

    声明变长数组(C11可选特性), 用变量表达式表达数组的维度, 用数组名访问数组的元素. 具有这种特性的数组只能在自动内存中创建.

    声明一个指针, 调用malloc, calloc或realloc, 将其返回值赋给指针, 使用指针访问数组的元素. 该指针可以是静态的或自动的.


变长数组(VLA)与动态内存分配所创建数组的对比

    变长数组是自动存储类型. 因此, 程序在离开变长数组定义所在块时, 变长数组占用的内存空间会被释放.

    用如malloc创建的数组, 在显式调用free()释放以前, 一直存在.
    因此, 动态内存分配所创建的数组不必局限在一个函数内访问.
    通常, 可以在一个函数中动态创建一个数组并返回指针, 供主调函数访问.
    然后主调函数在末尾调用free()释放之前被调用函数分配的内存.


动态创建一个二维数组
    首先得了解指向二维数组的指针, 即数组指针
        声明一个数组指针
            int (*pt)[SIZE];
        圆括号先执行*指针运算符, pt变为指针变量, 再执行[SIZE]下标运算符, 表明指针pt指向SIZE大小的相应类型数组.

        声明一个二级指针
            int **ppt;
        *指针运算符先执行一次, ppt变为指针变量, 再执行*指针运算符, 表明ppt指针int*, 即ppt指针变量的存储的数据是另一个指针变量的地址.
    
        两者对比
            数组指针是一个指针, 指向一个含有多个元素的指定类型数组
            二级指针是一个指针, 指向一个指定类型的指针
        两者的类型不一样, 这也是为什么不能使用二级指针指向二维数组进行操作的原因

    使用指针数组
        int (*matrix)[SIZE] = (int (*)[SIZE]) malloc(ROW*COLOMN*sizeof(int));
        或
        int (*matrix)[SIZE] = (int (*)[SIZE]) calloc(ROW*COLUMN, sizeof(int));

        为数组指针为其指向的数组的所有元素分配对应类型大小的内存即可
        在这里也可以反映出一个二维数组, 其在内存中就是一个连续的内存块, 本质还是一维数组.


    使用二级指针
        int ** matrix;   // 声明一个二级指针

        matrix = (int **) malloc(ROW * sizeof(int*));
        或
        matrix = (int **) calloc(ROW, sizeof(int*));

        for (int rw=0; rw<ROW; rw++)
            matrix[rw] = (int **) malloc(COLUMN*sizeof(int));

        声明一个二级指针, 只在内存中开辟了该指针大小的内存, 且类型为int**, 不论类型和内存大小, 都不能满足二维数组

        接下来使用malloc或calloc为这个二级指针开辟可以保存多个int指针变量地址的内存, 
        即为该二级指针指向多个的int*开辟内存, 对应用来记录二维数组每行的首地址, 所以应该开辟ROW个.

        再使用一个循环, 循环每行, 为每行中int元素开辟内存, 对应有每行对应有COLUMN个


    使用二级指针, 打包进函数并返回

        int ** create_matrix(size_t row, size_t column){
            // 分配存储指针的内存
            int ** matrix = (int**) malloc(row*column*sizeof(int*));

            // 为每行数组分配内存
            for (size_t rw=0; rw<row; rw++)
                matrix[rw] = (int*) malloc(column*sizeof(int));
            
            return matrix;
        }

        int ** create_matrix2(size_t row, size_t column){
            // 分配存储指针的内存
            int ** matrix = (int**) calloc(row*column, sizeof(int*));

            // 为每行数组分配内存
            for (size_t rw=0; rw<row; rw++)
                matrix[rw] = (int*) calloc(column, sizeof(int));

            return matrix;
        }

    判断内存是否分配成功
        因为动态内存分配失败了, 会返回空指针NULL, 所以只需要判断是否为空指针

        if (matrix==NULL){
            perror("内存分配失败.");
            eixt(1);
        }