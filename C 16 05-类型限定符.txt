const 关键字, 使变量具有恒常性(constancy)

volatile 关键字, 使便变量具有易变性(volatility)

const与volatile两个关键字创建的类型是限定类型(qualified type)

restrict 限定符, 用于提高编译器优化

_Atomic 限定符, 为C11可选支持项, 在stdatomic.h 中声明, 用于支持并发程序设计

这些类型限定符是幂等的(idempotent), 就是可以在一条声明中多次使用同一个限定符, 多余的限定符将被忽略.
    const const const int num = 3;   // 与 const int num = 3; 一样
有了这个属性, 在使用typedef时很方便
    typedef const int ConstInt;
    const ConstInt num = 3;


--------------------------------------------------------------

const 类型限定符
    const限定数据在程序运行时不能改变, 即变为不可修改的左值.

    应用于一般变量
        const int num;   // 限定num为不可修改的左值
        num = 5;   // 不允许
        可以初始化const限定的变量
        const int num = 3;
        num = 5;   // 不允许

    应用于数组
        const int array[4] = {11, 22, 33, 44};
        array[0] = 00;   // 不允许

    应用于指针
        根据const在指针声明时的位置, 需要区分是限定指针本身为const, 还是限定指针指向的值为const.
        当限定的为指针变量本身为const, 则指针变量本身不能改变, 而其指向的数据可以改变
            double * const pt;   // const指针变量

            pt = &num;   // 改变指针变量, 不允许

        当限定的为指针指向的值为const, 则指针指向的数据不能改变, 而指针变量本身可以改变
            double const * pt;
            或
            const double * pt;   // pt指向一个double类型的const值

            *pt = 3.14;   // 改变指针指向的值, 不允许
        
        记忆
            从右向左看, 限定符const如果离指针变量名近, 则是限定指针本身
            从右向左看, 限定符const如果离类型名近, 则是限定指针指向的对应类型变量

            const放在*指针运算符右边, 限定指针变量不能改变
            const放在*指针运算符左边, 限定指针指向的数据不能改变

        指针变量本身不能改变, 指针变量指向的值也不能改变
            double const * const pt;
            或
            const double * const pt;

        const应用于指针的时候, 最常用的是声明为函数形参的指针. 用来保证形参指向的原始数据不被改变.
            void output(const int array[], int len);  

    对全局变量使用const
        全局变量具有文件作用域, 内部链接或外部链接, 静态存储期.
        从定义处开始就对所在的文件或多个文件中的函数可见, 一直到程序执行完毕.

        这样做暴露了数据, 程序的任何部分都能更改数据. 此时如果将数据设置为const, 就可以避免不必要的更改.

        可以创建const变量, const数组, const结构体.

        在文件共享const数据的时候, 可以采取两种策略

            遵循外部变量的常用规则, 即在一个文件中使用定义式声明, 在其他文件中使用引用式声明
                /* file1.c */
                const double PI = 3.141592;
                
                /* file2.c */
                extern const double PI;

            把const变量放在一个头文件中, 然后在其他文件中包含该头文件
                /* head.h */
                static const double PI = 3.141592;

                /* file.c */
                # include "./head.h"
            当作为头文件中的全局变量的时候, 应该使用static指明其为内部链接.
            这样在多个文件包含该头文件的时候, 该全局变量不会在这多个文件中有相同的标识符的定义式声明. C标准不允许这样做.
            而让该全局变量只为其所在的文件提供.


volatile 类型限定符

    volatile表明限定的数据除了被当前程序修改外还可以被其他进程修改.
    该限定符的目的是警告编译器不要进行假定的优化.

    通常都被用于硬件地址以及在其他程序或同时运行的线程中共享数据.
    例如
        一个地址上可能存储着当前的时钟时间, 无论程序做什么, 地址上的值都随时间的变化而变化.
        或者一个地址, 用于接受另一台计算机传入的信息.

    volatile变量
        volatile int loc1;   // loc1 是一个易变位置

    指向volatile变量的指针
        volatile int * pt_loc;   // pt_loc是一个指向易变位置的指针
    
    如何进行优化
        value1 = x;
        ...
        value2 = x;

        较现代的编译器会注意到以上代码使用了两次x, 且假定x的值没有被改变.
        于是编译器把x的值临时存储在寄存器中, 然后在value2需要使用x时, 才从寄存器中(而不是从x的原始内存位置)读取x的值, 以节约时间.
        这个过程被称为高速缓存(caching).

        通常这是一个不错的优化, 但是如果一些在其他代理在以上两条语句间更改了x的值, 就不能这样优化.
        所以使用volatile告诉编译器, 还是从原先的地址来获取x的值.
        
    const和volatile共同限定一个值
        const和volatile一起限定一个变量, 表示在当前程序不可修改的变量, 在其他代理会将其修改.
        例如
            通常用const把硬件时钟设置为程序不能修改的变量, 但是可以通过代理更改.
        只能在声明的同时使用这两个限定符, 他们的顺序不重要
        如
            const volatile int loc;
            volatile cosnt int * pt_loc;


restrict 类型限定符

    restrict只能用于指针, 表明限定的指针是访问他所指向的数据的唯一途径.
    该限定符的目的是为了方便编译器设置优化方案, 以更好地支持计算.

    应用在指针变量上
            int * restrict strict_pt = (int *) malloc(10 * sizeof(int));
        使用restrict表明strict_pt是访问malloc()所分配内存的唯一且初始的方式.
        当在同一个块中, 有
            {
                strict_pt[i] += 3;
                ...
                strict_pt[i] += 5;
            }
        因为声明了strict_pt为访问他所指向的数据块的唯一且初始的方式, 所以编译器可以把涉及strict_pt的两条语句替换为
            {
                ...
                strict_pt[i] += 8;
            }
        而对于普通的指针, 因为不知道除该指针外是否还有其他指针指向相同数据块, 从而对数据进行改变, 所以编译器不会这样优化

    应用在函数形参的指针上
        如果将restrict限定用在函数形参上, 则编译器可以假定在函数体内其他标识符不会修改该指针指向的数据.
        而且编译器可以尝试对其优化, 使其不做别的用途.

        C标准库 string.h 中, 
            void * memcpy(void * restrict dest, const void * restrict src, size_t n);
                将n字节长的内容从一个内存地址复制到另一个地址; 如果两个地址存在重叠, 则最终行为未定义

            void * memmove(void *dest, const void *src, size_t n);
                将n字节长的内容从一个内存地址复制到另一个地址; 与memcpy不同的是它可以正确作用于两个存在重叠的地址

            这两个函数都是从位置src把n个字节拷贝到dest. memcpy()函数要求两个位置不重叠, 但是memove()函数没有这样的要求.
            声明src和dest为restrict说明这两个指针都是访问相应数据的唯一方式, 所以不能访问相同块的数据. 者满足memcpy()无重叠的要求.
            memmove()函数允许重叠, 他在拷贝数据时候得更小心, 以防在使用数据之前就先覆盖了数据.


_Atomic 类型限定符

    并发程序设计把程序执行分成可以同时执行的多个线程.

    C11 通过包含可选头文件stdatomic.h 和threads.h, 提供了一些可选的(不是必须实现)管理方法.
    值得注意的是, 要通过各种宏函数来访问原子类型.
    当一个线程对一个原子类型的对象执行原子操作时, 其他线程不能访问该对象.
    如
        _Atomic int hogs;   // hogs是一个原子类型的变量
        atomic_store(&hogs, 12);   // stdatomic.h中的宏
    这里hogs中存储12是一个原子过程, 其他线程不能访问hogs.


--------------------------------------------------------------

C99允许把存储类别说明符static和类型限定符放在函数原型和函数头的形式参数的初始方括号中.

static 除了变名静态存储变量的作用域或链接外, 还可以用来在函数原型声明中表明数组元素至少的个数
    double stick(double array[static 20]);
这种用法表明, 函数调用中的实际参数应该是一个指向数组首元素的指针, 且该数组至少有20个元素.
这种用法的目的是让编译器使用这些信息优化函数的编码.

函数原型中指向数组的指针参数在使用类型限定符时候, 可以将类型限定符放在方括号中
如, 以下两者等价
    void fun(int * const c_pt, int * restrict r_pt);
    void fun(int c_pt[const], int r_pt[restrict]);
c_pt是一个指向int的const指针, 即不能修改指针变量本身的指向, 但可以修改其指向数据的值
r_pt是一个指向int的被restrict修饰的指针, 即该指针变量是访问指向内存块数据的初始且唯一方式
