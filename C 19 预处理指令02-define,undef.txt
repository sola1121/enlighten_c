1. 宏定义
    指令结构
        #define 宏 替换体   // 定义宏及其替换内容
        #define 宏(参数表) 替换体   // 定义带参数的宏及其替换内容

        #undef 宏   // 解除定义的宏

    作用范围
        #define 指令出现在程序中的函数外面, 宏名的有效范围为该指令行起到本源文件结束.
        通常, #define 指令写在文件开头, 函数之前, 作为文件一部分, 在整个文件范围内有效. 可以用#undef 终止宏名的定义.
        #undef 指令取消的已定义的#define指令, 在之后便没有对应的宏名可使用, 但是依然可以再重新定义.

    宏的命名规则
        宏的名称中不允许有空格, 而且必须遵循C变量的命名规则: 只能使用字符, 数字, 下划线字符, 而且首字符不能是数字, 字符长度不能超过64位
        宏名习惯上由大写字母表示, 以便避免与程序中变量名混淆.

    一旦预处理器在程序中找到宏的实例后, 就会用替换体代替该宏
    从宏变成最终替换文本的过程称为宏展开(macro expansion). 注意宏展开后只是替换文本, 不会对其中的运算进行计算, 这一步是在编译的时候进行的

    注意
        宏定义只是用宏名代替一个字符串, 也就是只做简单的替换, 构成C代码的一部分, 但是不会进行正确性检查.
        宏定义不是C语句, 不必在行末加分号. 如果有了分号, 则会连带分号一起进行置换.
        在进行宏定义的时候, 可以引用以定义的宏名, 即可以层层置换.
        宏定义与定义变量的含义不同, 不分配存储空间. 不带参数的宏定义只作简单的字符替换.
        程序中用双撇号括起来的字符串内的字符, 即使与宏名相同, 也不进行置换.

    1) 使用#define 定义类对象宏object-like macro  
        使用#define 定义用来代表值的宏, 也叫做明示常量manifest constant, 或符号常量
        宏可以表示任何数值, 字符串, 甚至可以表示整个C表达式
            # define and &&
            # define or ||
            # define one 1
            if (one and one) puts("宏表示一个数字值和逻辑运算符.");

            # define format "定义一段字符串%s\n"
            printf(format, "格式化输出");
        
            # define format2 "反斜杠\
            把定义延续到下一行, 但要注意第一行左对齐, 不然会将行前空格算作字符串的一部分" 

            # define STR1 "字符串内容1"
            # define STR2 "字符串内容2"
            # define STR STR1 STR2   // 拼接STR1和STR2字符串内容

        宏可以嵌套其他宏
            # define PI 3.141592
            # define RAD 7
            # define AREA RAD*RAD*PI

        用作记号
            将宏的替换体看作记号token型字符串, 而不是字符型字符串.
            # define FOUR 2*2
            # define SIX 2 * 3   // 替换体中有空格

            当替换体中有多个空格的时候, 字符型字符串和记号型字符串的处理方式不同.
            1. 如果预处理器将该替换体解释为字符型字符串, 将用2 * 3替换SIX, 即额外的空格是替换体的一部分.
            2. 如果预处理器把该替换体解释为记号型字符串, 则用三个记号2, *, 3, 分别由单个空格分隔开, 用这三个记号来替换SIX, 即空格视为分隔符.
            不同的C编译器将宏替换体可能视为字符型字符串, 或记号型字符串, 但最终在C编译器处理时, 并不影响结果

        重新定义常量
            假设已有定义Limit定义为20, 稍后在该文件中又把他定义为25, 这个过程称为重定义常量.
            不同的实现采用不同的重定义方案
                1. 除非新定义与旧定义相同, 否则有些实现会将其视为错误. 如ANSI标准中采用
                2. 另外一些实现允许重定义, 但是会给出警告. 如gcc编译器采用中采用
            如
                # define LIMIT 4 * 5
                # define LIMIT 4 * 5   // 新定义与旧定义相同, 满足第一条的重定义
                # define LIMIT 4*5   // 新定义与旧定义不同, 满足第二条的重定义, 编译警告
                # define LIMIT 20   // 新定义与旧定义不同, 满足第二条的重定义, 编译警告

    2) 使用#define 定义类函数宏function-like macro
        类函数宏定义在宏名后跟一个圆括号, 圆括号中可以有一个或多个参数, 随后这些参数出现在替换体中.
            # define 宏名(参数表) 替换体
        如
            # define SQUARE(X) X*X

        看上去这像是函数调用, 但其行为与函数调用完全不同. 含参数的宏只是将替换体中的参数替换为参数表中所给值. 
        在程序中带实参的宏, 按#define 指令行中指定的替换体从 左→右 进行置换. 
        如果替换体字符串中包含宏中的形参, 则将程序语句中相应的实参(可以是常量,变量,表达式)代替形参. 
        如果宏定义中的替换体字符串中的字符不是参数字符, 则保留.
        这样就形成了置换后的替换体字符串.
        这种简单的替换方式, 可能会对一些运算的照成影响.
        如
            # define PI 3.141592
            # define AREA(R) PI*R*R
            ...
            area = AREA(radius);
        在对area的赋值语句进行替换的时候, 找到#define指令中的AREA(R), 将AREA(radius)中的实参字符radius代替宏定义中的PI*R*R中的形参R. 得到PI*radius*radius.
        如果给出 area = AREA(x + y) / 2;
        则替换后的为 area = PI*x + y*x + y / 2;
        这可能并不是想要的替换结果, 这就需要在定义的时候加上括号 # define AREA(R) (PI*(R)*(R))
        对于最开始的例子, 应该定义为 # define SQUARE(X) (X*X)
        注意:
            在定义宏时, 在宏名与带参数的括号之间不应该加空格, 否则会将空格以后的字符都做为替代字符串的一部分
            如
                # define AREA (R) PI*(R)*(R)   // 在宏和括号之间加了空格, 将会把宏后的视为替换体, 在替换后造成不期望的错误
                这样会将AREA看作符号常量, AREA后面的(R) PI*(R)*(R)将被用作替换字符串

        类函数宏与函数的区别
            函数调用时, 先求出实参表达式的值, 然后代入形参. 而使用带参数的宏只是进行字符替换
            函数调用是在程序运行时处理的, 为形参分配临时的内存单元. 而宏置换则是在预处理阶段进行的, 在置换时并不分配内存单元, 不进行值的传递处理, 也没有返回值概念
            对函数中的实参和形参都要定义类型, 二者的类型要求一致, 如不一致, 应进行类型转换. 而宏不存在类型问题, 宏名无类型, 他的参数也无类型, 只是一个符号代表, 置换时, 代入指定的字符串即可. 
            定义宏时, 字符串可以是任何类型的数据
            调用函数只可得到一个返回值, 而用宏可以设法得到几个结果
            使用宏次数越多时, 宏展开后源程序变长, 因为每展开一次都是代码量增长, 而函数调用不会使源程序变长
            宏替换不占运行时间, 而函数调用则占运行时间(分配单元, 保留现场, 值传递, 返回)

        结论1, 必要时应该使用足够多的圆括号来确保运算和结合的正确顺序.

        自增, 自减行为的未定义
            如果给出 square = SQUARE(++x);
            则替换后的为 square = ++x*++x;
            标准并未对这类运算规定顺序, 如果给定x=5; 则在运算时可能是 6*7=42, 7*6=42, 7*7=49.

        结论2, 避免使用自增减作为宏参数.

    3) 使用#undef 取消#define定义的宏
        # define LIMIT 255
        ...
        # undef LIMIT   // 移除#define定义的宏
        使用undef移除LIMIT后, 就可以重新将LIMIT定义为一个新的值了.
        即使原来没有定义LIMIT, 取消LIMIT的定义仍然有效.
        如果想使用一个名称, 又不确定之前是否使用过, 为了安全起见, 可以用#undef取消该名称的定义.

        (1) 预处理器如何看已定义和未定义
            预处理器在识别标识符时, 遵循C命名规则, 标识符可以由大写字母, 小写字母, 数字, 下划线字符组成, 且首字符不能是数字.
            当预处理器在预处理指令中发现一个标识符时, 他会把该标识符当作已定义的或未定义的.
            已定义表示由预处理定义.
            如果标识符是同一个文件中由前面的#define 指令创建的宏名, 而且没有用#undef指令关闭, 那么该标识符就是已定义.
            如果该标识符不是宏, 假设是一个文件作用域的C变量, 那么标识符对预处理器而言就是未定义.

            注意
                #define宏的作用域从他在文件中的声明处开始, 直到用#undef指令取消宏为止, 或延伸至文件尾.
                如果宏通过头文件引入, 那么#define在文件中的位置取决于#include指令的位置.

    4) 用宏参数创建字符串: #运算符
        C允许在字符串中包含参数.
        #号作为一个预处理运算符, 可以把记号转换成字符串.
        如
            # define PSQR(X) printf("square = " #X " * " #X " 运算结果为: %d\n", ((X)*(X)))
        通过#将字符串中的X转换为宏参数表中的X表达式的字符串形式
        即如果参数为变量为n, 则转换为字符串n, 如果参数为表达式n1+n2, 则转换为字符串n1+n2, 这个过程称为字符串化stringizing.
        最后, 通过ANSI C字符串的串联特性将这些字符串与printf()语句其他字符串组合, 生成最终的字符串.
        
    5) 预处理器粘合剂: ##运算符
        与#运算符类似, ##运算符可用于类函数宏的替换部分. 而且, ##还可用与对象宏的替换部分.
        ##运算符把两个记号组合成一个记号.
        如
            # define XNAME(N) X ## N
        XNAME(3) 将字符X和参数N粘合, 形成新的字符X3, 在C源码中使用, 就是变量名为X3的变量

    6) 变参宏: ... 和 __VA_ARGS__
        一些函数, 如printf()函数, 可以接受数量可变的参数. 在stdvar.h头文件中声明了相应的工具, 可以自定义带可变参数的函数.
        通过把宏参数表中最后的参数写成省略号(三个点...)来实现这一功能.
        这样, 预定义宏__VA_ARGS__可用在替换部分中, 表明省略号代表什么.
        如
            # define PR(...) printf(__VA_ARGS__)
            // 调用
            PR("参数%d\n", num);
        __VA_ARGS__展开为二个参数, "参数%d\n" 和 num, 展开后的代码是printf("参数%d\n", num);

    7) 使用例子
        (1) 一般将宏用来代表简短的表达式比较合适
            例子
                # define PI 3.141592
                # define CIRCLE(R) printf("圆的周长:%lf, 圆的面积:%lf\n", (2*PI*(R)), (PI*(R)*(R)))
                ...
                CIRCLE(redius);

        (2) 拼接字符串逐级使用宏
            例子
                # define PR printf
                # define INTEGER "输出: %d"
                # define ENDLN "\n"

                # define PRINT_1 INTEGER ENDLN
                # define PRINT_2 INTEGER INTEGER ENDLN
                ...
                int a=1, b=2;
                PR(PRINT_1, a);
                PR(PRINT_2, a, b);
                ...
                可以使用puts(PRINT_1); 来查看拼和置换后的字符串

                若使用#undef ENDLN 释放, 那么PRINT_1和PRINT_2 就都没法用了

                可以发现, 如果是纯字符型的, 原内容需使用双撇号括起来, 这样会自动拼接
            
        (3) #运算符, ##运算符, 变参宏配合使用
            例子
                # define XNAME(n) X ## n
                # define PR(X) printf("变量名: " #X ", 对应值为: ", __VA_ARGS__)
                ...
                int XNAME(1) = 32;
                PR(XNAME(1), "%d\n", XNAME(1));


2. 宏与函数的选择
    使用宏比使用普通函数复杂一些, 稍有不慎会产生奇怪的副作用.
    宏和函数的选择实际上是时间和空间的权衡.

    宏生成内联代码, 即在程序中生成语句.
    如果调用20次宏, 即在程序中插入20行代码.
    如果调用20次函数, 程序中只有一份函数语句的副本, 所以节省了空间.
    然而另一方面, 程序的控制必须跳转至函数内, 随后再返回主调程序, 这比内联代码花费更多的时间.

    宏的一个优点是, 不用担心变量类型, 因为仅处理字符串, 不是实际值, 所以只要能用于替换体字符串所表示的表达式, 不区分类型.

    需要注意的是
        1) 宏名中不允许有空格, 但是在替换字符串中可以有空格. ANSI C允许在参数表中使用空格.
        2) 用圆括号把宏的参数和整个替换体括起来. 这样能确保被括起来的部分在运算中的完整性以确保运算的顺序.
        3) 用大写字母表示宏函数的名称. 这不仅是惯例, 而且还能提醒使用者宏可能产生的副作用.
        4) 如果打算使用宏来加快程序的运行速度, 那么首先要确定使用宏和使用函数是否会导致较大的差异.
           在程序中只使用一次的宏无法明显改善程序的运行时间. 在嵌套循环中使用宏更有助于提高效率.
           许多系统提供程序分析器以帮助程序员压缩程序中最耗时的部分.