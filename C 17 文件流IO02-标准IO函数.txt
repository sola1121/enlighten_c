绝大多数C实现都是提供底层I/O和标准高级I/O. 
因为ANSI C库考虑到可移植性, 包含了标准I/O包, 但是未提供底层I/O.
标准I/O包自动创建输入和输出缓冲区以加快数据传输.
标准I/O都在C标准库stdio.h 头文件中声明.


标准I/O的机理

    通常使用标准I/O的第一步都是调用fopen()打开文件.
    调用fopen()不仅打开一个文件, 还创建了一个缓冲区, 在读写模式下会创建两个缓冲区, 以及创建一个包含文件和缓冲区数据的结构体对象.
    完成后fopen()返回一个指向该结构体对象的指针, 以便其他函数知道如何找到该结构.
    这一个过程, 描述为fopen()"打开一个流".
    如果以文本模式打开文件, 就获得一个文本流, 如果以二进制模式打开文件, 就获得一个二进制流.

    如在VC6 中的FILE 结构体定义
        #ifndef _FILE_DEFINED
        struct _iobuf {
        　　　　char *_ptr;      //文件输入的下一个位置
        　　　　int _cnt;        //当前缓冲区的相对位置
        　　　　char *_base;     //指基础位置(即是文件的起始位置) 
        　　　　int _flag;       //文件标志
        　　　　int _file;       //文件描述符id
        　　　　int _charbuf;    //检查缓冲区状况,如果无缓冲区则不读取
        　　　　int _bufsiz;     //文件缓冲区大小
        　　　　char *_tmpfname; //临时文件名
            };
        typedef struct _iobuf FILE;
        #define _FILE_DEFINED
        #endif
    这个结构通常包含一个指定流中当前位置的文件位置指示器. 
    除此外他还包含错误和文件结尾的指示器, 一个指向缓冲区开始处的指针, 一个文件标识符, 一个计数用以统计实际拷贝进缓冲区的字节数.

    stdio.h中一些处理FILE类型, 即处理文件流的函数, 一调用这些函数, 文件中的缓冲大小数据块就被拷贝到缓冲区中.
    缓冲区的大小因实现而异, 一般是512字节或其倍数, 随着计算机硬盘容量越大, 缓冲区大小也越大.
    最初调用函数, 除了填充缓冲区外, 还要设置FILE对象所指向的机构中的值. 尤其要设置流中的当前位置和拷贝进缓冲区的字节数. 一般从0开始.

    在初始化结构和缓冲区后, 输入函数按要求从缓冲区中读取数据. 
    在读取数据时, 文件位置指示器被设置为指向刚读取字符的下一个字符.
    由于stdio.h系列的所有输入函数都使用相同的缓冲区, 所以调用任何一个函数都将从上一次函数停止调用的位置开始.

    当输入函数发现已读完缓冲区中的所有字符时, 会请求把下一个缓冲大小的数据块从文件拷贝到该缓冲区中.
    以这种方式, 输入函数可以读取文件中的所有内容, 直到文件结尾.
    函数在读取缓冲区的最后一个字符后, 把结尾指示器设置为真. 于是下一次被调用的输入函数将返回EOF.

    输出函数以类似的方式把数据写入缓冲区. 当缓冲区被填满时, 数据将被拷贝至文件中.


fopen() 函数

    FILE * fopen ( const char * restrict filename, const char * restrict mode );
        为标准I/O打开一个文件, 并创建一个用于存储文件和缓冲区信息的结构体.
        第一个参数是待打开文件的名称, 是一个包含该文件名的字符串地址.
        第二个参数是一个字符串, 指定待打开文件的模式.
        返回指向FILE结构的指针, 即文件指针(file pointer), 其他函数可以使用该指针指定待处理的文件. 打开失败则返回一个空指针NULL, 且设置全局变量errno来标识错误

    模式字符串
        r-read, w-write, a-append, b-bit
        文本模式
            "r" : 以读模式打开文件, 被打开文件必须存在
            "w" : 以写模式打开文件, 把现有文件的长度截为0, 如果文件不存在, 则创建一个新文件
            "a" : 以追加模式打开文件, 在现有文件末尾添加内容, 如果文件不存在, 则创建一个新文件
            "r+" : 以更新模式打开文件, 即可以读文件
            "w+" : 以更新模式打开文件, 即可以读和写文件, 如果文件存在, 则将其长度截为0, 如果文件不存在, 则创建一个新文件
            "a+" : 以更新模式打开文件, 即可以读和写文件, 在现有文件的末尾添加内容, 如果文件不存在, 则创建一个新文件, 可以读取整个文件, 但是只能从末尾添加内容

        二进制模式
            "rb" : 以读模式打开文件
            "wb" : 以写模式打开文件, 把现有文件的长度截为0, 如果文件不存在, 则创建一个新文件
            "ab" : 以追加模式打开文件, 在现有文件末尾添加内容, 如果文件不存在, 则创建一个新文件
            "rb+", "r+b" : 以更新模式打开文件, 即可以读文件
            "wb+", "w+b" : 以更新模式打开文件, 即可以读和写文件, 如果文件存在, 则将其长度截为0, 如果文件不存在, 则创建一个新文件
            "ab+", "a+b" : 以更新模式打开文件, 即可以读和写文件, 在现有文件的末尾添加内容, 如果文件不存在, 则创建一个新文件, 可以读取整个文件, 但是只能从末尾添加内容

        C11 新增带字母x的写模式
            如果文件已存在或以独占模式打开文件中, 则打开文件失败
            "wx"
            "w+x"
            "wbx"
            "wb+x", "w+bx"
            没有x字母的写模式打开一个现有文件, fopen()会把该文件的长度截为0, 这样就丢失了该文件的内容.
            但是如果使用带x字母的写模式, 即使fopen()操作失败, 原文件的内容也不会被删除.
            如果环境允许, 带x字母的写模式会使得其他程序或线程无法访问正在被打开的文件, 即独占特性.

        注意:
            任何一种不带x字母的"w"模式打开一个现有文件, 该文件的内容会被删除.
            带有x字母的任何一种模式, 将无法打开一个现有文件.

    FILE 类型
        FILE是定义在stdio.h 中的派生类型, 本质是一个C结构体, 记录了所要打开文件的缓冲区信息. 
        标准库中I/O函数使用这些缓冲区信息就可以对文件进行操作.

    程序可以同时打开的文件数量是有限的, 这个限制取决于系统和实现, 范围一般是10~20.
    相同的文件指针可以处理不同的文件, 前提是这些文件不需要同时打开.


指向标准文件的指针
    在stdio.h 头文件中, 把三个文件指针与三个标准文件相关联, C程序会自动打开这三个标准文件

    标准输入, 对应文件指针 stdin, 通常使用的设备 键盘
    标准输出, 对应文件指针 stdout, 通常使用的设备 显示器
    标准错误, 对应文件指针 stderr, 通常使用的设备 显示器

    这些都是指向FILE的指针


getc()和putc()函数
    这两个函数对应getchar()与putchar(), 但是getc()和putc()需要指定数据源, 即哪个文件, 而getchar()和putchar()默认为stdin和stdout

    int getc ( FILE * stream );
    或
    int fgetc ( FILE * stream );
        从指定的文件中获取一个字符
        将char强制转换为int的形式返回读取的字符, 如果到达文件尾或发生读错误, 则返回EOF

    int putc ( int c, FILE * stream );
    或
    int fputc ( int c, FILE * stream );
        将字符写入指定的文件中
        第一个参数是待写入的字符, 第二个参数是文件指针
        将char强制转换为int的形式返回写入的字符, 如果发生错误则返回EOF


文件结尾 EOF
    从文件中读取数据的程序要读到文件结尾时停止.
    在使用标准I/O中函数读取一个字符时发现是文件结尾, 将会返回一个特殊值EOF.
    C程序只有在读到超过文件末尾时才会发现文件结尾.

    为了避免读到空文件, 应该使用入口条件循环进行文件输入.
    例
        int ch;
        FILE * fp;
        fp = fopen("./file.txt", "r");
        while ((ch=getc(fp)) != EOF )   // 或者 while ( (ch=getc(fp)) && (ch!=EOF) ) 注意运算符优先级
        {
            ...
        }


fclose()函数
    int fclose ( FILE * stream );
        关闭参数指向的文件, 必要时刷新缓冲区.
        关闭成功返回0, 失败返会EOF.

    如果磁盘已满, 移动硬盘被移除, 出现I/O错误, 都会导致调用fclose()函数失败.


文件I/O: fprintf(), fscanf(), fgets(), fputs()
    文件I/O函数要用FILE指针指定待处理的文件.

    fscanf(), fprintf()函数
        这两个函数的工作方式与scanf()和printf()类似, 区别在于fscanf()和fprintf()需要用第一个参数指定待处理文件.

        int fscanf ( FILE * stream, const char * format, ... );
            从指定文件流中读取格式化输入
            如果成功, 返回成功匹配和赋值的个数, 如果到达文件尾或发生读错误, 则返回EOF

        int fprintf ( FILE * stream, const char * format, ... );
            把格式化输出写入指定文件流
            如果成功, 则返回写入的字符总数, 否则返回一个负数

    fgets(), fputs()函数

        char * fgets ( char * str, int num, FILE * stream );
            从指定额文件流中读取一行或者指定长度的字符到字符串中
            第一个参数表示存储输入位置的地址, 第二个参数表示待输入字符串的长度, 第三个参数表示待读取的文件指针
            如果成功, 该函数返回相同的str参数, 如果到达文件尾或发生错误, 则返回一个空指针
        
        fgets()函数读取直到第一个换行符后面, 或读到文件结尾, 或读取num-1个字符
        如果fgets()读到换行符, 该函数在换行符后加一个表示字符串结尾的空字符使之成为一个字符串, 字符串的大小是其字符数加上一个空字符, 即num
        如果fgets()在读到字符个数上限num-1, 该函数会在末尾加一个表示字符串结尾的空字符使之成为一个字符串, 字符串的大小是其字符数加上一个空字符, 即num
        如果fgets()在遇到EOF时将返回NULL值, 可以利用这一机制检查是否到达文件尾, 未遇到EOF则返回之前传给该函数的第一个参数地址.

        int fputs ( const char * str, FILE * stream );
            把第一个参数指向的字符串写入指定文件流
            第一个参数表示存储输出位置的地址, 第二个参数表示待输入的文件指针
            如果成功, 返回一个非负值, 如果发生错误则返回EOF

        fputs()函数把字符原封不动地发送到指定文件流中, 当遇到紧跟在字符串后面的空字符\0, 缓冲区中的内容被发送至文件流中.

    因为fgets()保留了换行符, fputs()不会再添加换行符, 所以这两个配合最好.


二进制I/O: fread(), fwrite()
    使用文本模式处理字符和字符串时, 如何处理数值数据?
    可以使用fprintf()将数值数据转换为对应的字符, 在放入文本文件中, 如 fprintf(fp, "%f", 0.33333);
    但是如果格式化字符指定了长度与精度, 在转换为字符的时候, 就只对应长度个数的字符, 在读取该数值时, 就得不到原先的值.
    因此应该使用二进制模式来将数值, 结构体, 枚举等非字符型的数据整字节的存储在文件中. 在下次读取时候, 将会读取对应类型大小个字节.
    将以此方式存储的数据称为二进制形式存储数据.

    实际上所有数据都是以二进制形式存储的, 字符都以字符码的二进制表示来存储. 机器语言指令文件也是二进制.
    如果文件所有数据都可以被解释成字符码, 则该文件包含文本数据.
    如果文件部分或所有的数据都能被解释成二进制形式的数值数据, 则该文件包含二进制数据.

    一般而言, 使用文本模式打开纯文本文件, 以二进制模式打开包含二进制信息的文件.

    size_t fread ( void * ptr, size_t size, size_t nmemb, FILE * stream );
        读取指定文件流stream中的二进制数据到ptr指向的数组中
        第一个参数ptr指向要被写入的元素数组(数据块)的指针.
        第二个参数size表示要被写入的每个元素的大小, 以字节为单位.
        第三个参数nmemb表示将被写入的元素的个数, 每个元素的大小为size字节.
        第四个参数stream是指向FILE对象的指针, 该FILE对象指定了一个输出流.
        如果成功, 返回一个表示读取元素总数的size_t对象, 如果总数与 nmemb 参数不同, 则可能发生了一个错误或者到达了文件末尾.

    例
        // 恢复保存的内含10个double类型值的数组
        double numbers[10];
        fread(numbers, sizeof(double), 10, fp);

    size_t fwrite ( const void * ptr, size_t size, size_t nemeb, FILE * stream );
        把ptr 所指向的数组中的数据写入到给定流stream中
        第一个参数ptr指向要被写入的元素数组(数据块)地址.
        第二个参数size表示要被写入的每个元素的大小, 以字节为单位.
        第三个参数nmemb表示将被写入的元素的个数, 每个元素的大小为size字节.
        第四个参数stream是指向FILE对象的指针, 该FILE对象指定了一个输出流.
        如果成功, 返回一个表示元素的总数size_t对象, 如果该数字与 nmemb 参数不同, 则会显示一个错误.

    例  
        // 保存一个大小为256字节的数据对象, 这里是一个char数组
        char ch_array[256];
        fwrite(ch_array, sizeof(char), 256, fp);

        // 保存10个double数据对象, 这里是一个double数组
        double numbers[10];
        fwrite(numbers, sizeof(double), 10, fp);

    void* 指针类型是一种通用类型, 可以与任何类型相互转换


随机访问: fseek(), ftell()

    int fseek ( FILE * stream, long int offset, int whence );
        设置流 stream 的文件位置为给定的偏移 offset, 参数 offset 意味着从给定的 whence 位置查找的字节数.
        第一个参数是FILE指针, 指向待查找的文件
        第二个参数是偏移量(offset). 该参数表示从起始点开始要移动的距离. 必须是long类型的值, 为正(向文件结尾), 为负(向文件开始), 0(保持不动)
        第三个参数是模式, 确定起始点.
        如果成功, 则该函数返回0, 否则返回非0.

        在stdio.h 头文件中定义了几个表示模式的明示常量(manifest constant).
            SEEK_SET : 从文件开始处, 通常为值0
            SEEK_CUR : 当前位置, 通常为值1
            SEEK_END : 文件末尾, 通常为值2
        
        例
            fseek(fp, 0L, SEEK_SET);   // 定位至文件开始处
            fseek(fp, 10L, SEEK_SET);   // 从文件开始处向文件尾移动10个字节
            fseek(fp, 2L, SEEK_CUR);   // 从文件当前位置向文件尾移动2个字节
            fseek(fp, 0L, SEEK_END);   // 定位至文件结尾
            fseek(fp, -10L, SEEK_END);   // 从文件结尾向文件开始处移动10个字节

    long int ftell( FILE *stream );
        返回位置标识符的当前值, 如果发生错误, 则返回-1L, 全局变量errno被设置为一个正值
        ANSI C规定
            当以二进制模式打开文件, 返回的是参数所指向文件的当前位置距文件开始处的字节数.
            当以文本模式打开文件, 对于Unix/Linux系统, 返回的值可以作为fseek()的第二个参数, 对于MS-DOS, 返回的值把\r\n当作一个字节计数
        
    在随机访问文件的时候, 要注意不同系统对于文件存储的不同
        Unix/Linux系统只有一种文件格式, 二进制模式与文本模式都是一样的.
        而MS-DOS系列的系统, 使用Ctrl+Z标记文本文件的结尾, 以\r\n作为文本文件的换行符.
        以文本模式打开MS-DOS系列的系统的文本文件, C程序能识别Ctrl+Z文件结尾, 以二进制模式打开, 会将其视作一个字符, 而认为实际结尾在Ctrl+Z后
        以文本模式打开MS-DOS系列的系统的文本文件, C程序把\r\n看成\n, 以二进制模式打开, 就会看到这两个字符.

    针对可移植性
        不能保证所有的系统都与Unix/Linux系统的文件模型一致, 所以ANSI C对fseek()与ftell()降低了要求
            在二进制模式中, 实现不必支持SEEK_END模式. 想要到文件尾, 应该逐字节读取整个文件到文件末尾.
            在文本模式中, 只有以下调用能保证其相应行为
                fseek(file, 0L, SEEK_SET) : 定位至文件开始处
                fseek(file, 0L, SEEK_CUR) : 保持当前位置不动
                fseek(file, 0L, SEEK_END) : 定位至文件结尾
                fseek(file, ftell-pos, SEEK_SET) : 到距文件开始处ftell-pos的位置, ftell-pos是ftell()的返回值 


更好的随机访问: fsetpos(), fgetpos()
    fseek()和ftell()潜在的问题是他们都把文件大小限制在long类型能表示的范围内.

    在stdio.h 头文件中定义了一种新类型 fpos_t (代表 file point type, 文件定位类型). fpos_t不是基本类型, 他是根据其他类型来定义的.
    fpos_t类型变量或数据对象可以在文件中指定一个位置, 他不能是数组类型, 除此之外, 没有其他限制. 

    int fsetpos(FILE *stream, const fpos_t *pos);
        使用pos指向位置上的fpos_t类型值来设置文件指针指向偏移该值后指定的位置.
        如果成功, fsetpos()函数返回0, 如果失败, 返回非0

    int fgetpos(FILE *stream, fpos_t *pos);
        把fpos_t类型的值放在pos指向的位置上, 该值描述了文件中的当前位置距文件开头的字节数.
        如果成功, fgetpos()函数返回0, 如果失败, 返回非0


设置为文件开始位置: rewind()
    void rewind(FILE * stream);
        设置stream指向文件流重新为文件开始位置


feof(), ferror()函数
    如果标准输入函数返回EOF, 则通常表明函数已达到文件尾.
    然而当出现读取错误的时候, 函数也会返回EOF, 使用feof()和ferror()函数报告I/O操作失败的原因.

    int feof(FILE * stream);
        当前流检测到文件结尾EOF时, 返回一个非零值, 否则返回0

    int ferror(FILE * stream);
        当读或写出现错误, 返回一个非零值, 否则返回0

    要注意处理文件尾, C函数在读过文件后才会检测到文件结尾, 这意味着应该在尝试读取之后立即判断是否是文件结尾.
    如
        while (!feof(fp))
        或
        while ( (ch=fgetc(fp)) != EOF )

    void clearerr(FILE *stream);
        清除给定stream流的文件结束和错误标识符
        这不会失败, 且不会设置外部变量errno, 但是如果他检测到他的参数不是一个有效的流, 则返回-1, 并设置errno为EBADF


其他常用标准I/O函数

    FILE * freopen ( const char * filename, const char * mode, FILE * stream );
        重新以指定mode打开对应文件名filename的文件, 将生成的文件流指针给与stream, 同时关闭旧的文件, 并返回, 失败则返回NULL

    FILE * tmpfile(void);
        如果成功, 返回一个指向被创建的临时文件的流指针, 如果文件未被创建, 则返回NULL

    int ungetc(int c, FILE * stream);
        把指定字符c放入指定的文件流中
        成功返回c, 失败返回EOF
    如果把一个字符放回输入流, 下次调用标准输入函数将读取该字符.
    如果把一个字符串放回输入流, 下次调用标准输入函数将倒着读取该字符. 类似栈的特性.
    
    int fflush(FILE * stream);
        将输出缓冲区中所有未写入数据发送到指定的文件流中
        如果传入stream为空指针, 所有输出缓冲区都被刷新
        成功返回0, 失败返回非0或EOF
    这个过程被称为刷新缓冲区.
    在输入流中, 该函数的效果是未定义的.

    int setvbuf(FILE * restrict stream, char * restrict buffer, int mode , size_t size);
        在打开文件后且未对流进行其他操作之前, 调用该函数. 将会创建一个供标准I/O流替换使用的缓冲区.
        指针stream识别待处理的流, buffer指向待使用的存储区.
        如果buffer的值不是NULL, 则必须创建一个缓冲区.
        如果把NULL作为buffer的值, 该函数会为自己分配一个缓冲区.
        变量size告诉setvbuf()数组的大小.
        mode可以为_IOFBF : 表示完全缓冲, 即在缓冲区满时刷新
                 _IOLBF : 表示行缓冲, 即在缓冲区满时或写入一个换行符时刷新
                 _IONBF : 表示无缓冲.
        一般设置4k, 内存一页的大小

        如果操作成功, 返回0, 失败返回非0.
    假设一个程序要存储一种数据对象, 每个数据对象的大小是1000字节. 可以使用setvbuf()函数创建一个缓冲区, 其大小是该数据对象大小的整数倍.
    例
        FILE * buf_fp;
        int array[1024];
        memset(array, '\0', sizeof(array));
        if ( setvbuf(buf_fp, array, _IOFBF, 1024) == 0) {
            fprintf(buf_fp, "%s", "创创建新的缓冲区成功.\n");
        } 
    array作为新的完全缓冲区, 大小为1024个int的字节, 当使用fflush()刷新输出, 这会将array中的输出发送到buf_fp中


-----------------------------总结-------------------------------

C把输入视为字节流.

fread()函数, 把C输入看作是二进制值并将其存储在指定的存储位置.
fwrite()将二进制数据直接放入输出流, 而其他输出函数把非字符数据转换成用字符表示后才将其放入输出流.

fscanf(), getc(), fgets()或其他相关函数, C则将每个字节看作是字符码.
fscanf(), scanf()函数尝试把字符码翻译成转化说明指定的其他类型.
getc(), fgetc()系列函数把输入作为字符码存储, 将其作为单独的字符保存在字符变量中或作为字符串存储在字符数组中.

ANSI C提供两种文件打开模式, 二进制, 文本.
以二进制模式打开文件时, 可以逐字节读取文件, 以文本模式打开文件时, 会把文件内容从文本的系统表示法映射为C表示法.
对于Unix/Linx系统, 这两种模式完全相同.

输入函数getc(), fgets(), fscanf(), fread()都从文件开始处按顺序读取文件.

fseek(), ftell()函数让程序可以随机访问文件中的任意位置.
fgetpos(), fsetpos()把类似的功能扩展至更大的文件.
与文本模式相比, 二进制模式更容易进行随机访问.

C函数在读过文件结尾后才会检测到文件结尾, 应该每次读取后应该检查是否读到了文件按结尾.