绝大多数C实现都是提供底层I/O和标准高级I/O. 
因为ANSI C库考虑到可移植性, 包含了标准I/O包, 但是未提供底层I/O.
标准I/O包自动创建输入和输出缓冲区以加快数据传输.
标准I/O都在C标准库stdio.h 头文件中声明.


标准I/O的机理

    通常使用标准I/O的第一步都是调用fopen()打开文件.
    调用fopen()不仅打开一个文件, 还创建了一个缓冲区, 在读写模式下会创建两个缓冲区, 以及创建一个包含文件和缓冲区数据的结构体对象.
    完成后fopen()返回一个指向该结构体对象的指针, 以便其他函数知道如何找到该结构.
    这一个过程, 描述为fopen()"打开一个流".
    如果以文本模式打开文件, 就获得一个文本流, 如果以二进制模式打开文件, 就获得一个二进制流.

    如在VC6 中的FILE 结构体定义
        #ifndef _FILE_DEFINED
        struct _iobuf {
        　　　　char *_ptr;      //文件输入的下一个位置
        　　　　int _cnt;        //当前缓冲区的相对位置
        　　　　char *_base;     //指基础位置(即是文件的起始位置) 
        　　　　int _flag;       //文件标志
        　　　　int _file;       //文件描述符id
        　　　　int _charbuf;    //检查缓冲区状况,如果无缓冲区则不读取
        　　　　int _bufsiz;     //文件缓冲区大小
        　　　　char *_tmpfname; //临时文件名
            };
        typedef struct _iobuf FILE;
        #define _FILE_DEFINED
        #endif
    这个结构通常包含一个指定流中当前位置的文件位置指示器. 
    除此外他还包含错误和文件结尾的指示器, 一个指向缓冲区开始处的指针, 一个文件标识符, 一个计数用以统计实际拷贝进缓冲区的字节数.

    stdio.h中一些处理FILE类型, 即处理文件流的函数, 一调用这些函数, 文件中的缓冲大小数据块就被拷贝到缓冲区中.
    缓冲区的大小因实现而异, 一般是512字节或其倍数, 随着计算机硬盘容量越大, 缓冲区大小也越大.
    最初调用函数, 除了填充缓冲区外, 还要设置FILE对象所指向的机构中的值. 尤其要设置流中的当前位置和拷贝进缓冲区的字节数. 一般从0开始.

    在初始化结构和缓冲区后, 输入函数按要求从缓冲区中读取数据. 
    在读取数据时, 文件位置指示器被设置为指向刚读取字符的下一个字符.
    由于stdio.h系列的所有输入函数都使用相同的缓冲区, 所以调用任何一个函数都将从上一次函数停止调用的位置开始.

    当输入函数发现已读完缓冲区中的所有字符时, 会请求把下一个缓冲大小的数据块从文件拷贝到该缓冲区中.
    以这种方式, 输入函数可以读取文件中的所有内容, 直到文件结尾.
    函数在读取缓冲区的最后一个字符后, 把结尾指示器设置为真. 于是下一次被调用的输入函数将返回EOF.

    输出函数以类似的方式把数据写入缓冲区. 当缓冲区被填满时, 数据将被拷贝至文件中.


fopen() 函数

    FILE * fopen ( const char * restrict filename, const char * restrict mode );
        为标准I/O打开一个文件, 并创建一个用于存储文件和缓冲区信息的结构体.
        第一个参数是待打开文件的路径, 是一个包含该文件名的字符串地址.
        第二个参数是一个字符串, 指定待打开文件的模式.
        返回指向FILE结构的指针, 即文件指针(file pointer), 其他函数可以使用该指针指定待处理的文件. 打开失败则返回一个空指针NULL, 且设置全局变量errno来标识错误

    模式字符串
        r-read, w-write, a-append, b-bit
        ● 文本模式
            "r" : 只读, 打开后对文件以字符方式进行读操作, 文件不存在返回NULL
            "w" : 只写, 打开后清空文件原有全部数据, 再进行写操作, 如果文件不存在, 则创建一个新文件
            "a" : 追加, 打开后不删除文件原有数据, 在文件原有数据后添加新数据, 如果文件不存在, 则创建一个新文件
            "r+" : 读写, 打开文件以字符方式进行读, 写操作, 打开后读写位置从头开始, 文件不存在返回NULL
            "w+" : 读写, 打开后清空文件原有全部数据, 再进行读写操作, 如果文件不存在, 则创建一个新文件
            "a+" : 读写尾部添加, 打开文件后不删除文件原有数据, 可以读, 写文件, 读写位置标记在打开后指向文件原有数据的尾部, 文件不存在返回NULL

        ● 二进制模式
            "rb" : 只读, 打开后对文件以二进制方式进行读操作, 文件不存在返回NULL
            "wb" : 只写, 打开后清空文件原有全部数据, 再进行写操作, 如果文件不存在, 则创建一个新文件
            "ab" : 追加, 打开文件后不删除文件原有数据, 在原文件数据末尾添加内容, 文件不存在返回NULL
            "rb+", "r+b" : 读写, 打开后对文件以二进制方式进行读, 写操作, 打开后读写位置从头开始, 如果文件不存在, 则创建一个新文件
            "wb+", "w+b" : 读写, 打开后清空文件原有全部数据, 再进行读, 写操作, 如果文件不存在, 则创建一个新文件
            "ab+", "a+b" : 读写尾部添加, 打开文件后不删除文件原有数据, 可以读, 写文件, 读写位置标记在打开后指向文件原有数据的尾部, 文件不存在返回NULL

        C11 新增带字母x的写模式
            如果文件已存在或以独占模式打开文件中, 则打开文件失败
            "wx"
            "w+x"
            "wbx"
            "wb+x", "w+bx"
            没有x字母的写模式打开一个现有文件, fopen()会把该文件的长度截为0, 这样就丢失了该文件的内容.
            但是如果使用带x字母的写模式, 即使fopen()操作失败, 原文件的内容也不会被删除.
            如果环境允许, 带x字母的写模式会使得其他程序或线程无法访问正在被打开的文件, 即独占特性.

        注意:
            任何一种不带x字母的"w"模式打开一个现有文件, 该文件的内容会被删除.
            带有x字母的任何一种模式, 将无法打开一个现有文件.

    FILE 类型
        FILE是定义在stdio.h 中的派生类型, 本质是一个C结构体, 记录了所要打开文件的缓冲区信息. 
        标准库中I/O函数使用这些缓冲区信息就可以对文件进行操作.

    程序可以同时打开的文件数量是有限的, 这个限制取决于系统和实现, 范围一般是10~20.
    相同的文件指针可以处理不同的文件, 前提是这些文件不需要同时打开.


指向标准文件的指针
    在stdio.h 头文件中, 把三个文件指针与三个标准文件相关联, C程序会自动打开这三个标准文件

    标准输入, 对应文件指针 stdin, 通常使用的设备 键盘
    标准输出, 对应文件指针 stdout, 通常使用的设备 显示器
    标准错误, 对应文件指针 stderr, 通常使用的设备 显示器

    这些都是指向FILE的指针


fclose()函数
    int fclose ( FILE * stream );
        关闭参数指向的文件, 必要时刷新缓冲区.
        关闭成功返回0, 失败返会EOF.

    如果磁盘已满, 移动硬盘被移除, 出现I/O错误, 都会导致调用fclose()函数失败.


fgetc()和fputc()函数, 宏定义getc, putc
    getc与putc是基于文件I/O实现的对应getchar()与putchar()的宏定义
    getc()和putc()需要指定数据源, 即哪个文件, 而getchar()和putchar()默认为stdin和stdout

    int fgetc ( FILE * stream );
    与
    # define getc(fp) fgetc(fp)
        从指定文件流中读取一个字符
        将char强制转换为int的形式返回读取的字符
        读取成返回读取的字符, 如果到达文件尾或发生读错误, 则返回EOF

    int fputc ( int c, FILE * stream );
    与
    # define putc(ch, fp) fputc(ch, fp)
        把字符写到文件指针所指向的文件中
        第一个参数是待写入的字符, 第二个参数是文件指针
        将char强制转换为int的形式返回写入的字符, 如果发生错误则返回EOF


文件结尾 EOF
    从文件中读取数据的程序要读到文件结尾时停止.
    在使用标准I/O中函数读取一个字符时发现是文件结尾, 将会返回一个特殊值EOF.
    C程序只有在读到超过文件末尾时才会发现文件结尾.

    为了避免读到空文件, 应该使用入口条件循环进行文件输入.
    例
        int ch;
        FILE * fp;
        fp = fopen("./file.txt", "r");
        while ((ch=getc(fp)) != EOF )   // 仅可用于文本读写判断未到文件尾, 等价: while ( (ch=getc(fp)) && (ch!=EOF) ) 注意运算符优先级
        {
            ...
        }

    在文本文件中, 由于字符的ASCII都是非负值, 可以用EOF作为文件读完的标志.
    但对于二进制文件, 很可能文件中某一个字节的数据就是EOF值, 若使用fgetc(fp)==EOF来判断文件结尾就不行.


文本I/O
    文件I/O函数要用FILE指针指定待处理的文件.

    ● 格式化方式读写文件 fscanf(), fprintf()
        这两个函数的工作方式与scanf()和printf()类似, 区别在于fscanf()和fprintf()需要用第一个参数指定待处理文件.

        int fscanf ( FILE * stream, const char * format, ... );
            即 fsacnf(文件指针, 格式控制字符串, 输入项的地址列表)
            从文件流中把格式化字串读入指定变量列表
            如果成功, 返回成功匹配和赋值的个数, 如果到达文件尾或发生读错误, 则返回EOF

        int fprintf ( FILE * stream, const char * format, ... );
            即 fprintf(文件指针, 格式控制字符串, 输出项列表)
            从变量列表把格式化字串输出到指定文件流
            如果成功, 则返回写入的字符总数, 否则返回一个负数

        fscanf()和fprintf()适用于文本文件的读写
        优点是文本文件中的内容可以直接查看
        缺点是对于非字符类型的数据, 每一次的读写都要进行字符串与数之间的转换, 需要花费时间, 在数据量较大的时候, 效率低下. 

        例
            FILE *fp;
            int m, n;
            char *str, ch;
            ...
            fscanf(fp, "%d - %s", &m, str);   // 从指定文件流fp读取格式化输入给m, str
            fprintf(fp,"%d - %c", n, ch);    // 将n, ch按格式化输出到指定文件流fp

    ● 字符串方式读写文件 fgets(), fputs()

        char * fgets ( char * str, int num, FILE * stream );
            从指定的文件流中读取一行或者指定长度的字符串到str中
            第一个参数表示将存储读取内容的地址, 第二个参数表示读取字符串的长度, 第三个参数表示待读取的文件指针
            如果成功, 该函数返回相同的str参数, 如果到达文件尾或发生错误, 则返回NULL
        
        在文件中, fgets()函数调用一次最多可以从文本文件中读取num-1个字符, 然后函数自动在后面加上'\0'形成字符串
        因此用于存储的str所指向数组最小长度不得低于num.
        fgets()会保留文件中的换行符, Dos系统中CRLF两个字符表示一个换行符, 将会保留LF放到字符串中.

        int fputs ( const char * str, FILE * stream );
            把str指向的字符串写到文件指针所指向的文件中
            第一个参数表示将输出内容的地址, 第二个参数表示待输入的文件指针
            如果成功, 返回一个非负值, 如果发生错误则返回0或EOF

        fputs()函数把字符原封不动地发送到指定文件流中, 当遇到紧跟在字符串后面的空字符\0, 缓冲区中的内容被发送至文件流中, '\0'不会写在文件中.

        因为fgets()保留了输入时的换行符, fputs()不提供输出换行符, 所以这两个配合最好.


二进制I/O:
    ● 数据块读写文件 fread(), fwrite()
        使用文本模式处理字符和字符串时, 如何处理数值数据?
        可以使用fprintf()将数值数据转换为对应的字符, 在放入文本文件中, 如 fprintf(fp, "%f", 0.33333);
        但是如果格式化字符指定了长度与精度, 在转换为字符的时候, 就只对应长度个数的字符, 在读取该数值时, 就得不到原先的值.
        因此应该使用二进制模式来将数值, 结构体, 枚举等非字符型的数据整字节的存储在文件中. 在下次读取时候, 将会读取对应类型大小个字节.
        将以此方式存储的数据称为二进制形式存储数据.

        实际上所有数据都是以二进制形式存储的, 字符都以字符码的二进制表示来存储. 机器语言指令文件也是二进制.
        如果文件所有数据都可以被解释成字符码, 则该文件包含文本数据.
        如果文件部分或所有的数据都能被解释成二进制形式的数值数据, 则该文件包含二进制数据.

        一般而言, 使用文本模式打开纯文本文件, 以二进制模式打开包含二进制信息的文件.

        数据块读写方式在在读写过程中不对数据进行转换, 直接在内存文件之间进行数据拷贝, 省略了数值与字符串之间的转换时间.
        采用数据块读写方式时, 读写过程中不会考虑数据的性质和类型, 只是简单对存储空间进行赋值.
        至于存储空间内的这些二进制数所包含的数据类型和值, 则由用户自己进行处理和解释.

        size_t fread ( void * ptr, size_t size, size_t nmemb, FILE * stream );
            即 fread(存储块, 读入块大小, 读入块个数, 被读出文件指针)
            从文件读取大小为size*nmemb字节的数据块到ptr所指内存中
            第一个参数ptr指向要被写入的元素数组(数据块)的指针.
            第二个参数size表示要被写入的每个元素的大小, 以字节为单位.
            第三个参数nmemb表示将被写入的元素的个数, 每个元素的大小为size字节.
            第四个参数stream是指向被读出数据的文件流.
            如果成功, 返回一个表示读取元素总数的size_t对象, 如果总数与 nmemb 参数不同, 则可能发生了一个错误或者到达了文件末尾. 
            当发生一个错误为返回-1, 当遇到文件尾返回0.

        例
            // 恢复保存的内含10个double类型值的数组
            double numbers[10];
            fread(numbers, sizeof(double), 10, fp);

        size_t fwrite ( const void * ptr, size_t size, size_t nmemb, FILE * stream );
            即 fwrite(写出块, 写出块大小, 写出块个数, 被写入文件指针)
            从ptr所指内存中读取大小为size*nmemb字节的数据块写到文件中
            第一个参数ptr指向要被写入的元素数组(数据块)地址.
            第二个参数size表示要被写入的每个元素的大小, 以字节为单位.
            第三个参数nmemb表示将被写入的元素的个数, 每个元素的大小为size字节.
            第四个参数stream是指向将被输出数据的文件流.
            如果成功, 返回一个表示元素的总数size_t对象, 如果该数字与 nmemb 参数不同, 则会显示一个错误.

        例  
            // 保存一个大小为256字节的数据对象, 这里是一个char数组
            char ch_array[256];
            fwrite(ch_array, sizeof(char), 256, fp);

            // 保存10个double数据对象, 这里是一个double数组
            double numbers[10];
            fwrite(numbers, sizeof(double), 10, fp);

        void* 指针类型是一种通用类型, 可以与任何类型相互转换


文件结束判定: feof()

    fgetc()函数返回EOF并不一定就表示文件结束, 读取文件出错也会返回EOF.
    在非文本文件情况下, 有可能某个数据值本身就是EOF值, 仅凭读写函数返回EOF就认为文件已经结束是不正确的做法.

    int feof(FILE * stream);
        在进行读文件时, 检测是否读完文件所有数据
        如果文件结束, 则返回非0值, 否则返回0

        feof()函数并不是在读完文件的最后一个字节就返回逻辑真, 而是要在读一次, 当没有数据可以读入时才返回非0值.
 
    要注意处理文件尾, C函数在读过文件后才会检测到文件结尾, 这意味着应该在尝试读取之后立即判断是否是文件结尾.
    如
        while (!feof(fp))   // 可以处理文本与二进制文件读取是否到达文件尾
        或
        while ( (ch=fgetc(fp)) != EOF )   // 仅处理文本文件读取是否到达文件尾


随机访问: fseek(), ftell()

    系统为每个打开的文件设置了一个文件读写位置标记(简称文件位置指针).
    执行非追加方式打开文件操作, 文件位置指针自动指向文件开头, 以后每读, 写一个字符, 文件位置指针自动向后移动一个位置.
    如果是以追加方式("a")打开文件, 文件位置指针指向文件的末尾.
    对文件的随机访问是通过对文件位置指针值进行重新设定来实现的.

    int fseek ( FILE * stream, long int offset, int whence );
        即 fseek(文件流, 位移量, 起始点)
        设置流 stream 的文件位置为给定的偏移 offset, 参数 offset 意味着从给定的 whence 位置查找的字节数.
        第一个参数是FILE指针, 指向待查找的文件
        第二个参数是偏移量(offset). 该参数表示从起始点开始要移动的距离. 必须是long类型的值, 为正(向文件结尾), 为负(向文件开始), 0(保持不动)
        第三个参数是模式, 确定起始点.
        如果成功, 则该函数返回0, 否则返回非0.

        在stdio.h 头文件中定义了几个表示模式的明示常量(manifest constant).
            SEEK_SET : 从文件开始处, 通常为值0
            SEEK_CUR : 当前位置, 通常为值1
            SEEK_END : 文件末尾, 通常为值2
        
        例
            fseek(fp, 0L, SEEK_SET);   // 定位至文件开始处
            fseek(fp, 10L, SEEK_SET);   // 从文件开始处向文件尾移动10个字节
            fseek(fp, 2L, SEEK_CUR);   // 从文件当前位置向文件尾移动2个字节
            fseek(fp, 0L, SEEK_END);   // 定位至文件结尾
            fseek(fp, -10L, SEEK_END);   // 从文件结尾向文件开始处移动10个字节

    long int ftell( FILE *stream );
        返回位置标识符的当前值, 如果发生错误, 则返回-1L, 全局变量errno被设置为一个正值
        ANSI C规定
            当以二进制模式打开文件, 返回的是参数所指向文件的当前位置距文件开始处的字节数.
            当以文本模式打开文件, 对于Unix/Linux系统, 返回的值可以作为fseek()的第二个参数, 对于MS-DOS, 返回的值把\r\n当作一个字节计数
        
    在随机访问文件的时候, 要注意不同系统对于文件存储的不同
        Unix/Linux系统只有一种文件格式, 二进制模式与文本模式都是一样的.
        而MS-DOS系列的系统, 使用Ctrl+Z标记文本文件的结尾, 以\r\n作为文本文件的换行符.
        以文本模式打开MS-DOS系列的系统的文本文件, C程序能识别Ctrl+Z文件结尾, 以二进制模式打开, 会将其视作一个字符, 而认为实际结尾在Ctrl+Z后
        以文本模式打开MS-DOS系列的系统的文本文件, C程序把\r\n看成\n, 以二进制模式打开, 就会看到这两个字符.

    针对可移植性
        不能保证所有的系统都与Unix/Linux系统的文件模型一致, 所以ANSI C对fseek()与ftell()降低了要求
            在二进制模式中, 实现不必支持SEEK_END模式. 想要到文件尾, 应该逐字节读取整个文件到文件末尾.
            在文本模式中, 只有以下调用能保证其相应行为
                fseek(file, 0L, SEEK_SET) : 定位至文件开始处
                fseek(file, 0L, SEEK_CUR) : 保持当前位置不动
                fseek(file, 0L, SEEK_END) : 定位至文件结尾
                fseek(file, ftell-pos, SEEK_SET) : 到距文件开始处ftell-pos的位置, ftell-pos是ftell()的返回值 


更好的随机访问: fsetpos(), fgetpos()
    fseek()和ftell()潜在的问题是他们都把文件大小限制在long类型能表示的范围内.

    在stdio.h 头文件中定义了一种新类型 fpos_t (代表 file point type, 文件定位类型). fpos_t不是基本类型, 他是根据其他类型来定义的.
    fpos_t类型变量或数据对象可以在文件中指定一个位置, 他不能是数组类型, 除此之外, 没有其他限制. 

    int fsetpos(FILE *stream, const fpos_t *pos);
        使用pos指向位置上的fpos_t类型值来设置文件指针指向偏移该值后指定的位置.
        如果成功, fsetpos()函数返回0, 如果失败, 返回非0

    int fgetpos(FILE *stream, fpos_t *pos);
        把fpos_t类型的值放在pos指向的位置上, 该值描述了文件中的当前位置距文件开头的字节数.
        如果成功, fgetpos()函数返回0, 如果失败, 返回非0


重新设置文件开始位置: rewind()
    void rewind(FILE * stream);
        设置stream指向文件流重新为文件开始位置


错误标识符处理: ferror(), clearerr()
    int ferror(FILE * stream);
        用于测试给定文件指针指向的文件信息区的错误标识符.
        当读或写出现错误, 返回一个非零值, 否则返回0

    对同一个文件, 每次调用输入输出函数均产生一个新的ferror函数值errno, 因此应当在调用一个输入输出函数后立即检查ferror()函数的值, 否则信息会丢失.
    在执行fopen()函数时, ferror函数的初始值自动置为0.


    void clearerr(FILE *stream);
        将给定文件指针错误标志和文件结束标志置为0
        该函数执行不会失败, 且不会设置外部变量errno, 但是如果他检测到他的参数不是一个有效的流, 则返回-1, 并设置errno为EBADF

    示例
        FILE * fp;
        char ch;
        ...
        fp = fopen("./file.txt", "w");
        ch = fgetc(fp);   // 读取只写文件, 会出错
        if (ferror(fp)) perror("文件读取出错.");
        clearerr(fp);
        if (!ferror(fp)) puts("错误标识已清除.");


其他常用标准I/O函数

    FILE * freopen ( const char * filename, const char * mode, FILE * stream );
        重新以指定mode打开对应文件名filename的文件, 将生成的文件流指针给与stream, 同时关闭旧的文件, 并返回, 失败则返回NULL


    FILE * tmpfile(void);
        如果成功, 返回一个指向被创建的临时文件的流指针, 如果文件未被创建, 则返回NULL


    int ungetc(int c, FILE * stream);
        把指定字符c放入指定的文件流中
        成功返回c, 失败返回EOF
    如果把一个字符放回输入流, 下次调用标准输入函数将读取该字符.
    如果把一个字符串放回输入流, 下次调用标准输入函数将倒着读取该字符. 类似栈的特性.


    int fflush(FILE * stream);
        将输出缓冲区中所有未写入数据发送到指定的文件流中
        如果传入stream为空指针, 所有输出缓冲区都被刷新
        成功返回0, 失败返回非0或EOF
    这个过程被称为刷新缓冲区.
    在输入流中, 该函数的效果是未定义的.


    int setvbuf(FILE * restrict stream, char * restrict buffer, int mode , size_t size);
        在打开文件后且未对流进行其他操作之前, 调用该函数. 将会创建一个供标准I/O流替换使用的缓冲区.
        指针stream识别待处理的流, buffer指向待使用的存储区.
        如果buffer的值不是NULL, 则必须创建一个缓冲区.
        如果把NULL作为buffer的值, 该函数会为自己分配一个缓冲区.
        变量size告诉setvbuf()数组的大小.
        mode可以为_IOFBF : 表示完全缓冲, 即在缓冲区满时刷新
                 _IOLBF : 表示行缓冲, 即在缓冲区满时或写入一个换行符时刷新
                 _IONBF : 表示无缓冲.
        一般设置4k, 内存一页的大小

        如果操作成功, 返回0, 失败返回非0.
    假设一个程序要存储一种数据对象, 每个数据对象的大小是1000字节. 可以使用setvbuf()函数创建一个缓冲区, 其大小是该数据对象大小的整数倍.
    例
        FILE * buf_fp;
        int array[1024];
        memset(array, '\0', sizeof(array));
        if ( setvbuf(buf_fp, array, _IOFBF, 1024) == 0) {
            fprintf(buf_fp, "%s", "创创建新的缓冲区成功.\n");
        } 
    array作为新的完全缓冲区, 大小为1024个int的字节, 当使用fflush()刷新输出, 这会将array中的输出发送到buf_fp中


-----------------------------总结-------------------------------

C把输入视为字节流.

fread()函数, 把C输入看作是二进制值并将其存储在指定的存储位置.
fwrite()将二进制数据直接放入输出流, 而其他输出函数把非字符数据转换成用字符表示后才将其放入输出流.

fscanf(), getc(), fgets()或其他相关函数, C则将每个字节看作是字符码.
fscanf(), scanf()函数尝试把字符码翻译成转化说明指定的其他类型.
getc(), fgetc()系列函数把输入作为字符码存储, 将其作为单独的字符保存在字符变量中或作为字符串存储在字符数组中.

ANSI C提供两种文件打开模式, 二进制, 文本.
以二进制模式打开文件时, 可以逐字节读取文件, 以文本模式打开文件时, 会把文件内容从文本的系统表示法映射为C表示法.
对于Unix/Linx系统, 这两种模式完全相同.

输入函数getc(), fgets(), fscanf(), fread()都从文件开始处按顺序读取文件.

fseek(), ftell()函数让程序可以随机访问文件中的任意位置.
fgetpos(), fsetpos()把类似的功能扩展至更大的文件.
与文本模式相比, 二进制模式更容易进行随机访问.

C函数在读过文件结尾后才会检测到文件结尾, 应该每次读取后应该检查是否读到了文件按结尾.