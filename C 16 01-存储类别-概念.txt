C 中的对象 object

    从硬件方面来看, 被存储的每个值都占用一定的物理内存, C语言把这样的一块内存称为对象object.
    对象可以存储一个或多个值, 也可以并没有存储实际的值. 但是他在一定被分配了相应的大小以用于存储值.
    注意区分面向对象编程(Object Oriented Programming, 简称OOP)中的对象, OOP中的对象指的是类对象, 其定义包括数据和允许对数据进行的操作.


标识符 identifier

    从软件方面来看, 程序需要一种方法访问对象.
    软件(即C程序)中使用标识符identifier来指定designate硬件内存中的对象.
    如
        int num = 3;
    该声明创建了一个名为num的标识符, 即其变量名. 
    标识符遵循变量命名规则.

    补充
        变量的命名
            对于标识符(变量名), 编译器一般只识别前63位字符, 对于外部标识符, 只允许31位字符.
            标识符可以使用小写字母, 大写字母, 数字, 下划线_, 来命名, 而且名称的第一个字符必须是字母或下划线.
    
    变量名不是指定对象的唯一途径.
        如
            int *pt = &num;
        pt是一个标识符, 他指定了一个存储地址的对象. 但是*pt不是标识符, 因为他不是一个名称. 然而其确实指定了一个对象. *pt与num指定的对象相同.
        指定对象的表达式被称为左值(指定内存位置上的内容). 所以num是标识符也是左值, *pt即是表达式也是左值.

        标识符用于访问对象, 可以用作用域(scope)和链接(linkage)描述标识符, 标识符的作用域和链接表明了程序的哪些部分可以使用他.
        不同的存储类别具有不同的存储期, 作用域和链接.

        标识符可以在源代码的多文件中共享, 可以用于特定文件的任意函数中, 可仅存在于他所在函数的执行期.
        对于并发编程, 对象可以在特定线程的执行期存在. 可以通过函数调用的方式显式分配释放内存.


作用域
    作用域描述程序可访问标识符的区域.
    从变量的使用空间上对变量进行约束.

    一个C变量的作用域可以是块作用域, 函数作用域, 函数原型作用域, 文件作用域.

    块作用域 block scope
        块是用一对花括号括起来的代码区域. 例如整个函数体是一个块, 函数中的任意复合语句也是一个块.
        定义在块中的变量具有块作用域(block scope), 块作用域变量的可见范围是从定义处到包含该定义的块的末尾.
        另外, 虽然函数的形式参数声明在函数的左花括号前, 但是他们也是具有块作用域, 属于函数体这个块.

    函数作用域 function scope
        函数作用域仅用于goto语句标签.
        即使一个标签首次出现在函数内层块中, 他的作用域也延伸至整个函数.
        如果在两个块中使用相同的标签会很混乱, 标签的函数作用域防止了这样的事情发生.

    函数原型作用域 funciton prototype scope
        函数原型作用域用于函数原型中的形参名(变量名)
        函数原型作用域的范围是从形参定义处到原型声明结束.
        编译器在处理函数原型中的形参时只关心他的类型, 而形参名(如果没有省略)通常无关紧要.
        只有在变长数组中, 形参名才有用

    文件作用域 file scope
        变量定义在函数的外面, 便具有文件作用域(file scope).
        具有文件作用域的变量, 从他的定义处到该定义所在文件的末尾均可见.
        因为具有文件作用域的变量可以应用于多个函数, 所以这样的变量也叫称为全局变量(global variable)

        补充
            #include 宏指令实际上用被包含头文件内容的源文件代码替换该指令位置.
            所以编译器把源代码文件和所有头文件都看成是一个包含信息的单独文件. 这个文件被称为翻译单元(translation unit).
            描述一个具有文件作用域的变量时, 他的实际可见范围是整个翻译单元.
            如果程序由多个源代码文件组成, 那么该程序也将由多个翻译单元组成. 每个翻译单元均对应一个源代码文件和他所包含的文件.

        所以通过#include 宏指令包含到其他文件中的声明, 就好像直接写在那些文件中一样, 它们的作用域不限于头文件的文件尾. 而是在声明开始到最后.


链接
    C变量有3种链接属性, 外部链接, 内部链接, 无链接.

    无链接
        具有块作用域, 函数作用域, 函数原型作用域的变量是无链接变量. 
        这意味着这些变量属于定义他们的块, 函数, 函数原型私有.

    内部链接, 外部链接
        具有文件作用域的变量可以是内部链接, 外部链接. 
        外部链接可以在多个翻译单元中使用, 即多个编译的文件上(注意编译中只能有一个main)
        内部链接变量只能在其定义声明的翻译单元中使用

        只有当程序由多个翻译单元组成时, 才体现区别内部链接和外部链接的重要性.

        如
            // 在函数外, 具有文件作用域, 即全局变量
            int num1 = 5;   // 文件作用域, 外部链接, 可以被其他文件引用
            static int num2 = 4;   // 文件作用域, 内部链接, 只能在所在文件中使用

            int main(){
                ...
            }

    C标准用"内部链接的文件作用域"描述仅限于所在的一个翻译单元(即一个源代码文件和他所包含的头文件)的作用域,
        用"外部链接的文件作用域"描述可延伸至其他翻译单元的作用域.
    外部链接的文件作用域可简称为全局作用域或程序作用域, 内部链接的文件作用域可简称为文件作用域

    在函数外声明的全局变量, 如果声明时用static, 为内部链接, 只能在该具有该文件的翻译单元中使用
    在函数外声明的全局变量, 如果声明时没有使用static, 为外部链接, 那么由多个文件组成的翻译单元也可以使用该变量


存储期 storage duration
    作用域和链接描述了标识符的可见性. 存储期描述了通过这些标识符访问的对象的生存期.
    关系到变量在内存中的存放位置, 由此决定了变量的保留时间和变量的作用范围.
    从变量的使用时间上对变量进行约束

    C对象有四种存储期, 静态存储期, 线程存储期, 自动存储期, 动态分配存储期

    静态存储期
        所有的文件作用域变量(全局变量)具有静态存储期. 即包含了具有内部链接或外部链接的文件作用域变量.
        如果对象具有静态存储期, 在开始执行程序时为其分配内存, 直到程序执行完毕才释放, 即程序的执行期间一直存在. 
        注意
            对于文件作用域变量, 关键字static表明了其链接属性, 而非存储期.
            以static声明的文件作用域变量具有内部链接, 未以static声明的文件作用域变量具有外部链接.

    线程存储期
        线程存储期用于并发程序设计, 程序执行可被分为多个线程. 
        具有线程存储期的对象, 从被声明时到线程结束一直存在. 
        以关键字_Thread_local声明一个对象时, 每个线程都获得该变量的私有备份.

    自动存储期
        块作用域的变量通常都具有自动存储期. 
        当程序进入定义这些变量的块时, 为这些变量分配内存. 当退出这个块时, 释放刚刚为变量分配的内存.
        这种做法相当于把自动变量占用的内存视为一个可重复使用的工作区或暂存区.
        注意, 变长数组稍有不同, 他们的存储期从声明处到块的末尾, 而不是从块的开始到块的末尾.

    动态分配存储期
        使用动态内存分配函数分配的内存块, 一直存在直到使用free()释放.
        一般具有块作用域. 即在其分配块中可见.

    块作用域的变量也能具有静态存储期. 只需把在块中声明的变量前面加上关键字static
        void fun(){
            static int num = 0;
            ...
        }
    变量num存储在静态内存中, 他从程序被载入到程序结束期间都存在. 但是其作用域是在fun函数中的. 只有在执行该函数时, 才能使用num访问他所指定的对象.
